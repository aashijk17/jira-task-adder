"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalInvocationService = void 0;
const tslib_1 = require("tslib");
const util_1 = require("../util");
const cli_shared_1 = require("@forge/cli-shared");
const zlib = tslib_1.__importStar(require("node:zlib"));
const DEFAULT_INVOCATION_TIMEOUT = 25;
class LocalInvocationService {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    async invoke(handler, request) {
        this.logger.info('');
        this.logger.info((0, util_1.formatInvocation)(handler, request));
        const sandbox = util_1.SandboxesContainer.get()[handler];
        if (!sandbox) {
            throw new cli_shared_1.ValidationError(cli_shared_1.Text.tunnel.error.handler.notFound(handler));
        }
        const timeout = request._meta.timeout ?? DEFAULT_INVOCATION_TIMEOUT;
        const tunnelWarningTimeout = setTimeout(() => {
            this.logger.warn(cli_shared_1.Text.tunnel.invocationTimeout(timeout));
        }, timeout * 1000);
        const { body, metrics, success, error, metricsCompressed } = await sandbox.execute(request);
        clearTimeout(tunnelWarningTimeout);
        LocalInvocationService.printMetrics(metrics, metricsCompressed, this.logger);
        return { body, metrics, success, error, metricsCompressed };
    }
    static INTERNAL_METRICS = ['execute.setup-request-context', 'invoke.setup-isolate'];
    static printMetrics = (metrics, metricsCompressed, logger) => {
        if (metrics?.length) {
            if (metricsCompressed) {
                metrics = JSON.parse(zlib.unzipSync(Buffer.from(metricsCompressed, 'base64')).toString());
            }
            logger.debug(`Metrics: ${JSON.stringify(metrics?.filter((m) => !LocalInvocationService.INTERNAL_METRICS.includes(m.name)), null, 2)}`);
        }
    };
}
exports.LocalInvocationService = LocalInvocationService;
