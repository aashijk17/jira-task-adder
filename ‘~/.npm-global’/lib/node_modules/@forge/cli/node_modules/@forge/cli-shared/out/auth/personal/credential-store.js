"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCredentialStore = exports.CredentialStoreImpl = exports.KeytarAccessError = exports.NoKeytarError = exports.NoTokenInStoreError = exports.personalApiCredentialsValidatedShape = exports.personalApiCredentialsShape = exports.API_TOKEN_KEY = exports.EMAIL_KEY = void 0;
const tslib_1 = require("tslib");
const os_1 = require("os");
const Either_1 = require("fp-ts/lib/Either");
const t = tslib_1.__importStar(require("io-ts"));
const cache_1 = require("../../cache");
const instruction_1 = require("../instruction");
const graphql_1 = require("../../graphql");
const shared_1 = require("../../shared");
const ui_1 = require("../../ui");
exports.EMAIL_KEY = 'FORGE_EMAIL';
exports.API_TOKEN_KEY = 'FORGE_API_TOKEN';
const KEYTAR_SERVICE = 'Atlassian';
const CACHE_CREDENTIALS_KEY = 'forge-credentials';
var KeytarAccount;
(function (KeytarAccount) {
    KeytarAccount["DEV"] = "Ecosystem-staging";
    KeytarAccount["STG"] = "Ecosystem-staging";
    KeytarAccount["PROD"] = "Ecosystem";
    KeytarAccount["FEDRAMP_MODERATE_STAGING"] = "Ecosystem-fedm-staging";
    KeytarAccount["FEDRAMP_MODERATE_PROD"] = "Ecosystem-fedm-prod";
})(KeytarAccount || (KeytarAccount = {}));
function getKeytar() {
    try {
        return require('keytar');
    }
    catch {
        return null;
    }
}
exports.personalApiCredentialsShape = t.type({
    email: t.string,
    token: t.string
});
exports.personalApiCredentialsValidatedShape = t.type({
    email: t.string,
    token: t.string,
    accountId: t.string
});
class NoTokenInStoreError extends shared_1.UserError {
    constructor() {
        super(ui_1.Text.error.noTokenStored);
    }
}
exports.NoTokenInStoreError = NoTokenInStoreError;
class NoKeytarError extends shared_1.UserError {
    constructor() {
        super(ui_1.Text.error.noKeytar);
    }
}
exports.NoKeytarError = NoKeytarError;
class KeytarAccessError extends shared_1.UserError {
}
exports.KeytarAccessError = KeytarAccessError;
class CredentialStoreImpl {
    logger;
    instructionsURL;
    keytar;
    cachedConfig;
    userRepository;
    keytarAccount;
    constructor(logger, instructionsURL, keytar, cachedConfig, userRepository) {
        this.logger = logger;
        this.instructionsURL = instructionsURL;
        this.keytar = keytar;
        this.cachedConfig = cachedConfig;
        this.userRepository = userRepository;
        this.keytarAccount = (0, graphql_1.getEnvironmentConfig)(KeytarAccount);
    }
    wrapKeytarError(e) {
        const message = (0, shared_1.wrapError)(e).message;
        let error;
        const currentPlatform = (0, os_1.platform)();
        switch (currentPlatform) {
            case 'darwin':
                error = ui_1.Text.error.keytarAccessError.mac(message);
                break;
            case 'linux':
                error = ui_1.Text.error.keytarAccessError.linux(message);
                break;
            case 'win32':
                error = ui_1.Text.error.keytarAccessError.windows(message);
                break;
            default:
                error = ui_1.Text.error.keytarAccessError.other(message);
        }
        throw new KeytarAccessError(error);
    }
    decodeCredentials(credentialsString) {
        if (!credentialsString) {
            throw new NoTokenInStoreError();
        }
        let credentials;
        try {
            credentials = JSON.parse(credentialsString);
        }
        catch {
            throw new NoTokenInStoreError();
        }
        const decodeResult = exports.personalApiCredentialsValidatedShape.decode(credentials);
        if ((0, Either_1.isLeft)(decodeResult)) {
            throw new NoTokenInStoreError();
        }
        return decodeResult.right;
    }
    async getCredentialsKeytar(keytar) {
        let stringifiedPersonalApiCredentials;
        try {
            stringifiedPersonalApiCredentials = await keytar.getPassword(KEYTAR_SERVICE, this.keytarAccount);
        }
        catch (e) {
            this.wrapKeytarError(e);
        }
        if (!stringifiedPersonalApiCredentials) {
            return undefined;
        }
        return this.decodeCredentials(stringifiedPersonalApiCredentials);
    }
    popInsecurePlaintextCredentials() {
        const result = this.cachedConfig.get(CACHE_CREDENTIALS_KEY);
        if (result) {
            this.logger.warn(ui_1.Text.warning.plaintextCredentialsFound(this.instructionsURL));
            this.deleteInsecurePlaintextCredentials();
        }
        return result;
    }
    deleteInsecurePlaintextCredentials() {
        this.cachedConfig.delete(CACHE_CREDENTIALS_KEY);
    }
    async getCredentials() {
        let result;
        const plaintextCredentials = this.popInsecurePlaintextCredentials();
        if (plaintextCredentials) {
            if (this.keytar) {
                await this.setCredentials(plaintextCredentials);
                this.logger.warn(ui_1.Text.warning.plaintextCredentialsMigrated);
            }
            else {
                this.logger.warn(ui_1.Text.warning.plaintextCredentialsNotMigrated);
            }
        }
        if (process.env[exports.API_TOKEN_KEY] && process.env[exports.EMAIL_KEY]) {
            const credentials = {
                email: process.env[exports.EMAIL_KEY],
                token: process.env[exports.API_TOKEN_KEY]
            };
            const { accountId } = await this.userRepository.getUser(credentials);
            result = { ...credentials, accountId };
        }
        else if (this.keytar) {
            result = await this.getCredentialsKeytar(this.keytar);
        }
        if (result) {
            return result;
        }
        throw new NoTokenInStoreError();
    }
    async setCredentials(credentials) {
        if (this.keytar) {
            try {
                await this.keytar.setPassword(KEYTAR_SERVICE, this.keytarAccount, JSON.stringify(credentials));
            }
            catch (e) {
                throw new NoKeytarError();
            }
        }
        else {
            throw new NoKeytarError();
        }
    }
    async deleteCredentials() {
        if (this.keytar) {
            try {
                await this.keytar.deletePassword(KEYTAR_SERVICE, this.keytarAccount);
            }
            catch (e) {
            }
        }
        this.deleteInsecurePlaintextCredentials();
    }
}
exports.CredentialStoreImpl = CredentialStoreImpl;
function getCredentialStore(logger, userRepository) {
    const keytar = getKeytar();
    const cachedConfig = cache_1.CachedConf.getCache(cache_1.CONFIG_PROJECT_NAME);
    const instructionsUrl = (0, instruction_1.getInstructionsUrl)();
    return new CredentialStoreImpl(logger, instructionsUrl, keytar, cachedConfig, userRepository);
}
exports.getCredentialStore = getCredentialStore;
