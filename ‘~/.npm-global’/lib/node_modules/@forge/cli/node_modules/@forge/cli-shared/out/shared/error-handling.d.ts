import { Logger } from '../ui';
export declare type ErrorAnalytics = Record<string, string | string[] | boolean | undefined> & {
    isUserError?: boolean;
    requestId?: string;
};
export interface ErrorWithAnalytics {
    getAttributes(): ErrorAnalytics;
}
export declare function isUserError(e: any): boolean;
export declare function getErrorAttributes(e: any): ErrorAnalytics;
export declare class BaseError extends Error implements ErrorWithAnalytics {
    protected readonly requestId?: string | undefined;
    constructor(requestId?: string | undefined, message?: string);
    getAttributes(): ErrorAnalytics;
    isUserError(): boolean;
}
export declare class UserError extends BaseError {
    constructor(message?: string, requestId?: string | undefined);
    isUserError(): boolean;
}
export declare class HiddenError extends BaseError {
    constructor(message?: string, requestId?: string | undefined);
}
export interface AutoAnalyzeErrorInput {
    assistantName?: string;
    prompt?: string;
}
export declare const exitOnError: (logger: Logger, error: Error, hint?: string | null, autoAnalyzeErrorInput?: AutoAnalyzeErrorInput) => Promise<never>;
export declare const wrapError: (error: unknown) => Error;
export declare const assertIsError: (error: unknown) => asserts error is Error;
export declare class ValidationError extends UserError {
}
export declare class BundlerTSError extends UserError {
}
export interface TunnelErrorDetails {
    __tunnel_error__: true;
    name: string;
    attributes: ErrorAnalytics;
}
export declare class ApplicationCompileError extends UserError {
}
export declare class UIPromptError extends BaseError {
    private readonly isTtyError;
    constructor(message?: string, isTtyError?: boolean);
    isUserError(): boolean;
}
export declare class PartialInstallationError extends UserError {
    constructor(message?: string);
}
export declare class MissingCreatorError extends BaseError {
    constructor(message?: string);
}
//# sourceMappingURL=error-handling.d.ts.map