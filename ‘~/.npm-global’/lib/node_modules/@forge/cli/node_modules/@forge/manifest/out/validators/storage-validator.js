"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageValidator = void 0;
const text_1 = require("../text");
const utils_1 = require("../utils");
class StorageValidator {
    entityAttributeMaxLength = 30;
    entityAttributesMaxCount = 50;
    entityIndexesMaxCount = 7;
    reservedIndexName = 'by-key';
    async validate(manifest) {
        const validationErrors = [];
        validationErrors.push(...this.validateSqlModules(manifest));
        validationErrors.push(...this.validateCustomEntities(manifest));
        return {
            success: validationErrors.length === 0,
            manifestObject: manifest,
            ...(validationErrors.length ? { errors: validationErrors } : {})
        };
    }
    validateSqlModules(manifest) {
        const validationErrors = [];
        const sqlModules = manifest?.typedContent?.modules?.sql;
        if (sqlModules && sqlModules.length) {
            if (sqlModules.length > 1) {
                validationErrors.push({
                    message: `Found ${sqlModules.length} SQL modules; only one is allowed.`,
                    reference: text_1.References.Modules,
                    level: 'error',
                    ...(0, utils_1.findPosition)('sql', manifest.yamlContentByLine)
                });
            }
        }
        return validationErrors;
    }
    validateCustomEntities(manifest) {
        const validationErrors = [];
        const entities = manifest?.typedContent?.app?.storage?.entities;
        if (entities) {
            entities.forEach((entity) => {
                const { name, attributes } = entity;
                if (Object.keys(attributes).length > this.entityAttributesMaxCount) {
                    validationErrors.push({
                        message: text_1.errors.app.storage.entities.tooManyAttributes(name, this.entityAttributesMaxCount),
                        reference: text_1.References.App,
                        level: 'error',
                        ...(0, utils_1.findPosition)('entities', manifest.yamlContentByLine)
                    });
                }
                Object.keys(attributes).forEach((attributeKey) => {
                    if (attributeKey.length > this.entityAttributeMaxLength) {
                        validationErrors.push({
                            message: text_1.errors.app.storage.entities.attributeNameTooLong(name, attributeKey, this.entityAttributeMaxLength),
                            reference: text_1.References.App,
                            level: 'error',
                            ...(0, utils_1.findPosition)('entities', manifest.yamlContentByLine)
                        });
                    }
                });
                if (entity.indexes) {
                    const { indexes } = entity;
                    if (indexes.length > this.entityIndexesMaxCount) {
                        validationErrors.push({
                            message: text_1.errors.app.storage.entities.tooManyIndexes(name, this.entityIndexesMaxCount),
                            reference: text_1.References.App,
                            level: 'error',
                            ...(0, utils_1.findPosition)('entities', manifest.yamlContentByLine)
                        });
                    }
                    const indexName = [];
                    const indexRange = [];
                    const indexPartition = [];
                    indexes.forEach((index) => {
                        if (typeof index === 'string') {
                            indexRange.push(index);
                        }
                        else if (typeof index === 'object') {
                            indexName.push(index.name);
                            indexRange.push(...index.range);
                            if (index.partition) {
                                indexPartition.push(...index.partition);
                            }
                        }
                    });
                    if (indexName.find((name) => name === this.reservedIndexName)) {
                        validationErrors.push({
                            message: text_1.errors.app.storage.entities.reservedIndexName(name, this.reservedIndexName),
                            reference: text_1.References.App,
                            level: 'error',
                            ...(0, utils_1.findPosition)('entities', manifest.yamlContentByLine)
                        });
                    }
                    indexRange.forEach((range) => {
                        if (!Object.keys(attributes).length || !attributes[range]) {
                            validationErrors.push({
                                message: text_1.errors.app.storage.entities.invalidIndexRange(name, range),
                                reference: text_1.References.App,
                                level: 'error',
                                ...(0, utils_1.findPosition)('entities', manifest.yamlContentByLine)
                            });
                        }
                    });
                    indexPartition.forEach((partition) => {
                        if (!Object.keys(attributes).length || !attributes[partition]) {
                            validationErrors.push({
                                message: text_1.errors.app.storage.entities.invalidIndexPartition(name, partition),
                                reference: text_1.References.App,
                                level: 'error',
                                ...(0, utils_1.findPosition)('entities', manifest.yamlContentByLine)
                            });
                        }
                    });
                }
            });
        }
        return validationErrors;
    }
}
exports.StorageValidator = StorageValidator;
