"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductVerifier = void 0;
const tslib_1 = require("tslib");
const linter_interface_1 = require("../../../linter-interface");
const verifier_interface_1 = require("../../verifier-interface");
const cli_shared_1 = require("@forge/cli-shared");
const manifest_1 = require("@forge/manifest");
const text_1 = require("../../../text");
const array_prototype_flatmap_1 = tslib_1.__importDefault(require("array.prototype.flatmap"));
class ProductVerifier extends verifier_interface_1.BaseLintIssueVerifier {
    pathMap;
    product;
    constructor(environment, manifest, pathMap, product) {
        super(environment, manifest);
        this.pathMap = pathMap;
        this.product = product;
    }
    getLintClass() {
        return linter_interface_1.LintClass.Error;
    }
    async process(apiCalls) {
        const rules = [];
        const lintCriteriaMatches = new Set();
        for (const apiCall of apiCalls) {
            const apiCallLookupResult = this.lookupApiCall(apiCall);
            if (apiCallLookupResult) {
                lintCriteriaMatches.add(apiCallLookupResult);
            }
        }
        for (const apiCall of lintCriteriaMatches) {
            if (!apiCall?.regex) {
                continue;
            }
            const missingScopes = await this.getMissingPermissionScopes(apiCall);
            for (const permission of missingScopes) {
                rules.push({
                    class: this.getLintClass(),
                    message: text_1.messages.verifiers.product.message((0, cli_shared_1.productDisplayName)(this.product), apiCall.method.toUpperCase(), this.pathMap.get(apiCall.regex)?.originalPath, permission),
                    reference: text_1.messages.verifiers.product.reference,
                    line: apiCall.line,
                    column: apiCall.column,
                    metadata: {
                        missingPermission: permission
                    }
                });
            }
        }
        return rules;
    }
    lookupApiCall(apiCall) {
        const pathWithoutQuery = apiCall.path.replace(/\?.+$/, '');
        for (const regex of this.pathMap.keys()) {
            if (regex.test(pathWithoutQuery)) {
                return {
                    ...apiCall,
                    regex,
                    path: pathWithoutQuery,
                    method: apiCall.method.toLowerCase()
                };
            }
        }
    }
    getMissingPermissionScopes(apiCall) {
        const current = this.getRequiredScopes(apiCall);
        const beta = this.getBetaScopes(apiCall);
        return (0, manifest_1.getMissingScopes)(this.manifest?.permissions?.scopes, { current, beta });
    }
    getRequiredScopes({ regex, method }) {
        if (!regex)
            return [];
        const oAuth2Scopes = this.pathMap.get(regex)?.methods[method]?.['x-atlassian-oauth2-scopes'];
        if (oAuth2Scopes) {
            return (0, array_prototype_flatmap_1.default)(oAuth2Scopes.filter((scope) => scope.state === 'Current').map((scope) => scope.scopes), (x) => x);
        }
        const swaggerEntries = this.pathMap.get(regex)?.methods[method]?.security;
        if (!swaggerEntries)
            return [];
        return swaggerEntries?.reduce((prev, curr) => [...prev, ...(curr['OAuth2'] || []), ...(curr['oAuthDefinitions'] || [])], []);
    }
    getBetaScopes({ regex, method }) {
        if (!regex)
            return [];
        const oAuth2Scopes = this.pathMap.get(regex)?.methods[method]?.['x-atlassian-oauth2-scopes'];
        if (!oAuth2Scopes)
            return [];
        return (0, array_prototype_flatmap_1.default)(oAuth2Scopes.filter((scope) => scope.state === 'Beta').map((scope) => scope.scopes), (x) => x);
    }
}
exports.ProductVerifier = ProductVerifier;
