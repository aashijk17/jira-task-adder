"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebpackBundler = exports.getCompiler = exports.handleWebpackCompilationResult = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const webpack_1 = tslib_1.__importDefault(require("webpack"));
const cli_shared_1 = require("@forge/cli-shared");
const metadata_1 = require("./metadata");
const text_1 = require("./text");
function handleWebpackCompilationResult(logger, err, stats) {
    if (err) {
        throw err;
    }
    if (!stats) {
        throw new Error('bundle function callback returns empty stats');
    }
    const info = stats.toJson();
    if (stats.hasErrors() && info.errors) {
        const isTSError = info.errors.every((e) => e.message.includes('[tsl]'));
        if (isTSError) {
            const formattedErrors = info.errors.map((error) => {
                return error.message.replace(/\.?.+.tsx?(?!\([0-9]\,[0-9]\))$/gm, '');
            });
            throw new cli_shared_1.BundlerTSError(text_1.Text.typescriptError(formattedErrors));
        }
        else {
            throw new Error(text_1.Text.genericBundlingError(info.errors.map((e) => e.message)));
        }
    }
    if (stats.hasWarnings() && info.warnings) {
        for (const warning of info.warnings) {
            logger.warn(warning.message);
        }
    }
}
exports.handleWebpackCompilationResult = handleWebpackCompilationResult;
function getCompiler(config) {
    return (0, webpack_1.default)(config);
}
exports.getCompiler = getCompiler;
function getNodeModuleNames(stats) {
    const { modules } = stats.toJson({ modules: true });
    if (modules) {
        const filteredModuleNames = new Set();
        modules
            .map((m) => m.name || '')
            .forEach((name) => {
            const parts = name.match(/^\.\/node_modules\/([^/]+)\/([^/]+)/);
            if (parts) {
                const module = parts[1][0] === '@' ? `${parts[1]}/${parts[2]}` : parts[1];
                filteredModuleNames.add(module);
            }
            else if (name.includes('unsupported.js')) {
                filteredModuleNames.add(name.slice(name.indexOf('?')));
            }
        });
        return Array.from(filteredModuleNames);
    }
}
class WebpackBundler {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    async getOutput(args, config, stats) {
        const outputDir = config.output.path;
        const metadata = await (0, metadata_1.getMetadata)(this.logger, args.appDirectory, this.localModules(stats));
        if (stats) {
            metadata.modules = getNodeModuleNames(stats);
        }
        return { outputDir, metadata };
    }
    isRegularModule(name) {
        if (name.match(/^external "(?:node:)?([^:"]+)"$/)) {
            return false;
        }
        if (name.startsWith('webpack/runtime/')) {
            return false;
        }
        if (!path_1.default.extname(name).match(/^\.[cm]?[jt]sx?$/)) {
            return false;
        }
        return true;
    }
    localModules(stats) {
        const { modules } = stats.toJson({ modules: true });
        const result = new Set();
        const addModules = (modules) => {
            for (const module of modules) {
                if (module.modules) {
                    addModules(module.modules);
                }
                else if (module.name && this.isRegularModule(module.name)) {
                    result.add(module.name);
                }
            }
        };
        if (modules) {
            addModules(modules);
        }
        return result;
    }
    async runCompiler(args, config) {
        const compiler = getCompiler(config);
        return new Promise((resolve, reject) => {
            compiler.run(async (compilerError, stats) => {
                try {
                    handleWebpackCompilationResult(this.logger, compilerError, stats);
                    compiler.close((closeError) => {
                        if (closeError) {
                            reject(closeError);
                        }
                    });
                    resolve(await this.getOutput(args, config, stats));
                }
                catch (err) {
                    reject(err);
                }
            });
        });
    }
    async bundle(args) {
        const config = await this.getConfig(args);
        return await this.runCompiler(args, config);
    }
    async watch(args, watch) {
        const config = await this.getConfig(args);
        const compiler = getCompiler(config);
        let isFirstRun = true;
        compiler.hooks.watchRun.tapAsync('watchRun', async (_, watchRunCallback) => {
            if (!isFirstRun) {
                await watch.onBuildWillStart();
            }
            watchRunCallback();
        });
        return new Promise((resolve, reject) => {
            const watching = compiler.watch({ poll: 1000 }, async (compilerError, stats) => {
                try {
                    handleWebpackCompilationResult(this.logger, compilerError, stats);
                    this.logger.info(cli_shared_1.LogColor.trace(args.successMessage));
                    const result = await this.getOutput(args, config, stats);
                    if (isFirstRun) {
                        isFirstRun = false;
                        resolve({ result, stop: () => watching.close(() => void 0) });
                    }
                    else {
                        await watch.onBuildFinished(null, result);
                    }
                }
                catch (err) {
                    await watch.onBuildFinished(err);
                    isFirstRun = false;
                    reject(err);
                }
            });
        });
    }
}
exports.WebpackBundler = WebpackBundler;
