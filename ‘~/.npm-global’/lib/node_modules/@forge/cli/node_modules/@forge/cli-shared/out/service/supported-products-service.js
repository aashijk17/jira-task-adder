"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TEST_ONLY_EXPORTS = exports.isBitbucketProduct = exports.SupportedProductsService = void 0;
const url_1 = require("url");
const shared_1 = require("../shared");
const ui_1 = require("../ui");
const SUPPORTED_PRODUCTS_DEFINITIONS = [
    {
        name: 'Jira',
        productType: 'sited',
        special: {
            supportedByCrossProductApps: true
        }
    },
    {
        name: 'Confluence',
        productType: 'sited',
        special: {
            supportedByCrossProductApps: true
        }
    },
    {
        name: 'Compass',
        productType: 'sited',
        special: {
            supportedByCrossProductApps: true
        }
    },
    {
        name: 'Teamwork Graph',
        productType: 'sited',
        special: {
            isEnabledByFeatureGate: async (statsigService) => statsigService.isTeamworkGraphProductSupported()
        }
    },
    {
        name: 'Bitbucket',
        productType: 'workspace'
    }
];
class SupportedProductEntry {
    productName;
    productType;
    supportedByCrossProductApps;
    constructor(productName, productType, supportedByCrossProductApps) {
        this.productName = productName;
        this.productType = productType;
        this.supportedByCrossProductApps = supportedByCrossProductApps;
    }
}
async function resolveEnabledProducts(statsigService) {
    const productDefinitionWithIsEnabledResolved = await Promise.all(SUPPORTED_PRODUCTS_DEFINITIONS.map(async (pd) => {
        const enabledByFeatureGateResolver = pd.special?.isEnabledByFeatureGate;
        const isEnabled = enabledByFeatureGateResolver ? await enabledByFeatureGateResolver(statsigService) : true;
        return { pd, isEnabled };
    }));
    const definitionsForEnabledProducts = productDefinitionWithIsEnabledResolved
        .filter(({ isEnabled }) => isEnabled)
        .map(({ pd }) => pd);
    return definitionsForEnabledProducts.map((pd) => {
        return new SupportedProductEntry(pd.name, pd.productType, pd.special?.supportedByCrossProductApps ?? false);
    });
}
class SupportedProductEntriesHolder {
    value;
    constructor(value) {
        this.value = value;
    }
    async initialize(valueProvider) {
        if (this.value) {
            throw new Error('SupportedProductsService was already initialized - is initialization called multiple times?');
        }
        this.value = await valueProvider();
    }
    get() {
        if (!this.value) {
            throw new Error('SupportedProductsService is not initialized - are you calling it from some constructor?');
        }
        return this.value;
    }
}
class SupportedProductsService {
    supportedProductEntriesHolder;
    constructor(supportedProductEntries) {
        this.supportedProductEntriesHolder = new SupportedProductEntriesHolder(supportedProductEntries);
    }
    async initializeWithSupportedProducts(statsigService) {
        await this.supportedProductEntriesHolder.initialize(async () => await resolveEnabledProducts(statsigService));
    }
    getFilteredSupportedProducts(filter) {
        return this.supportedProductEntriesHolder
            .get()
            .filter((p) => filter(p))
            .map((p) => p.productName);
    }
    getSupportedProducts() {
        return this.supportedProductEntriesHolder.get().map((p) => p.productName);
    }
    getSupportedSecondaryProductsForXPA(requiredProducts) {
        const requiredProductsNames = requiredProducts.map((p) => (0, shared_1.productDisplayName)(p));
        return this.getFilteredSupportedProducts((p) => p.supportedByCrossProductApps && !requiredProductsNames.includes(p.productName));
    }
    validateSupportedProduct(productNameInput) {
        const productName = (0, shared_1.productDisplayName)(productNameInput);
        const supportedProducts = this.getSupportedProducts();
        if (supportedProducts.includes(productName)) {
            return productName;
        }
        else {
            throw new shared_1.ValidationError(ui_1.Text.error.invalidContext([]));
        }
    }
    isWorkspaceProduct(product) {
        return this.getFilteredSupportedProducts((p) => p.productType === 'workspace').includes((0, shared_1.productDisplayName)(product));
    }
    validateSite(site, product) {
        const trySites = [site, `https://${site}`];
        for (const trySite of trySites) {
            try {
                const urlObj = new url_1.URL(trySite);
                if (product && this.isWorkspaceProduct(product)) {
                    return urlObj;
                }
                urlObj.pathname = '/';
                return urlObj;
            }
            catch {
            }
        }
        throw new shared_1.ValidationError(ui_1.Text.error.invalidSite);
    }
}
exports.SupportedProductsService = SupportedProductsService;
const isBitbucketProduct = (product) => {
    return (0, shared_1.productDisplayName)(product) === 'Bitbucket';
};
exports.isBitbucketProduct = isBitbucketProduct;
exports.TEST_ONLY_EXPORTS = {
    resolveEnabledProducts
};
