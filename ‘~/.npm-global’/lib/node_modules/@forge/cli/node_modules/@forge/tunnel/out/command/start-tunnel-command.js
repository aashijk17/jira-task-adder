"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartTunnelCommand = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@forge/cli-shared");
const node_cache_1 = tslib_1.__importDefault(require("node-cache"));
const portfinder_1 = require("portfinder");
const servers_1 = require("../servers");
const docker_compose_1 = require("docker-compose");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs"));
class InvalidTunnelConfigError extends cli_shared_1.UserError {
    constructor(message) {
        super(message);
    }
}
class StartTunnelCommand {
    getAppConfig;
    devServer;
    tunnelFactory;
    tunnelClient;
    functionHost;
    logger;
    configFile;
    tunnelServers = {};
    cspReporterServer;
    constructor(getAppConfig, devServer, tunnelFactory, tunnelClient, functionHost, logger, configFile) {
        this.getAppConfig = getAppConfig;
        this.devServer = devServer;
        this.tunnelFactory = tunnelFactory;
        this.tunnelClient = tunnelClient;
        this.functionHost = functionHost;
        this.logger = logger;
        this.configFile = configFile;
    }
    validateTunnelUrl(tunnelUrl) {
        if (!tunnelUrl) {
            return;
        }
        let parsedUrl;
        try {
            parsedUrl = new URL(tunnelUrl);
        }
        catch (error) {
            throw new InvalidTunnelConfigError(cli_shared_1.Text.tunnel.error.invalidSelfManagedTunnelUrl(tunnelUrl));
        }
        if (parsedUrl.protocol !== 'https:') {
            throw new InvalidTunnelConfigError(cli_shared_1.Text.tunnel.error.invalidSelfManagedTunnelUrlProtocol(parsedUrl.protocol));
        }
    }
    validateTunnelPort(port) {
        if (port === undefined) {
            return;
        }
        if (port < 1 || port > 65535) {
            throw new InvalidTunnelConfigError(cli_shared_1.Text.tunnel.error.invalidSelfManagedTunnelPort(port.toString()));
        }
    }
    stopServices = async (appId, environmentKey, containersDockerComposeFiles) => {
        await Promise.all([
            this.functionHost.stopWatching(),
            this.tunnelClient.unregisterTunnels(appId, environmentKey),
            this.tunnelFactory.closeTunnel(),
            this.devServer.stop(),
            ...Object.values(this.tunnelServers).map((server) => server.stop()),
            this.cspReporterServer?.stop(),
            this.stopDockerComposeStack(containersDockerComposeFiles)
        ]);
    };
    stopDockerComposeStack = async (composeFiles) => {
        if (!composeFiles || Object.keys(composeFiles).length === 0)
            return;
        const { services } = await this.configFile.readConfig();
        const serviceWithTunnelConfigExists = services?.some((service) => service.containers?.some((container) => {
            return !!container.tunnel;
        }));
        if (!services || services.length === 0 || !serviceWithTunnelConfigExists)
            return;
        await Promise.all(Object.entries(composeFiles).map(async ([serviceKey, file]) => {
            try {
                await (0, docker_compose_1.downAll)({ cwd: '.', log: true, config: file, composeOptions: [`-p${serviceKey}`] });
                await this.deleteDockerComposeFile(file);
            }
            catch (err) {
                throw new Error(cli_shared_1.Text.tunnel.unableToStopDockerComposeStack(serviceKey, err.message ?? 'Unknown Error Occurred.'));
            }
        }));
    };
    deleteDockerComposeFile = async (composeFile) => {
        if (fs.existsSync(composeFile)) {
            fs.unlinkSync(composeFile);
        }
        const hiddenDir = path.join(process.cwd(), '.services');
        if (fs.existsSync(hiddenDir)) {
            const files = fs.readdirSync(hiddenDir);
            if (files.length == 0) {
                fs.rmdirSync(hiddenDir);
            }
        }
    };
    startFaaSTunnelServer = async ({ port, appId, environmentKey, tunnelUrl }) => {
        const { permissions = {}, remotes = [] } = await this.configFile.readConfig();
        const serverInfo = await this.devServer.start(port, permissions, remotes);
        let faasTunnelUrl;
        if (tunnelUrl) {
            faasTunnelUrl = new URL(tunnelUrl);
        }
        else {
            const { id, token, url } = await this.tunnelClient.setupTunnel(appId, environmentKey);
            faasTunnelUrl = await this.tunnelFactory.establishTunnel({
                port: serverInfo.port,
                id,
                token,
                tunnelUrl: url
            });
        }
        return {
            ...serverInfo,
            tunnelUrl: faasTunnelUrl
        };
    };
    startResourceBasedTunnelsServers = async (resourceDetails, options) => {
        const { permissions = {}, remotes = [], translations: i18nConfig } = await this.configFile.readConfig();
        const cspReporterPort = await (0, portfinder_1.getPortPromise)({ port: 4000 });
        if (resourceDetails.length === 0)
            return [];
        this.cspReporterServer = new servers_1.CspReporterServer(cspReporterPort, this.logger, new node_cache_1.default());
        await this.cspReporterServer.start();
        return await Promise.all(resourceDetails.map(async (rd) => {
            const { key, resourceType } = rd;
            const port = options.resourcePortMap[key];
            const tunnelServer = resourceType === 'nativeUI' ? servers_1.NativeUITunnelServer : servers_1.CustomUITunnelServer;
            this.tunnelServers[key] = new tunnelServer({
                ...rd,
                port,
                host: options.host,
                logger: this.logger,
                cspReporterServerPort: cspReporterPort,
                permissions,
                remotes,
                i18nConfig
            });
            return this.tunnelServers[key].start();
        }));
    };
    async execute(options, containersDockerComposeFiles) {
        const { id: appId } = await this.getAppConfig();
        const { port, environmentKey, url } = options;
        this.validateTunnelUrl(url);
        this.validateTunnelPort(port);
        const allResources = await this.configFile.getResources();
        try {
            const faasTunnelServer = await this.startFaaSTunnelServer({
                port,
                appId,
                environmentKey,
                tunnelUrl: url
            });
            const customUITunnelsServers = await this.startResourceBasedTunnelsServers(allResources, options);
            const tunnelDefinitions = {
                faasTunnelUrl: faasTunnelServer.tunnelUrl,
                customUI: customUITunnelsServers.map(({ tunnelUrl, resourceKey }) => ({
                    tunnelUrl,
                    resourceKey
                }))
            };
            await this.tunnelClient.registerTunnels(appId, environmentKey, tunnelDefinitions);
            const stopFunction = async () => this.stopServices(appId, environmentKey, containersDockerComposeFiles);
            this.devServer.setErrorHandler?.(async (error) => {
                await this.stopServices(appId, environmentKey, containersDockerComposeFiles);
                await (0, cli_shared_1.exitOnError)(this.logger, error);
            });
            const reloadSandboxes = async (bundledCode, tunnelOptions) => {
                await this.functionHost.stopWatching();
                await this.functionHost.startWatching(bundledCode, tunnelOptions);
            };
            return {
                localPort: faasTunnelServer.port,
                tunnelDefinitions,
                stopFunction,
                reloadSandboxes,
                faasServer: faasTunnelServer.devServer,
                uiServers: customUITunnelsServers.map(({ devServer }) => devServer)
            };
        }
        catch (e) {
            try {
                await this.stopServices(appId, environmentKey, containersDockerComposeFiles);
            }
            catch { }
            throw e;
        }
    }
}
exports.StartTunnelCommand = StartTunnelCommand;
