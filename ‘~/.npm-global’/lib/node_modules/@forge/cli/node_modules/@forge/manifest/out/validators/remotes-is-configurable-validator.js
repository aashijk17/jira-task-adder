"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemotesIsUserConfigurableValidator = void 0;
const text_1 = require("../text");
const utils_1 = require("../utils");
class RemotesIsUserConfigurableValidator {
    async validateOld(manifest) {
        if (!manifest?.typedContent?.remotes) {
            return {
                success: true,
                manifestObject: manifest
            };
        }
        const remotes = manifest.typedContent.remotes;
        const validationErrors = [];
        remotes?.forEach((remote) => {
            if (remote.baseUrl === undefined) {
                validationErrors.push({
                    message: text_1.errors.modules.remote.baseUrlNotPresent(remote.key),
                    reference: text_1.References.App,
                    level: 'error',
                    ...(0, utils_1.findPosition)(remote.key, manifest.yamlContentByLine)
                });
            }
        });
        return {
            success: validationErrors.length === 0,
            manifestObject: manifest,
            errors: validationErrors
        };
    }
    async validateNew(manifest) {
        if (!manifest?.typedContent?.remotes) {
            return {
                success: true,
                manifestObject: manifest
            };
        }
        const remotes = manifest.typedContent.remotes;
        const validationErrors = [];
        const configurableRemotesAllowed = manifest.typedContent.permissions?.configurable?.enabled ?? false;
        remotes?.forEach((remote) => {
            if (!configurableRemotesAllowed) {
                if (remote.configurable !== undefined) {
                    validationErrors.push({
                        message: text_1.errors.modules.remote.userConfigurationPermissionsMismatch(remote.key),
                        reference: text_1.References.App,
                        level: 'error',
                        ...(0, utils_1.findPosition)(remote.key, manifest.yamlContentByLine)
                    });
                }
                if (remote.configurable === undefined && remote.baseUrl === undefined) {
                    validationErrors.push({
                        message: text_1.errors.modules.remote.baseUrlNotPresent(remote.key),
                        reference: text_1.References.App,
                        level: 'error',
                        ...(0, utils_1.findPosition)(remote.key, manifest.yamlContentByLine)
                    });
                }
            }
            else {
                if (remote.configurable === undefined && remote.baseUrl === undefined) {
                    validationErrors.push({
                        message: text_1.errors.modules.remote.neitherBaseUrlNorUserConfigurationPresent(remote.key),
                        reference: text_1.References.App,
                        level: 'error',
                        ...(0, utils_1.findPosition)(remote.key, manifest.yamlContentByLine)
                    });
                }
                else if (remote.configurable !== undefined && remote.baseUrl !== undefined) {
                    validationErrors.push({
                        message: text_1.errors.modules.remote.bothBaseUrlAndUserConfigurationPresent(remote.key),
                        reference: text_1.References.App,
                        level: 'error',
                        ...(0, utils_1.findPosition)(remote.key, manifest.yamlContentByLine)
                    });
                }
            }
        });
        return {
            success: validationErrors.length === 0,
            manifestObject: manifest,
            errors: validationErrors
        };
    }
    async validate(manifest) {
        if (!(0, utils_1.configurableRemotesEnabled)()) {
            return this.validateOld(manifest);
        }
        else {
            return this.validateNew(manifest);
        }
    }
}
exports.RemotesIsUserConfigurableValidator = RemotesIsUserConfigurableValidator;
