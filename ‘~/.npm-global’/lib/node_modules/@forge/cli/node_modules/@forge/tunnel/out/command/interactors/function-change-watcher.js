"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalFunctionHost = exports.MEMORY_LIMIT = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const promises_1 = require("fs/promises");
const cli_shared_1 = require("@forge/cli-shared");
const runtime_1 = require("@forge/runtime");
const util_1 = require("../../util");
exports.MEMORY_LIMIT = 256;
class LocalFunctionHost {
    configFile;
    logger;
    createSandbox;
    currentTunnelOptions = cli_shared_1.defaultNoDebugTunnelOptions;
    constructor(configFile, logger, createSandbox) {
        this.configFile = configFile;
        this.logger = logger;
        this.createSandbox = createSandbox;
    }
    async startWatching(bundledCode, tunnelOptions = cli_shared_1.defaultNoDebugTunnelOptions) {
        this.currentTunnelOptions = tunnelOptions;
        const pathTo = (relativePath) => path_1.default.resolve(bundledCode.outputDir, relativePath);
        const manifestFilePath = pathTo(cli_shared_1.manifestFileName);
        const manifestContents = JSON.stringify(await this.configFile.readConfig());
        await (0, promises_1.writeFile)(manifestFilePath, manifestContents);
        await this.initializeSandboxes(bundledCode.outputDir, tunnelOptions);
        runtime_1.StaticInvocationEventEmitter.addListener(runtime_1.EVENT_P3_LOG, this.onRuntimeLog);
    }
    async stopWatching() {
        runtime_1.StaticInvocationEventEmitter.removeAllListeners();
    }
    onRuntimeLog = (event) => {
        this.logger.info((0, util_1.formatRuntimeLog)(event));
        if (event.logLevel === runtime_1.LogLevel.ERROR) {
            this.runAssistantErrorAnalysis(event);
        }
    };
    runAssistantErrorAnalysis = (event) => {
        const assistantName = this.currentTunnelOptions.assistantName;
        if (assistantName) {
            const errorMessage = JSON.stringify(event);
            const prompt = (0, cli_shared_1.createForgeTunnelErrorPrompt)(errorMessage);
            (0, cli_shared_1.runAssistant)(prompt, assistantName, this.logger).catch((error) => {
                this.logger.error(new Error(`Error analysis with ${assistantName}: ${error}`));
            });
        }
    };
    async initializeSandboxes(srcPath, tunnelOptions) {
        try {
            util_1.SandboxesContainer.stopSandboxes();
            const handlers = await this.configFile.getAppHandlers();
            const sandboxes = {};
            await Promise.all(handlers.map(async ({ module, func }) => {
                sandboxes[`${module}.${func}`] = await this.createSandbox({
                    modName: module,
                    appPath: srcPath,
                    handler: func,
                    debugPort: LocalFunctionHost.getDebuggerPort(module, func, tunnelOptions)
                });
            }));
            util_1.SandboxesContainer.updateSandboxes(sandboxes);
        }
        catch (error) {
            this.logger.error(error);
        }
    }
    static getDebuggerPort(modName, handler, tunnelOptions) {
        const sandboxName = `${modName}.${handler}`;
        if (!tunnelOptions.debug) {
            return undefined;
        }
        const index = (tunnelOptions.debugFunctionHandlers || []).findIndex((handler) => handler === sandboxName);
        if (index === -1) {
            return undefined;
        }
        return index + tunnelOptions.debugStartingPort;
    }
}
exports.LocalFunctionHost = LocalFunctionHost;
