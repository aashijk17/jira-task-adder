"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWrapperProvider = exports.NetworkWrapperProvider = exports.LocalWrapperProvider = exports.ParseWrapperCDNIndexError = exports.WrapperNetworkError = exports.LocalWrapperNotFoundError = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const cheerio_1 = require("cheerio");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const cli_shared_1 = require("@forge/cli-shared");
var RuntimeCDN;
(function (RuntimeCDN) {
    RuntimeCDN["DEV"] = "https://forge-node-runtime.stg-east.frontend.public.atl-paas.net/";
    RuntimeCDN["STG"] = "https://forge-node-runtime.stg-east.frontend.public.atl-paas.net/";
    RuntimeCDN["PROD"] = "https://forge-node-runtime.prod-east.frontend.public.atl-paas.net/";
    RuntimeCDN["FEDRAMP_MODERATE_STAGING"] = "https://forge-node-runtime.prod-east.frontend.public.atl-paas.net/";
    RuntimeCDN["FEDRAMP_MODERATE_PROD"] = "https://forge-node-runtime.prod-east.frontend.public.atl-paas.net/";
})(RuntimeCDN || (RuntimeCDN = {}));
class LocalWrapperNotFoundError extends cli_shared_1.UserError {
    constructor() {
        super('Local node runtime wrapper not found.');
    }
}
exports.LocalWrapperNotFoundError = LocalWrapperNotFoundError;
class WrapperNetworkError extends cli_shared_1.BaseError {
    constructor(message, requestId) {
        super(undefined, message);
    }
}
exports.WrapperNetworkError = WrapperNetworkError;
class ParseWrapperCDNIndexError extends cli_shared_1.BaseError {
    constructor(message, requestId) {
        super(requestId, message);
    }
}
exports.ParseWrapperCDNIndexError = ParseWrapperCDNIndexError;
var ScriptType;
(function (ScriptType) {
    ScriptType["WRAPPER"] = "wrapper";
    ScriptType["LOADER"] = "loader";
})(ScriptType || (ScriptType = {}));
class LocalWrapperProvider {
    filesystemReader;
    runtimePath;
    constructor(filesystemReader, runtimePath) {
        this.filesystemReader = filesystemReader;
        this.runtimePath = runtimePath;
    }
    async getLocalScript(scriptType) {
        const source = path_1.default.join(this.runtimePath, `dist/${scriptType}.js`);
        const script = await this.filesystemReader.readFileAsync(source);
        if (!script) {
            throw new LocalWrapperNotFoundError();
        }
        return {
            script,
            source,
            version: 'local'
        };
    }
    async getNodeRuntimeWrapper() {
        return await this.getLocalScript(ScriptType.WRAPPER);
    }
    async getNodeRuntimeLoader() {
        return await this.getLocalScript(ScriptType.LOADER);
    }
}
exports.LocalWrapperProvider = LocalWrapperProvider;
class NetworkWrapperProvider {
    statsigService;
    wrapper;
    loader;
    cdnUrl;
    constructor(statsigService) {
        this.statsigService = statsigService;
        this.cdnUrl = (0, cli_shared_1.getEnvironmentConfig)(RuntimeCDN);
    }
    async getScriptPathFromIndex(htmlContent, requestId, scriptType) {
        const html = (0, cheerio_1.load)(htmlContent, { xml: { xmlMode: false } });
        const scriptPath = html('script')
            ?.get()
            ?.find((asset) => asset.attribs['src']?.includes(scriptType))?.attribs['src'];
        if (typeof scriptPath !== 'string') {
            throw new ParseWrapperCDNIndexError(`Unable to parse source of runtime ${scriptType}.`, requestId);
        }
        return new URL(scriptPath, this.cdnUrl).toString();
    }
    getFileFromCDN = async (scriptType) => {
        try {
            const indexResponse = await (0, node_fetch_1.default)(this.cdnUrl);
            if (!indexResponse.ok) {
                throw new WrapperNetworkError(`Failed to fetch runtime component: ${this.cdnUrl} ${indexResponse.status}.`, (0, cli_shared_1.getAtlassianTraceId)(indexResponse.headers));
            }
            const source = await this.getScriptPathFromIndex(await indexResponse.text(), (0, cli_shared_1.getAtlassianTraceId)(indexResponse.headers), scriptType);
            const response = await (0, node_fetch_1.default)(source);
            if (!response.ok) {
                throw new WrapperNetworkError(`Failed to fetch runtime component: ${source.toString()} ${response.status}.`, (0, cli_shared_1.getAtlassianTraceId)(response.headers));
            }
            const script = await response.text();
            return {
                script,
                source,
                version: new URL(source).pathname
            };
        }
        catch (e) {
            if (e instanceof ParseWrapperCDNIndexError) {
                throw e;
            }
            throw new WrapperNetworkError(e instanceof Error ? e.message : 'Networking error when retrieving runtime component, retry the command.');
        }
    };
    async getNodeRuntimeWrapper() {
        if (!this.wrapper) {
            this.wrapper = await this.getFileFromCDN(ScriptType.WRAPPER);
        }
        return this.wrapper;
    }
    async getNodeRuntimeLoader() {
        if (!this.loader) {
            if (await this.statsigService.testForgeCliBundleRuntimeLoaderGate()) {
                this.loader = await this.getFileFromCDN(ScriptType.LOADER);
            }
        }
        return this.loader;
    }
}
exports.NetworkWrapperProvider = NetworkWrapperProvider;
const getWrapperProvider = ({ fileSystemReader, statsigService }) => {
    if (process.env.FORGE_RUNTIME_PATH) {
        return new LocalWrapperProvider(fileSystemReader, process.env.FORGE_RUNTIME_PATH);
    }
    return new NetworkWrapperProvider(statsigService);
};
exports.getWrapperProvider = getWrapperProvider;
