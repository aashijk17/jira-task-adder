"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeUITunnelServer = void 0;
const tslib_1 = require("tslib");
const webpack_dev_server_1 = tslib_1.__importDefault(require("webpack-dev-server"));
const bundler_1 = require("@forge/bundler");
const resource_tunnel_server_1 = require("./resource-tunnel-server");
const cli_shared_1 = require("@forge/cli-shared");
const url_1 = require("url");
class NativeUITunnelServer extends resource_tunnel_server_1.ResourceTunnelServer {
    tunnelArgs;
    server;
    outputDir;
    constructor(tunnelArgs) {
        super(tunnelArgs);
        this.tunnelArgs = tunnelArgs;
        const { key, path, port, permissions, remotes, i18nConfig } = tunnelArgs;
        const entrypoint = { name: key, path, functions: [] };
        const config = (0, bundler_1.getNativeUiBuildConfig)([entrypoint]);
        this.outputDir = config.output.path;
        const compiler = (0, bundler_1.getCompiler)({
            ...config,
            infrastructureLogging: {
                level: 'error'
            },
            stats: 'errors-only',
            watchOptions: {
                aggregateTimeout: 200,
                poll: 1000,
                ignored: '**/node_modules'
            }
        });
        this.server = new webpack_dev_server_1.default({
            port,
            host: '0.0.0.0',
            setupMiddlewares: (middlewares) => {
                const index = middlewares.findIndex((middleware) => middleware.name === 'webpack-dev-middleware');
                middlewares.splice(index, 0, {
                    name: 'custom-ui-scripts-middleware',
                    middleware: this.getCustomUIHtmlTransformMiddleware(permissions, remotes)
                });
                if (i18nConfig) {
                    middlewares.unshift({
                        name: 'i18n-resources-middleware',
                        middleware: this.getI18nResourcesMiddleware(i18nConfig)
                    });
                }
                middlewares.unshift({
                    name: 'logging-middleware',
                    middleware: (req, _, next) => {
                        this.logFileServed(req.url, (input) => cli_shared_1.Text.tunnel.customUI.fileServed(input, this.key));
                        next();
                    }
                });
                return middlewares;
            }
        }, compiler);
    }
    async start() {
        const { key, port } = this.tunnelArgs;
        return {
            port,
            devServer: this,
            resourceKey: key,
            tunnelUrl: new url_1.URL(`http://localhost:${port}`)
        };
    }
    async compileAndWatch({ onBuildWillStart, onBuildFinished }) {
        await this.server.start();
        const compiler = this.server.compiler;
        compiler.hooks.watchRun.tapAsync('watchRun', async (_, watchRunCallback) => {
            await onBuildWillStart();
            watchRunCallback();
        });
        let isFirstCompilation = true;
        return new Promise((resolve, reject) => {
            compiler.hooks.done.tapAsync('done', async (stats, doneCallback) => {
                try {
                    (0, bundler_1.handleWebpackCompilationResult)(this.logger, null, stats);
                    this.logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.tunnel.resourcesBundlingSucceeded));
                    const result = { outputDir: this.outputDir };
                    if (!isFirstCompilation) {
                        await onBuildFinished(null, result);
                    }
                    else {
                        isFirstCompilation = false;
                    }
                    resolve(result);
                }
                catch (err) {
                    await onBuildFinished(err);
                    isFirstCompilation = false;
                    reject(err);
                }
                finally {
                    doneCallback();
                }
            });
        });
    }
    async stop() {
        return this.server.stop();
    }
}
exports.NativeUITunnelServer = NativeUITunnelServer;
