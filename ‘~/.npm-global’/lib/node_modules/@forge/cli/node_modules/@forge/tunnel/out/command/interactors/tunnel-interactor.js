"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelInteractor = void 0;
const tslib_1 = require("tslib");
const readline_1 = tslib_1.__importDefault(require("readline"));
const bundler_1 = require("@forge/bundler");
const cli_shared_1 = require("@forge/cli-shared");
const multi_compiler_watcher_1 = require("./multi-compiler-watcher");
const fs_1 = tslib_1.__importDefault(require("fs"));
const chokidar_1 = tslib_1.__importDefault(require("chokidar"));
class TunnelInteractor {
    logger;
    statsigService;
    constructor(logger, statsigService) {
        this.logger = logger;
        this.statsigService = statsigService;
    }
    logTunnelStatus(localPort, tunnelOptions) {
        this.logger.info('');
        this.logger.info(cli_shared_1.Text.tunnel.startedServer(localPort, this.logger.debugEnabled) + '\n');
        if (tunnelOptions.url) {
            this.logger.warn(cli_shared_1.Text.tunnel.selfManagedTunnel(tunnelOptions.url, localPort));
        }
    }
    handleUserExitEvent(stopFunction, bundleMonitor, manifestFileWatcher) {
        return new Promise((resolve, reject) => {
            const rl = readline_1.default.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            const tunnelCleanupListener = async () => {
                this.logger.info('');
                this.logger.info(cli_shared_1.Text.tunnel.stoppingTunnel);
                try {
                    rl.close();
                    await stopFunction();
                    resolve();
                }
                catch (error) {
                    this.logger.error(error);
                    reject(error);
                }
                finally {
                    if (bundleMonitor) {
                        await bundleMonitor.stop();
                    }
                    await manifestFileWatcher.close();
                    this.logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.tunnel.stoppedTunnel));
                    process.exit();
                }
            };
            rl.on('SIGINT', tunnelCleanupListener);
            rl.on('SIGBREAK', tunnelCleanupListener);
            process.on('SIGTERM', tunnelCleanupListener);
        });
    }
    watchAndWarnOnManifestChanges(manifestFilePath) {
        const originalManifest = fs_1.default.readFileSync(manifestFilePath, 'utf8');
        return chokidar_1.default.watch(manifestFilePath).on('change', () => {
            const currentManifest = fs_1.default.readFileSync(manifestFilePath, 'utf8');
            if (currentManifest !== originalManifest) {
                this.logger.error(new Error(cli_shared_1.Text.tunnel.error.manifestChangeDetected));
            }
        });
    }
    watchApp = async (startTunnelResult, tunnelOptions = cli_shared_1.defaultNoDebugTunnelOptions) => {
        const { localPort, reloadSandboxes, faasServer, uiServers } = startTunnelResult;
        const onBuildWillStart = async () => {
            this.logger.info('');
            this.logger.info(cli_shared_1.Text.bundle.detectedChanges);
            if (tunnelOptions.verify) {
                await (0, bundler_1.runLinter)(this.statsigService);
            }
            this.logger.info(cli_shared_1.Text.tunnel.preBundleTask(cli_shared_1.Text.tunnel.bundlingHeader));
        };
        const onBuildFinished = (kind) => async (err, output) => {
            if (err) {
                this.logger.error(err);
                return;
            }
            if (kind === 'runtime') {
                await reloadSandboxes(output, tunnelOptions);
            }
            this.logTunnelStatus(localPort, tunnelOptions);
        };
        const multiCompiler = new multi_compiler_watcher_1.MultiCompilerWatcher(faasServer, uiServers);
        if (tunnelOptions.verify) {
            await (0, bundler_1.runLinter)(this.statsigService);
        }
        this.logger.info(cli_shared_1.Text.tunnel.preBundleTask(cli_shared_1.Text.tunnel.bundlingHeader));
        try {
            const output = await multiCompiler.compileAndWatch({
                onRuntimeChange: { onBuildWillStart, onBuildFinished: onBuildFinished('runtime') },
                onUIChange: { onBuildWillStart, onBuildFinished: onBuildFinished('ui') }
            }, tunnelOptions);
            await reloadSandboxes(output, tunnelOptions);
            this.logTunnelStatus(localPort, tunnelOptions);
        }
        catch (_) {
        }
        return multiCompiler;
    };
}
exports.TunnelInteractor = TunnelInteractor;
