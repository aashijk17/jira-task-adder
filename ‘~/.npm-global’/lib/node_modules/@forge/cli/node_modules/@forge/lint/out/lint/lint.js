"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.litelint = exports.lint = exports.parseSourceFile = exports.problemCount = exports.reportLintResults = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@forge/cli-shared");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
const parse_1 = require("../parse");
const basic_manifest_linter_1 = require("./linters/manifest-linter/basic-manifest-linter");
const handler_linter_1 = require("./linters/handler-linter/handler-linter");
const full_manifest_linter_1 = require("./linters/manifest-linter/full-manifest-linter");
const permissions_manifest_linter_1 = require("./linters/manifest-linter/permissions-manifest-linter");
const permission_linter_1 = require("./linters/permission-linter/permission-linter");
const deprecated_csp_permissions_manifest_linter_1 = require("./linters/manifest-linter/deprecated-csp-permissions-manifest-linter");
const dynamic_properties_permissions_linter_1 = require("./linters/dynamic-properties-linter/dynamic-properties-permissions-linter");
const remote_compute_manifest_linter_1 = require("./linters/manifest-linter/remote-compute-manifest-linter");
const invoke_remote_linter_1 = require("./linters/remote-linter/invoke-remote-linter");
const storage_module_linter_1 = require("./linters/storage-module-linter/storage-module-linter");
const frame_component_linter_1 = require("./linters/frame-component-linter/frame-component-linter");
const deprecated_egress_permissions_manifest_linter_1 = require("./linters/manifest-linter/deprecated-egress-permissions-manifest-linter");
const reportLintResults = (logger, lintResults, showSummary = true) => {
    let numErrors = 0, numWarnings = 0;
    let noProblemsFound = true;
    if (lintResults.length) {
        lintResults.forEach((lintResult) => {
            if (lintResult.size()) {
                noProblemsFound = false;
                numErrors += lintResult.errors.length;
                numWarnings += lintResult.warnings.length;
                logger.info(cli_shared_1.Text.lint.filename(path_1.default.resolve(lintResult.file)));
                lintResult.errors.forEach(({ line, column, message, reference }) => {
                    logger.info(cli_shared_1.Text.lint.error(line, column, message, reference));
                });
                lintResult.warnings.forEach(({ line, column, message, reference }) => {
                    logger.info(cli_shared_1.Text.lint.warning(line, column, message, reference));
                });
            }
        });
    }
    if (noProblemsFound) {
        logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.lint.noProblems));
        logger.info('');
    }
    else {
        const resultsWithFixers = lintResults.filter((result) => result.hasFixer());
        const numFixableErrors = resultsWithFixers.reduce((count, result) => count + result.errors.length, 0);
        const numFixableWarnings = resultsWithFixers.reduce((count, result) => count + result.warnings.length, 0);
        if (showSummary) {
            logger.info(cli_shared_1.Text.lint.summary(numErrors, numWarnings, numFixableErrors, numFixableWarnings));
            if (numFixableErrors + numFixableWarnings > 0) {
                logger.info(cli_shared_1.Text.lint.fixSummary(numErrors, numFixableErrors, numFixableWarnings));
            }
            else if (numErrors + numWarnings === 1) {
                logger.info(cli_shared_1.Text.lint.noFixableProblem);
            }
            else {
                logger.info(cli_shared_1.Text.lint.noFixableProblems);
            }
        }
        if (numErrors) {
            process.exitCode = 1;
        }
    }
};
exports.reportLintResults = reportLintResults;
const problemCount = (lintResults) => {
    return lintResults.reduce((prev, curr) => ({
        errors: prev.errors + curr.errors.length,
        warnings: prev.warnings + curr.warnings.length
    }), { errors: 0, warnings: 0 });
};
exports.problemCount = problemCount;
const parseSourceFile = async (filepath, parser, readFilePromise = (0, util_1.promisify)(fs_1.default.readFile)) => {
    const code = await readFilePromise(filepath, { encoding: 'utf-8' });
    const parseResult = await parser(code, filepath);
    return {
        ast: parseResult,
        filepath
    };
};
exports.parseSourceFile = parseSourceFile;
const lint = async (filesToLint, manifest, environment, logger, statsigService, parseFunction = exports.parseSourceFile, linters = [
    new permission_linter_1.PermissionLinter(environment, manifest, logger),
    new permissions_manifest_linter_1.PermissionsManifestLinter(logger, statsigService),
    new deprecated_csp_permissions_manifest_linter_1.DeprecatedCspPermissionsManifestLinter(logger, statsigService),
    new remote_compute_manifest_linter_1.RemoteComputeManifestLinter(logger, statsigService),
    new full_manifest_linter_1.FullManifestLinter(logger, statsigService),
    new handler_linter_1.HandlerLinter(environment, manifest, logger),
    new dynamic_properties_permissions_linter_1.DynamicPropertiesPermissionsLinter(environment, manifest, logger),
    new invoke_remote_linter_1.InvokeRemoteLinter(environment, manifest, logger),
    new storage_module_linter_1.StorageModulesLinter(environment, manifest, logger),
    new frame_component_linter_1.FrameComponentLinter(environment, manifest, logger),
    new deprecated_egress_permissions_manifest_linter_1.DeprecatedEgressPermissionsManifestLinter(logger, statsigService)
]) => {
    const { include, exclude } = await (0, cli_shared_1.listTSConfigIncludeExclude)(new cli_shared_1.FileSystemReader());
    const tsInclude = new Set(include);
    const tsExclude = new Set(exclude);
    try {
        const lintInputs = (await Promise.all(filesToLint.map(async (filepath) => {
            const ext = path_1.default.extname(filepath);
            if (ext.match(/jsx?$/)) {
                return parseFunction(filepath, parse_1.tsParser);
            }
            else if (ext.match(/tsx?$/)) {
                const resolvedFilePath = path_1.default.resolve('./' + filepath);
                const tsFileIncluded = tsInclude.has(resolvedFilePath);
                const tsFileExcluded = tsExclude.has(resolvedFilePath);
                if ((tsFileIncluded && !tsFileExcluded) || (!tsInclude.size && !tsExclude.size)) {
                    return parseFunction(filepath, parse_1.tsParser);
                }
            }
            return { ast: null, filepath: '' };
        }))).filter((result) => !!result?.ast);
        await Promise.all(linters.map((linter) => linter.bootstrap()));
        const results = await Promise.all(linters.map((linter) => linter.batchExecute(lintInputs))).then(cli_shared_1.flat);
        return results.map((result) => {
            const comparator = (a, b) => a.line === b.line ? a.column - b.column : a.line - b.line;
            result.errors = result.errors.sort(comparator);
            result.warnings = result.warnings.sort(comparator);
            return result;
        });
    }
    catch (e) {
        throw new cli_shared_1.ApplicationCompileError(formatCompileErrorMessage(e));
    }
};
exports.lint = lint;
function formatCompileErrorMessage(error) {
    let errorMessage = error.message;
    if (error.fileName) {
        errorMessage += `\nin ${error.fileName}`;
    }
    if (error.index !== undefined) {
        errorMessage += `\nat index ${error.index}`;
    }
    if (error.lineNumber !== undefined && error.column !== undefined) {
        errorMessage += `\nat line ${error.lineNumber}, column ${error.column}`;
    }
    return errorMessage;
}
const litelint = async (logger, statsigService, linter = new basic_manifest_linter_1.BasicManifestLinter(logger, statsigService)) => {
    await linter.bootstrap();
    return linter.batchExecute();
};
exports.litelint = litelint;
