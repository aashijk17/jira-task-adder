"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageModulesLinter = exports.fixMissingModules = void 0;
const tslib_1 = require("tslib");
const base_linter_1 = tslib_1.__importDefault(require("../../base-linter"));
const api_call_interface_1 = require("./api-call-interface");
const sql_node_visitor_1 = require("./visitors/sql-node-visitor");
const sql_verifier_1 = require("./verifiers/sql-verifier");
var SqlEngine;
(function (SqlEngine) {
    SqlEngine["mysql"] = "mysql";
})(SqlEngine || (SqlEngine = {}));
const fixMissingModules = async (errors, warnings, state) => {
    const currentModules = (await state.configFile.readConfig())?.modules ?? {};
    if (warnings.length && !currentModules.sql) {
        const newModules = {
            ...currentModules,
            sql: [
                {
                    key: 'db',
                    engine: SqlEngine.mysql
                }
            ]
        };
        await state.configFile.writeToConfigFile('modules', newModules);
        state.warningsFixed++;
    }
    return state;
};
exports.fixMissingModules = fixMissingModules;
class StorageModulesLinter extends base_linter_1.default {
    manifest;
    constructor(environment, manifest, logger) {
        super(environment, logger);
        this.manifest = manifest;
    }
    async bootstrap() {
        this.nodeVisitors = [new sql_node_visitor_1.SQLNodeVisitor()];
        this.verifiers = {
            sql: new sql_verifier_1.SQLVerifier(this.environment, this.manifest)
        };
    }
    setupMatchesMap(filepath) {
        this.matches.set(filepath, {
            sql: []
        });
    }
    getFixer() {
        return exports.fixMissingModules;
    }
    addLintCriteriaMatch(apiCall, filepath) {
        const criteriaMatches = this.matches.get(filepath);
        if (apiCall.type === api_call_interface_1.ApiCallTypes.SQL) {
            criteriaMatches.sql.push(apiCall);
        }
    }
}
exports.StorageModulesLinter = StorageModulesLinter;
