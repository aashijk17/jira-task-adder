"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringResourceInterpolator = exports.StringResourceInterpolatorError = void 0;
const fs_1 = require("fs");
const types_1 = require("../types");
const errors_1 = require("../text/errors");
const manifest_interpolator_1 = require("./manifest-interpolator");
const mime_types_1 = require("mime-types");
const path_1 = require("path");
const MODULE_PROPERTIES_TO_INTERPOLATE = [
    { moduleType: types_1.AllModuleTypes.RovoAgent, property: 'prompt' }
];
class StringResourceInterpolatorError extends manifest_interpolator_1.ManifestInterpolatorError {
    constructor(message) {
        super(message);
        this.name = 'StringResourceInterpolatorError';
    }
}
exports.StringResourceInterpolatorError = StringResourceInterpolatorError;
class StringResourceInterpolator {
    type = manifest_interpolator_1.InterpolatorType.STRING_RESOURCE;
    interpolate({ manifest, filePath }) {
        MODULE_PROPERTIES_TO_INTERPOLATE.forEach(({ moduleType, property }) => {
            const modules = manifest.modules?.[moduleType];
            modules?.forEach((module) => {
                if (module.hasOwnProperty(property)) {
                    const moduleAny = module;
                    const propertyValue = moduleAny[property];
                    if (propertyValue.startsWith('resource:')) {
                        moduleAny[property] = this.fetchContentFromResourceFile(propertyValue, manifest, filePath);
                    }
                }
            });
        });
        return manifest;
    }
    fetchContentFromResourceFile(modulePropertyWithStringResource, manifest, manifestPath) {
        const resourcePath = this.getResourcePath(manifest, modulePropertyWithStringResource);
        const manifestDir = (0, path_1.dirname)(manifestPath);
        try {
            return (0, fs_1.readFileSync)((0, path_1.resolve)(manifestDir, resourcePath), 'utf8');
        }
        catch (error) {
            throw new StringResourceInterpolatorError(errors_1.errors.schema.errorReadingResourceFile(resourcePath, error?.message));
        }
    }
    getResourcePath(manifest, resourceString) {
        const resourceUrl = new URL(resourceString);
        const [resourceKey, relativePath] = resourceUrl.pathname.split(';');
        const resource = this.checkIfResourceIsValid(manifest, resourceKey);
        const resourcePath = `${resource.path}/${relativePath}`;
        this.checkIfResourceTypeIsSupported(resourcePath);
        return resourcePath;
    }
    checkIfResourceIsValid(manifest, resourceKey) {
        const resource = manifest.resources?.find((resource) => resource.key === resourceKey);
        if (!resource) {
            throw new StringResourceInterpolatorError(errors_1.errors.schema.resourceNotFound(resourceKey));
        }
        if (!resource.path) {
            throw new StringResourceInterpolatorError(errors_1.errors.schema.resourcePathNotDefined(resourceKey));
        }
        return resource;
    }
    checkIfResourceTypeIsSupported(resourcePath) {
        const mimeType = (0, mime_types_1.lookup)(resourcePath);
        if (!mimeType || !mimeType.startsWith('text')) {
            throw new StringResourceInterpolatorError(errors_1.errors.schema.resourceFileNotSupported(resourcePath));
        }
    }
}
exports.StringResourceInterpolator = StringResourceInterpolator;
