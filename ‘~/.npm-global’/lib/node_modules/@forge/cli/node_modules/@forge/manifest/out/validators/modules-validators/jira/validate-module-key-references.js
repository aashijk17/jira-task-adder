"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateModuleReferences = exports.ALLOWED_REFERENCED_MODULE_TYPES = void 0;
const text_1 = require("../../../text");
const utils_1 = require("../../../utils");
exports.ALLOWED_REFERENCED_MODULE_TYPES = [
    'jira:adminPage',
    'jira:globalPage',
    'jira:projectPage',
    'jira:projectSettingsPage'
];
const validateModuleLink = ({ key, modulesOfValidType, referencedModuleKey, yamlContentByLine, validReferencedModuleTypes }) => {
    const validReferencedModuleExists = modulesOfValidType.some((m) => referencedModuleKey === m.key);
    if (validReferencedModuleExists) {
        return [];
    }
    return [
        {
            message: `Module with key ${referencedModuleKey} does not exist or is not ${validReferencedModuleTypes.length > 1 ? 'one of the allowed types:' : 'of the allowed type'} ${validReferencedModuleTypes.join(', ')}`,
            reference: text_1.References.Modules,
            level: 'error',
            ...(0, utils_1.findPosition)(key, yamlContentByLine)
        }
    ];
};
const validateModuleReferences = (modules, expectedTypes, keyReferences, yamlContentByLine) => {
    const modulesOfValidType = expectedTypes.flatMap((expectedType) => {
        return modules[expectedType]?.map((module) => ({ key: module.key })) || [];
    });
    return keyReferences.flatMap((keyReference) => validateModuleLink({
        key: keyReference.moduleKey,
        modulesOfValidType,
        referencedModuleKey: keyReference.referencedModuleKey,
        validReferencedModuleTypes: expectedTypes,
        yamlContentByLine
    }));
};
exports.validateModuleReferences = validateModuleReferences;
