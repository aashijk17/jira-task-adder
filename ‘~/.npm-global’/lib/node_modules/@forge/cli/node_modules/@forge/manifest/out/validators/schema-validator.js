"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaValidator = void 0;
const tslib_1 = require("tslib");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const ajv_formats_1 = tslib_1.__importDefault(require("ajv-formats"));
const utils_1 = require("../utils");
const text_1 = require("../text");
class SchemaValidator {
    schema;
    validateSchema;
    constructor(schema) {
        this.schema = schema;
        const ajv = new ajv_1.default({ allErrors: true, verbose: true, strict: false });
        (0, ajv_formats_1.default)(ajv);
        ajv.addVocabulary(['defaultValue', 'fieldDescription', 'fieldTitle', 'shortClassName']);
        this.validateSchema = ajv.compile(this.schema);
    }
    processErrorMessage = (error) => {
        if (error.keyword === 'if' && ['then', 'else'].some((keyword) => keyword === error.params.failingKeyword)) {
            return undefined;
        }
        if (error.keyword === 'required' && error.schemaPath.includes('oneOf')) {
            return undefined;
        }
        if (error.keyword === 'not') {
            return text_1.errors.schema.notAllowed(error.schema.required);
        }
        if (error.keyword === 'enum') {
            return text_1.errors.schema.enumValues(error.params.allowedValues);
        }
        if (error.keyword === 'oneOf') {
            if (error.params.passingSchemas) {
                const requiredProps = error.params.passingSchemas.map((v) => error.schema[v].required);
                return text_1.errors.schema.oneOf(requiredProps);
            }
            else if (error.parentSchema?.oneOf) {
                const requiredProps = error.parentSchema.oneOf
                    .map((v) => v.required)
                    .filter((v) => !!v);
                return text_1.errors.schema.oneOf(requiredProps);
            }
            return text_1.errors.schema.oneOf(undefined);
        }
        if (error.keyword === 'additionalProperties' && 'additionalProperty' in error.params) {
            return text_1.errors.schema.additionalProperties(error.params.additionalProperty);
        }
        return error.message;
    };
    handleModuleError = (path, error, manifest) => {
        const hasProperty = path.length > 1;
        const propertyName = path[path.length - 1];
        const errorMessage = this.processErrorMessage(error);
        if (!errorMessage) {
            return undefined;
        }
        if (hasProperty) {
            path.splice(path.length - 1, 0, 'property');
        }
        const data = typeof error.data !== 'string' ? undefined : error.data;
        const searchString = data && hasProperty ? `${propertyName}: ${data}` : path[0];
        return {
            message: text_1.errors.schemaError(data, path, errorMessage),
            reference: text_1.References.SchemaError,
            level: 'error',
            ...(0, utils_1.findPosition)(searchString, manifest.yamlContentByLine)
        };
    };
    handleGenericError = (path, error, manifest) => {
        const hasProperty = path.length > 1;
        const propertyName = path[path.length - 1];
        const errorMessage = this.processErrorMessage(error);
        if (!errorMessage) {
            return undefined;
        }
        if (hasProperty) {
            path.splice(path.length - 1, 0, 'property');
        }
        const data = typeof error.data !== 'string' ? undefined : error.data;
        const searchString = error.data && hasProperty ? `${propertyName}: ${error.data}` : propertyName;
        return {
            message: text_1.errors.schemaError(data, path, errorMessage),
            reference: text_1.References.SchemaError,
            level: 'error',
            ...(0, utils_1.findPosition)(searchString, manifest.yamlContentByLine)
        };
    };
    isDeprecatedField = (section, error) => {
        if (error.keyword === 'additionalProperties') {
            return section === 'app' && error.params.additionalProperty === 'name';
        }
        return false;
    };
    getDeprecationInfo(section, property) {
        const deprecationInfo = text_1.errors.deprecationInfo;
        const deprecationSection = deprecationInfo[section];
        if (!deprecationSection) {
            return undefined;
        }
        else {
            return deprecationSection[property];
        }
    }
    handleDeprecatedField = (section, error, manifest) => {
        const property = error.params.additionalProperty;
        return {
            message: text_1.errors.schema.deprecatedValue(section, property, this.getDeprecationInfo(section, property)),
            reference: text_1.References.Deprecated,
            level: 'warning',
            ...(0, utils_1.findPosition)(`${section}:`, manifest.yamlContentByLine)
        };
    };
    handleError = (path, error, manifest) => {
        const rootManifestSection = path[0];
        const manifestSection = path[path.length - 1];
        if (this.isDeprecatedField(manifestSection, error)) {
            return this.handleDeprecatedField(manifestSection, error, manifest);
        }
        if (rootManifestSection === 'modules') {
            return this.handleModuleError(path.slice(1), error, manifest);
        }
        return this.handleGenericError(path, error, manifest);
    };
    async validate(manifest) {
        if (!manifest || !manifest.yamlContent) {
            return {
                success: false,
                manifestObject: manifest
            };
        }
        let success = this.validateSchema(manifest.yamlContent);
        const errors = this.validateSchema.errors
            ?.map((error) => {
            const values = error.instancePath.replace(/\/\d+/, '').split('/').slice(1);
            return this.handleError(values, error, manifest);
        })
            .filter((e) => e !== undefined);
        const _isEqual = (e1, e2) => {
            return (e1.level === e2.level &&
                e1.reference === e2.reference &&
                e1.column === e2.column &&
                e1.line === e2.line &&
                e1.message === e2.message);
        };
        const dedupedErrors = [];
        void errors?.forEach((e) => {
            if (!(dedupedErrors.filter((de) => _isEqual(e, de)).length > 0)) {
                dedupedErrors.push(e);
            }
        });
        const warningLevel = dedupedErrors.filter((e) => e.level === 'warning');
        if (warningLevel.length === dedupedErrors.length) {
            success = true;
        }
        return {
            success,
            manifestObject: {
                ...manifest,
                typedContent: success ? manifest.yamlContent : undefined
            },
            errors: dedupedErrors
        };
    }
}
exports.SchemaValidator = SchemaValidator;
