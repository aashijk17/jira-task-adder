"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProvidersValidator = void 0;
const utils_1 = require("../utils");
const text_1 = require("../text");
const remote_regions_validator_1 = require("./remote-regions-validator");
class ProvidersValidator {
    async validate(manifest) {
        if (!manifest || !manifest.typedContent || !manifest.typedContent.providers) {
            return {
                success: true,
                manifestObject: manifest
            };
        }
        let validationErrors = [];
        const auth = manifest.typedContent.providers.auth;
        const remotes = manifest.typedContent.remotes;
        const permissions = manifest.typedContent.permissions;
        auth?.forEach((provider) => {
            if ('remotes' in provider) {
                const hasMissing = provider.remotes?.find((key) => !remotes?.find((item) => item.key === key));
                if (hasMissing) {
                    validationErrors.push({
                        message: text_1.errors.providers.missingRemote(provider.key, hasMissing),
                        reference: text_1.References.Providers,
                        level: 'error',
                        ...(0, utils_1.findPosition)(hasMissing, manifest.yamlContentByLine)
                    });
                }
                const missingEgressPermission = provider.remotes?.find((key) => {
                    const remote = remotes?.find((item) => item.key === key);
                    if (remote) {
                        const egressPermission = permissions?.external?.fetch?.backend?.find((item) => {
                            if (typeof item === 'string') {
                                return item === remote.baseUrl;
                            }
                            if ('remote' in item) {
                                return item.remote === remote.key;
                            }
                            return item.address === remote.baseUrl;
                        });
                        return !egressPermission;
                    }
                    return false;
                });
                if (missingEgressPermission) {
                    validationErrors.push({
                        message: text_1.errors.providers.missingEgress(missingEgressPermission),
                        reference: text_1.References.Providers,
                        level: 'error',
                        ...(0, utils_1.findPosition)(missingEgressPermission, manifest.yamlContentByLine)
                    });
                }
            }
        });
        auth
            ?.filter((provider) => 'actions' in provider)
            .forEach((provider) => {
            Object.values(provider.actions).forEach((action) => {
                const message = action && this.isActionValidRemote(provider, action, manifest, remotes);
                if (message) {
                    validationErrors.push(message);
                }
            });
        });
        auth?.forEach((provider) => {
            const message = this.isValidProfileRetrieverFunction(provider, manifest);
            if (message) {
                validationErrors.push(message);
            }
        });
        auth?.forEach((provider) => {
            validationErrors = [...validationErrors, ...this.isValidAuthRemote(provider, manifest, remotes)];
        });
        return {
            success: validationErrors.length === 0,
            errors: validationErrors
        };
    }
    isActionValidRemote(provider, action, manifest, remotes) {
        const remote = remotes?.find((item) => item.key === action?.remote);
        if (action && !remote) {
            return {
                message: text_1.errors.providers.missingRemote(provider.key, action.remote),
                reference: text_1.References.Providers,
                level: 'error',
                ...(0, utils_1.findPosition)(action.remote, manifest.yamlContentByLine)
            };
        }
    }
    isValidProfileRetrieverFunction(provider, manifest) {
        if ('actions' in provider && 'function' in provider.actions.retrieveProfile) {
            const { function: functionKey } = provider.actions.retrieveProfile;
            const hasFunction = manifest.typedContent?.modules?.function?.find((func) => func.key === functionKey);
            if (!hasFunction) {
                return {
                    message: text_1.errors.providers.missingProfileFunction(provider.key, functionKey),
                    reference: text_1.References.Providers,
                    level: 'error',
                    ...(0, utils_1.findPosition)(functionKey, manifest.yamlContentByLine)
                };
            }
        }
    }
    isValidAuthRemote(provider, manifest, remotes) {
        const validationErrors = [];
        const referencedRemotes = [...(provider.remotes || [])];
        if ('actions' in provider) {
            referencedRemotes.push(provider.actions.retrieveProfile.remote);
            referencedRemotes.push(provider.actions.exchange.remote);
            referencedRemotes.push(provider.actions.authorization.remote);
            provider.actions.revokeToken && referencedRemotes.push(provider.actions.revokeToken.remote);
            provider.actions.refreshToken && referencedRemotes.push(provider.actions.refreshToken.remote);
        }
        referencedRemotes?.forEach((providerRemoteKey) => {
            const remote = remotes?.find((remote) => remote.key === providerRemoteKey);
            if (!remote) {
                return;
            }
            if (typeof remote.baseUrl !== 'undefined') {
                const remoteRegions = (0, remote_regions_validator_1.getRegionsFromBaseUrl)(remote.baseUrl);
                if (remoteRegions.size != 1) {
                    validationErrors.push({
                        message: text_1.errors.providers.hasRegionUrls(provider.key, remote.key),
                        reference: text_1.References.Providers,
                        level: 'error',
                        ...(0, utils_1.findPosition)(providerRemoteKey, manifest.yamlContentByLine)
                    });
                }
            }
        });
        return validationErrors;
    }
}
exports.ProvidersValidator = ProvidersValidator;
