"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystemReader = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importStar(require("fs"));
const glob_1 = require("glob");
const os_1 = require("os");
const path_1 = tslib_1.__importStar(require("path"));
const util_1 = require("util");
const recursive_readdir_1 = tslib_1.__importDefault(require("recursive-readdir"));
const shared_1 = require("../shared");
const FILE_NOT_FOUND_CODE = 'ENOENT';
class FileSystemReader {
    fileExists(filePath) {
        return fs_1.default.existsSync(filePath);
    }
    readFile(filePath) {
        try {
            return fs_1.default.readFileSync(filePath, 'utf8');
        }
        catch (error) {
            return this.handleFileError(error);
        }
    }
    async readFileAsync(filePath) {
        const read = (0, util_1.promisify)(fs_1.default.readFile);
        try {
            return await read(filePath, 'utf8');
        }
        catch (error) {
            return this.handleFileError(error);
        }
    }
    async recursiveReadDir(rootDir, ignores) {
        const ignoreDirs = ignores?.map((ignore) => {
            if (typeof ignore === 'string' && !path_1.default.extname(ignore)) {
                return (dir, stats) => stats.isDirectory() && path_1.default.basename(dir) === path_1.default.basename(ignore);
            }
            return ignore;
        });
        if (!(0, fs_1.existsSync)((0, path_1.resolve)(rootDir)) || !(0, fs_1.statSync)((0, path_1.resolve)(rootDir)).isDirectory()) {
            return [];
        }
        return (0, recursive_readdir_1.default)(rootDir, ignoreDirs);
    }
    async readGlob({ pattern, filesOnly = false }) {
        let results = await (0, glob_1.glob)(pattern, {});
        if (filesOnly) {
            results = (0, shared_1.flat)(await Promise.all(results.map(async (result) => {
                if ((await fs_1.default.promises.lstat(result)).isFile()) {
                    return [result];
                }
                else {
                    return [];
                }
            })));
        }
        results.sort();
        return results;
    }
    hasGlobSpecialChars(pattern) {
        return (0, glob_1.hasMagic)(pattern);
    }
    readBinaryFile(filePath) {
        try {
            return fs_1.default.readFileSync(filePath);
        }
        catch (error) {
            return this.handleFileError(error);
        }
    }
    async readBinaryFileAsync(filePath) {
        const read = (0, util_1.promisify)(fs_1.default.readFile);
        try {
            return await read(filePath);
        }
        catch (error) {
            return this.handleFileError(error);
        }
    }
    getHomeDirectory() {
        return (0, os_1.homedir)();
    }
    bytesToMb(size) {
        if (!size) {
            return '0 MB';
        }
        return (size / 1024 / 1024).toFixed(2) + ' MB';
    }
    getSize(filePath) {
        try {
            return fs_1.default.statSync(filePath).size;
        }
        catch {
            return undefined;
        }
    }
    async getFolderSizeAsync(directory) {
        const getFolderSize = (await import('get-folder-size')).default;
        const result = await getFolderSize(directory);
        if (result.errors) {
            return undefined;
        }
        return result.size;
    }
    handleFileError(error) {
        if (error && error.code === FILE_NOT_FOUND_CODE) {
            return undefined;
        }
        else {
            throw error;
        }
    }
    async getFileGlobList(globList) {
        const files = await Promise.all(globList.map((pattern) => this.readGlob({ pattern, filesOnly: true })));
        return (0, shared_1.flat)(files);
    }
}
exports.FileSystemReader = FileSystemReader;
