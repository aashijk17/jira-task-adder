"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMacroAutoConvert = void 0;
const text_1 = require("../../../text");
const utils_1 = require("../../../utils");
const VALID_MATCHER_PATTERN = new RegExp(/^(?=.{1,1024}$)[a-zA-Z]+:(\/\/)?(\\\\)?(?:[a-zA-Z0-9-\*]+[\.:])*[a-zA-Z0-9-\*]+(?:\.:[a-zA-Z\*]{1,})?(?:\/.*)?$/);
const errorMessages = text_1.errors.modules.confluence.autoConvert;
const mapToAutoConvertError = (validationErrors, moduleKey) => validationErrors.map((message) => ({ moduleKey, message }));
const validateEmpty = (matchers, moduleKey) => {
    const validationErrors = [];
    if (matchers === undefined || matchers.length == 0) {
        validationErrors.push(errorMessages.emptyMatcherArray(moduleKey));
    }
    return mapToAutoConvertError(validationErrors, moduleKey);
};
const validateRegex = (pattern, moduleKey, index) => {
    const validationErrors = [];
    if (!VALID_MATCHER_PATTERN.test(pattern)) {
        validationErrors.push(errorMessages.invalidMatcherPatternRegex(pattern, moduleKey, index));
    }
    return validationErrors;
};
const validateMatcherPattern = (moduleKey, pattern, index) => {
    const validationErrors = [];
    validationErrors.push(...validateRegex(pattern, moduleKey, index));
    return mapToAutoConvertError(validationErrors, moduleKey);
};
const validateMacroAutoConvert = (allModules, yamlContentByLine) => {
    const validationErrors = [];
    const modules = (0, utils_1.getAllModules)(allModules) || [];
    const modulesWithAutoConvert = modules.filter((module) => module.autoConvert);
    if (modulesWithAutoConvert.length > 0) {
        modulesWithAutoConvert.forEach((module) => {
            validationErrors.push(...validateEmpty(module.autoConvert.matchers, module.key).map((error) => ({
                message: error.message,
                reference: text_1.References.Modules,
                level: 'error',
                ...(0, utils_1.findPosition)(error.moduleKey, yamlContentByLine)
            })));
            if (validationErrors.length) {
                return validationErrors;
            }
            module.autoConvert.matchers.forEach((matchers, index) => {
                validationErrors.push(...validateMatcherPattern(module.key, matchers.pattern, index).map((error) => ({
                    message: error.message,
                    reference: text_1.References.Modules,
                    level: 'error',
                    ...(0, utils_1.findPosition)(error.moduleKey, yamlContentByLine)
                })));
            });
        });
    }
    return validationErrors;
};
exports.validateMacroAutoConvert = validateMacroAutoConvert;
