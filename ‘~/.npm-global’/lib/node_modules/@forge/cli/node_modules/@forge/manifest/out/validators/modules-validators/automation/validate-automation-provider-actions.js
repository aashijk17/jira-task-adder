"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAutomationProviderActions = void 0;
const types_1 = require("../../../types");
const text_1 = require("../../../text");
const utils_1 = require("../../../utils");
const MAX_AUTOMATION_ACTIONS = 20;
const validateAutomationProviderActions = (allModules, yamlContentByLine) => {
    const validationErrors = [];
    const automationActionProviders = allModules[types_1.AllModuleTypes.AutomationActionProvider];
    const actionKey = (0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreAction);
    const definedActions = allModules[actionKey]?.map((action) => action.key) ?? [];
    automationActionProviders?.forEach((automationAction) => {
        automationAction.actions.forEach((action) => {
            if (!definedActions.includes(action)) {
                validationErrors.push(getUndefinedActionValidationError(automationAction.key, action, yamlContentByLine));
            }
        });
    });
    const count = automationActionProviders?.reduce((sum, actionProvider) => sum + (actionProvider.actions?.length ?? 0), 0) ?? 0;
    if (count > MAX_AUTOMATION_ACTIONS) {
        validationErrors.push(getValidationError(yamlContentByLine));
    }
    return validationErrors;
};
exports.validateAutomationProviderActions = validateAutomationProviderActions;
function getValidationError(yamlContentByLine) {
    return {
        message: text_1.errors.modules.action.tooManyAutomationActions(MAX_AUTOMATION_ACTIONS),
        reference: text_1.References.Modules,
        level: 'error',
        ...(0, utils_1.findPosition)(types_1.AllModuleTypes.AutomationActionProvider, yamlContentByLine)
    };
}
function getUndefinedActionValidationError(agent, action, yamlContentByLine) {
    return {
        message: text_1.errors.modules.action.undefinedAutomationActionReference(agent, action),
        reference: text_1.References.Modules,
        level: 'error',
        ...(0, utils_1.findPosition)(agent, yamlContentByLine)
    };
}
