"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLMValidator = void 0;
const text_1 = require("../text");
const utils_1 = require("../utils");
const MAXIMUM_NUMBER_OF_LLM_MODELS = 1;
class LLMValidator {
    async validate(manifest) {
        const validationErrors = [];
        validationErrors.push(...this.validateLLMModules(manifest));
        return {
            success: validationErrors.length === 0,
            manifestObject: manifest,
            ...(validationErrors.length ? { errors: validationErrors } : {})
        };
    }
    validateLLMModules(manifest) {
        if (manifest?.typedContent?.modules?.llm && Array.isArray(manifest?.typedContent?.modules?.llm)) {
            const llm = manifest.typedContent.modules.llm;
            const yamlContentByLine = manifest.yamlContentByLine;
            return [
                ...this.validateNumberOfModules(llm, yamlContentByLine),
                ...this.validateNumberOfModels(llm, yamlContentByLine),
                ...this.validateModelUniqueness(llm, yamlContentByLine)
            ];
        }
        return [];
    }
    validateNumberOfModules(llmModules, yamlContentByLine) {
        if (llmModules.length > 1) {
            return [
                {
                    message: text_1.errors.modules.llm.tooManyModulesDeclared(llmModules.length),
                    reference: text_1.References.Modules,
                    level: 'error',
                    ...(0, utils_1.findPosition)('llm', yamlContentByLine)
                }
            ];
        }
        return [];
    }
    validateNumberOfModels(llmModules, yamlContentByLine) {
        const modelsDeclared = llmModules.map(({ model }) => model).flat();
        if (modelsDeclared.length > MAXIMUM_NUMBER_OF_LLM_MODELS) {
            return [
                {
                    message: text_1.errors.modules.llm.tooManyModelsDeclared(modelsDeclared.length, MAXIMUM_NUMBER_OF_LLM_MODELS),
                    reference: text_1.References.Modules,
                    level: 'error',
                    ...(0, utils_1.findPosition)('llm', yamlContentByLine)
                }
            ];
        }
        return [];
    }
    validateModelUniqueness(llmModules, yamlContentByLine) {
        const modelsDeclared = llmModules.map(({ model }) => model).flat();
        const repeatedModelDeclarations = new Set(modelsDeclared.filter((model, currentIndex) => modelsDeclared.indexOf(model) !== currentIndex));
        if (repeatedModelDeclarations.size) {
            return Array.from(repeatedModelDeclarations).reduce((acc, curr) => {
                acc.push({
                    message: text_1.errors.modules.llm.duplicateModel(curr),
                    reference: text_1.References.Modules,
                    level: 'error',
                    ...(0, utils_1.findPosition)(curr, yamlContentByLine)
                });
                return acc;
            }, []);
        }
        return [];
    }
}
exports.LLMValidator = LLMValidator;
