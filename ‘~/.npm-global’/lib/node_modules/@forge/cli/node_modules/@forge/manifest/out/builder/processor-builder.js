"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessorBuilder = void 0;
const types_1 = require("../types");
const processor_1 = require("../processor");
const deprecated_csp_method_validation_processor_1 = require("../processor/deprecated-csp-method-validation-processor");
const remote_compute_validation_processor_1 = require("../processor/remote-compute-validation-processor");
const deprecated_egress_permissions_validation_processor_1 = require("../processor/deprecated-egress-permissions-validation-processor");
class ProcessorBuilder {
    static cache = new Map();
    validationType;
    lintOptions = {};
    constructor() {
        this.validationType = types_1.ValidationTypes.FULL;
    }
    static instance() {
        return new ProcessorBuilder();
    }
    withValidation(type) {
        this.validationType = type;
        return this;
    }
    withOptions(options) {
        this.lintOptions = options;
        return this;
    }
    buildInternal() {
        switch (this.validationType) {
            case types_1.ValidationTypes.BASIC:
                return new processor_1.BasicValidationProcessor(this.lintOptions);
            case types_1.ValidationTypes.FULL:
                return new processor_1.FullValidationProcessor(this.lintOptions);
            case types_1.ValidationTypes.FORGE_REMOTE_COMPUTE:
                return new remote_compute_validation_processor_1.RemoteComputeValidationProcessor();
            case types_1.ValidationTypes.PRODUCT_TRIGGER:
                return new processor_1.ProductTriggerValidationProcessor();
            case types_1.ValidationTypes.DEPRECATED_CSP_METHOD:
                return new deprecated_csp_method_validation_processor_1.DeprecatedCspMethodValidationProcessor();
            case types_1.ValidationTypes.DEPRECATED_EGRESS_PERMISSIONS:
                return new deprecated_egress_permissions_validation_processor_1.DeprecatedEgressPermissionsValidationProcessor();
            default:
                throw new Error('Unsupported validation type');
        }
    }
    createCacheKey() {
        return `${this.validationType}-${JSON.stringify(this.lintOptions)}`;
    }
    build() {
        const cacheKey = this.createCacheKey();
        const cached = ProcessorBuilder.cache.get(cacheKey);
        if (cached) {
            return cached;
        }
        const processor = this.buildInternal();
        ProcessorBuilder.cache.set(cacheKey, processor);
        return processor;
    }
}
exports.ProcessorBuilder = ProcessorBuilder;
