"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptBundler = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path_1 = tslib_1.__importDefault(require("path"));
const readline_1 = require("readline");
const cross_spawn_1 = tslib_1.__importDefault(require("cross-spawn"));
const cli_shared_1 = require("@forge/cli-shared");
const common_1 = require("./common");
const dependencies_1 = require("./dependencies");
const text_1 = require("./text");
const types_1 = require("./types");
const metadata_1 = require("./metadata");
const COPY_DEPENDENCIES_OPTIONS = {
    exclude: ['@forge/react', '@forge/bridge']
};
class TypeScriptBundler {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    runTypeScript(args, outputDir) {
        const processArgs = [];
        processArgs.push('--project', args.appDirectory);
        processArgs.push('--rootDir', path_1.default.join(args.appDirectory, common_1.SOURCE_DIR));
        if (args.watchMode) {
            processArgs.push('--watch');
        }
        else {
            processArgs.push('--listFiles');
        }
        processArgs.push('--outDir', outputDir);
        let tsc = 'tsc';
        const appTsc = path_1.default.join(args.appDirectory, common_1.NODE_MODULES_DIR, '.bin', 'tsc');
        if ((0, fs_1.existsSync)(appTsc)) {
            tsc = appTsc;
        }
        return (0, cross_spawn_1.default)(tsc, processArgs, { stdio: ['ignore', 'pipe', 'inherit'] });
    }
    isListedFile(line) {
        line = line.trim();
        if (line.length === 0) {
            return null;
        }
        if (!line.match(/^\/.+\.[cm]?[jt]sx?$/)) {
            return null;
        }
        return line;
    }
    async getResult(args, outputDir, output) {
        let metadata;
        if (output) {
            const files = new Set();
            for (const line of output.split('\n')) {
                const filePath = this.isListedFile(line);
                if (filePath) {
                    files.add(filePath);
                }
            }
            metadata = await (0, metadata_1.getMetadata)(this.logger, args.appDirectory, files);
        }
        else {
            metadata = (0, types_1.emptyMetadata)();
        }
        metadata.bundler = 'typescript';
        return { outputDir, metadata };
    }
    async bundle(args) {
        const outputDir = (0, common_1.getOutputDir)(args);
        await (0, dependencies_1.copyProductionDependencies)(args.appDirectory, outputDir, COPY_DEPENDENCIES_OPTIONS);
        const compiler = this.runTypeScript(args, outputDir);
        let output = '';
        compiler.stdout.on('data', (data) => (output += data.toString()));
        return new Promise((resolve, reject) => compiler.on('exit', async (code) => {
            try {
                if (code !== 0) {
                    const errors = output.split('\n').filter((line) => !this.isListedFile(line));
                    throw new cli_shared_1.BundlerTSError(text_1.Text.typescriptError(errors));
                }
                const result = await this.getResult(args, outputDir, output);
                resolve(result);
            }
            catch (e) {
                reject(e);
            }
        }));
    }
    async watch(args, watch) {
        const outputDir = (0, common_1.getOutputDir)(args);
        await (0, dependencies_1.copyProductionDependencies)(args.appDirectory, outputDir, COPY_DEPENDENCIES_OPTIONS);
        const compiler = this.runTypeScript(args, outputDir);
        let isFirstRun = true;
        const output = [];
        return new Promise((resolve, reject) => {
            compiler.on('exit', async () => {
                reject(new cli_shared_1.BundlerTSError(text_1.Text.typescriptError(output)));
            });
            const outputLines = (0, readline_1.createInterface)(compiler.stdout);
            outputLines.on('line', async (line) => {
                if (/Starting (incremental )?compilation/.exec(line)) {
                    if (!isFirstRun) {
                        await watch.onBuildWillStart();
                    }
                    output.length = 0;
                    return;
                }
                if (!line.includes('Watching for file changes.')) {
                    line = line.trim();
                    if (line) {
                        output.push(line);
                    }
                    return;
                }
                try {
                    const errors = Number(/Found (\d+) error/.exec(line)?.[1] ?? '0');
                    if (errors) {
                        throw new cli_shared_1.BundlerTSError(text_1.Text.typescriptError(output));
                    }
                    const result = await this.getResult(args, outputDir);
                    if (isFirstRun) {
                        isFirstRun = false;
                        this.logger.info(cli_shared_1.LogColor.trace(args.successMessage));
                        resolve({ result, stop: () => compiler.kill() });
                        return;
                    }
                    await watch.onBuildFinished(null, result);
                }
                catch (e) {
                    if (isFirstRun) {
                        isFirstRun = false;
                        reject(e);
                        return;
                    }
                    await watch.onBuildFinished(e);
                }
            });
        });
    }
}
exports.TypeScriptBundler = TypeScriptBundler;
