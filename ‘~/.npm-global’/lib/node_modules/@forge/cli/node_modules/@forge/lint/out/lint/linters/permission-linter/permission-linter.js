"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionLinter = exports.fixMissingPermissions = exports.deprecatedEgressPermissions = exports.findMissingPermissions = exports.NON_FWD_SLASH_REGEX = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@forge/cli-shared");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const base_linter_1 = tslib_1.__importDefault(require("../../base-linter"));
const api_call_interface_1 = require("./api-call-interface");
const verifiers_1 = require("./verifiers");
const visitors_1 = require("./visitors");
const fs_1 = tslib_1.__importDefault(require("fs"));
const utils_1 = require("../utils");
exports.NON_FWD_SLASH_REGEX = '[^\\/\\s]*';
const CACHE_KEY = 'PERMISSIONS_LINTER';
const ONE_HOUR_MS = 1000 * 60 * 60;
const findMissingPermissions = (errors, warnings, permissionsType, state) => {
    const missingPermissions = new Set();
    errors.forEach(({ metadata }) => {
        if (metadata && metadata[permissionsType]) {
            missingPermissions.add(metadata[permissionsType]);
            if (state)
                state.errorsFixed++;
        }
    });
    warnings.forEach(({ metadata }) => {
        if (metadata && metadata[permissionsType]) {
            missingPermissions.add(metadata[permissionsType]);
            if (state)
                state.warningsFixed++;
        }
    });
    return missingPermissions;
};
exports.findMissingPermissions = findMissingPermissions;
const deprecatedEgressPermissions = (warnings, state) => {
    const hasDeprecated = warnings.some((warning) => warning.metadata?.hasDeprecatedEgressPermissions);
    if (hasDeprecated && state)
        state.warningsFixed++;
    return hasDeprecated;
};
exports.deprecatedEgressPermissions = deprecatedEgressPermissions;
const applyEgressPermissionsMigration = (config) => {
    const { fetch: originalFetch, ...restExternal } = config.external ?? {};
    Object.entries(originalFetch || {}).forEach(([key, values]) => {
        const valuesToOverride = [];
        values.forEach((egressValue) => {
            if (typeof egressValue === 'string') {
                valuesToOverride.push({
                    address: egressValue
                });
            }
            else {
                valuesToOverride.push(egressValue);
            }
            config.external.fetch[key] = valuesToOverride;
        });
    });
    Object.entries(restExternal || {}).forEach(([key, values]) => {
        const valuesToOverride = [];
        values.forEach((egressValue) => {
            if (typeof egressValue === 'string') {
                valuesToOverride.push({
                    address: egressValue
                });
            }
            else {
                valuesToOverride.push(egressValue);
            }
            config.external[key] = valuesToOverride;
        });
    });
};
const fixMissingPermissions = async (errors, warnings, state) => {
    const missingScopes = (0, exports.findMissingPermissions)(errors, warnings, 'missingPermission', state);
    const missingExternalFetchBackend = (0, exports.findMissingPermissions)(errors, warnings, 'missingExternalFetchPermission', state);
    const missingContentStyle = (0, exports.findMissingPermissions)(errors, warnings, 'missingContentStylePermission', state);
    const missingExternalImage = (0, exports.findMissingPermissions)(errors, warnings, 'missingExternalImagesPermission', state);
    const hasDeprecatedEgressPermissions = (0, exports.deprecatedEgressPermissions)(warnings, state) ||
        missingExternalImage.size > 0 ||
        missingExternalFetchBackend.size > 0;
    const currentPermissions = (await state.configFile.readConfig())?.permissions ?? {};
    const currentScopes = (0, utils_1.getAllScopeKeys)(currentPermissions?.scopes ?? []);
    currentScopes.forEach((scope) => missingScopes.add(scope));
    const currentExternalFetchBackend = currentPermissions?.external?.fetch?.backend ?? [];
    currentExternalFetchBackend.forEach((scope) => missingExternalFetchBackend.add(scope));
    const arrayMissingExternalFetchBackend = [...missingExternalFetchBackend];
    const currentContentStyles = currentPermissions?.content?.styles ?? [];
    currentContentStyles.forEach((scope) => missingContentStyle.add(scope));
    const arrayMissingContentStyles = [...missingContentStyle];
    const currentExternalImages = currentPermissions?.external?.images ?? [];
    currentExternalImages.forEach((scope) => missingExternalImage.add(scope));
    const arrayMissingExternalImages = [...missingExternalImage];
    const config = {
        ...currentPermissions,
        scopes: [...missingScopes]
    };
    if (arrayMissingExternalFetchBackend.length > 0) {
        config.external = {
            ...config.external,
            fetch: {
                ...config.external?.fetch,
                backend: arrayMissingExternalFetchBackend
            }
        };
    }
    if (arrayMissingExternalImages.length > 0) {
        config.external = {
            ...config.external,
            images: arrayMissingExternalImages
        };
    }
    if (arrayMissingContentStyles.length > 0) {
        config.content = {
            ...config.content,
            styles: arrayMissingContentStyles
        };
    }
    if (hasDeprecatedEgressPermissions) {
        applyEgressPermissionsMigration(config);
    }
    await state.configFile.writeToConfigFile('permissions', config);
    return state;
};
exports.fixMissingPermissions = fixMissingPermissions;
class PermissionLinter extends base_linter_1.default {
    manifest;
    static JIRA_CACHE_KEY = 'permissions-jira-cache-key';
    static JSM_CACHE_KEY = 'permissions-jsm-cache-key';
    static JSW_CACHE_KEY = 'permissions-jsw-cache-key';
    static CONFLUENCE_CACHE_KEY = 'permissions-confluence-cache-key';
    static CONFLUENCE_V2_CACHE_KEY = 'permissions-confluence-v2-cache-key';
    static BITBUCKET_CACHE_KEY = 'permissions-bitbucket-cache-key';
    jira;
    confluence;
    bitbucket;
    cache;
    constructor(environment, manifest, logger) {
        super(environment, logger);
        this.manifest = manifest;
    }
    async bootstrap() {
        this.cache = cli_shared_1.CachedConf.getCache(CACHE_KEY);
        const LOCAL_CONF_SWAGGER = process.env.LOCAL_CONF_SWAGGER;
        const LOCAL_CONF_V2_SWAGGER = process.env.LOCAL_CONF_V2_SWAGGER;
        const LOCAL_JIRA_SWAGGER = process.env.LOCAL_JIRA_SWAGGER;
        const LOCAL_JSM_SWAGGER = process.env.LOCAL_JSM_SWAGGER;
        const LOCAL_JSW_SWAGGER = process.env.LOCAL_JSW_SWAGGER;
        const LOCAL_BB_SWAGGER = process.env.LOCAL_BB_SWAGGER;
        const USE_LOCAL_SWAGGER = process.env.USE_LOCAL_SWAGGER;
        let swaggerFiles;
        if (USE_LOCAL_SWAGGER &&
            LOCAL_CONF_SWAGGER &&
            LOCAL_JIRA_SWAGGER &&
            LOCAL_JSM_SWAGGER &&
            LOCAL_JSW_SWAGGER &&
            LOCAL_BB_SWAGGER &&
            LOCAL_CONF_V2_SWAGGER) {
            swaggerFiles = [
                this.getProductPathsFile(LOCAL_JIRA_SWAGGER),
                this.getProductPathsFile(LOCAL_JSM_SWAGGER),
                this.getProductPathsFile(LOCAL_JSW_SWAGGER),
                this.getProductPathsFile(LOCAL_CONF_SWAGGER),
                this.getProductPathsFile(LOCAL_CONF_V2_SWAGGER),
                this.getProductPathsFile(LOCAL_BB_SWAGGER)
            ];
        }
        else {
            swaggerFiles = [
                this.getProductPaths(PermissionLinter.JIRA_CACHE_KEY, 'https://developer.atlassian.com/cloud/jira/platform/swagger-v3.v3.json'),
                this.getProductPaths(PermissionLinter.JSM_CACHE_KEY, 'https://developer.atlassian.com/cloud/jira/service-desk/swagger.v3.json'),
                this.getProductPaths(PermissionLinter.JSW_CACHE_KEY, 'https://developer.atlassian.com/cloud/jira/software/swagger.v3.json'),
                this.getProductPaths(PermissionLinter.CONFLUENCE_CACHE_KEY, 'https://developer.atlassian.com/cloud/confluence/swagger.v3.json'),
                this.getProductPaths(PermissionLinter.CONFLUENCE_V2_CACHE_KEY, 'https://developer.atlassian.com/cloud/confluence/openapi-v2.v3.json'),
                this.getProductPaths(PermissionLinter.BITBUCKET_CACHE_KEY, 'https://developer.atlassian.com/cloud/bitbucket/swagger.json')
            ];
        }
        const [jiraSwagger, jsmSwagger, jswSwagger, confluenceSwagger, confluenceV2Swagger, bitbucketSwagger] = await Promise.all(swaggerFiles);
        this.jira = this.processPaths({
            ...jiraSwagger.paths,
            ...jsmSwagger.paths,
            ...jswSwagger.paths
        });
        this.confluence = this.processPaths({
            ...confluenceSwagger.paths,
            ...confluenceV2Swagger.paths
        });
        this.bitbucket = this.processPaths(bitbucketSwagger.paths);
        this.nodeVisitors = [
            new visitors_1.ProductNodeVisitor(),
            new visitors_1.UIHookNodeVisitor(),
            new visitors_1.StorageAPINodeVisitor(),
            new visitors_1.ExternalApiCallVisitor(),
            new visitors_1.ImageUrlVisitor()
        ];
        const humanReadableEnvironment = (0, cli_shared_1.environmentToOption)(this.environment);
        this.verifiers = {
            bitbucket: new verifiers_1.ProductVerifier(humanReadableEnvironment, this.manifest, this.bitbucket, 'bitbucket'),
            confluence: new verifiers_1.ProductVerifier(humanReadableEnvironment, this.manifest, this.confluence, 'confluence'),
            jira: new verifiers_1.ProductVerifier(humanReadableEnvironment, this.manifest, this.jira, 'jira'),
            storage: new verifiers_1.StorageAPIVerifier(humanReadableEnvironment, this.manifest),
            uiHook: new verifiers_1.UIHookVerifier(humanReadableEnvironment, this.manifest),
            external: new verifiers_1.ExternalFetchVerifier(humanReadableEnvironment, this.manifest),
            image: new verifiers_1.ImageUrlVerifier(humanReadableEnvironment, this.manifest)
        };
    }
    setupMatchesMap(filepath) {
        if (!this.jira || !this.confluence || !this.bitbucket)
            throw new Error('Bootstrap failed');
        this.matches.set(filepath, {
            bitbucket: [],
            confluence: [],
            jira: [],
            uiHook: [],
            storage: [],
            external: [],
            image: []
        });
    }
    getFixer() {
        return exports.fixMissingPermissions;
    }
    addLintCriteriaMatch(apiCall, filepath) {
        const criteriaMatches = this.matches.get(filepath);
        switch (apiCall.type) {
            case api_call_interface_1.ApiCallTypes.PRODUCT:
                criteriaMatches[apiCall.product].push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.HOOK:
                criteriaMatches.uiHook.push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.STORAGE:
                criteriaMatches.storage.push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.EXTERNAL:
                criteriaMatches.external.push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.IMAGE:
                criteriaMatches.image.push(apiCall);
                break;
        }
    }
    async getProductPaths(cacheKey, url) {
        const cached = this.cache?.get(cacheKey);
        if (!cached) {
            const response = await (0, node_fetch_1.default)(url);
            const jsonBody = await response.json();
            void this.cache?.set(cacheKey, jsonBody, 12 * ONE_HOUR_MS);
            return jsonBody;
        }
        return cached;
    }
    async getProductPathsFile(url) {
        const response = fs_1.default.readFileSync(url);
        return JSON.parse(response.toString());
    }
    processPaths(paths) {
        const pathMap = new Map();
        Object.keys(paths).forEach((path) => {
            const key = new RegExp(path.replace(/{(?<={)(.*?)(?=})}/g, exports.NON_FWD_SLASH_REGEX) + '\\/?$');
            pathMap.set(key, { originalPath: path, methods: paths[path] });
        });
        return pathMap;
    }
}
exports.PermissionLinter = PermissionLinter;
