"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMetadata = void 0;
const tslib_1 = require("tslib");
const promises_1 = require("fs/promises");
const path_1 = tslib_1.__importDefault(require("path"));
const parser = tslib_1.__importStar(require("@babel/parser"));
const traverse_1 = tslib_1.__importDefault(require("@babel/traverse"));
const text_1 = require("./text");
const types_1 = require("./types");
class MetadataCollector {
    logger;
    appDirectory;
    metadata = (0, types_1.emptyMetadata)();
    constructor(logger, appDirectory) {
        this.logger = logger;
        this.appDirectory = appDirectory;
    }
    async processPackageJson() {
        const packageJsonFile = path_1.default.join(this.appDirectory, 'package.json');
        try {
            await (0, promises_1.access)(packageJsonFile);
        }
        catch {
            return undefined;
        }
        const packageFile = await (0, promises_1.readFile)(packageJsonFile, 'utf8');
        const packageJson = JSON.parse(packageFile);
        if (packageJson.type === 'module') {
            this.metadata.esm = true;
        }
    }
    static packageFromImport(name) {
        const parts = name.split('/');
        if (parts.length === 0 || parts[0] === '') {
            return '';
        }
        if (parts[0].startsWith('@')) {
            return `${parts[0]}/${parts[1]}`;
        }
        if (parts[0].startsWith('node:')) {
            return parts[0].substring(5);
        }
        return parts[0];
    }
    async processSourceFile(filePath) {
        if (filePath.split('/').includes('node_modules')) {
            return;
        }
        const rel = path_1.default.relative(await (0, promises_1.realpath)(this.appDirectory), await (0, promises_1.realpath)(filePath));
        if (rel.startsWith('..')) {
            return;
        }
        const ext = path_1.default.extname(filePath);
        if (ext.match(/^\.[cm]?jsx?$/)) {
            this.metadata.jsFiles++;
        }
        else if (ext.match(/^\.[cm]?tsx?$/)) {
            this.metadata.tsFiles++;
        }
        else {
            return;
        }
        const source = await (0, promises_1.readFile)(filePath, 'utf8');
        const ast = parser.parse(source, {
            sourceType: 'module',
            plugins: ['typescript', 'jsx']
        });
        (0, traverse_1.default)(ast, {
            ImportDeclaration: ({ node }) => this.processImport(node)
        });
    }
    processImport(node) {
        const packageName = MetadataCollector.packageFromImport(node.source.value);
        this.metadata.dependencies.add(packageName);
        if (packageName.startsWith('@forge/')) {
            for (const specifier of node.specifiers) {
                let member;
                switch (specifier.type) {
                    case 'ImportDefaultSpecifier':
                    case 'ImportNamespaceSpecifier':
                        member = '*';
                        break;
                    case 'ImportSpecifier':
                        switch (specifier.imported.type) {
                            case 'Identifier':
                                member = specifier.imported.name;
                                break;
                            case 'StringLiteral':
                                member = specifier.imported.value;
                                break;
                        }
                }
                this.metadata.sdkImports.add(`${packageName}.${member}`);
            }
        }
    }
    async collect({ files }) {
        await this.warnIfFailed(() => this.processPackageJson());
        await Promise.all(Array.from(files, (filePath) => this.warnIfFailed(() => this.processSourceFile(filePath))));
        return this.metadata;
    }
    async warnIfFailed(action) {
        try {
            return await action();
        }
        catch (error) {
            this.logger.debug(text_1.Text.metadataFailed(error));
            this.metadata.errors++;
        }
    }
}
async function getMetadata(logger, appDirectory, files) {
    const collector = new MetadataCollector(logger, appDirectory);
    return collector.collect({ files });
}
exports.getMetadata = getMetadata;
