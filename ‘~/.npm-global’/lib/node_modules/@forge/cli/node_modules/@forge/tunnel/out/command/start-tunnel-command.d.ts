import { BundlerOutput } from '@forge/bundler';
import { AppConfigProvider, ConfigFile, Logger, TunnelOptions } from '@forge/cli-shared';
import { DevelopmentServer } from '../servers';
import { FunctionChangeWatcher } from './interactors';
import { TunnelDefinitions } from '../index';
import { RegisterTunnelService, CreateTunnelService } from '../services';
export interface StartTunnelOptions {
    port?: number;
    host: string;
    environmentKey: string;
    resourcePortMap: Record<string, number>;
    url?: string;
}
export interface StartTunnelResult {
    localPort: number;
    tunnelDefinitions: TunnelDefinitions;
    faasServer: DevelopmentServer;
    uiServers: DevelopmentServer[];
    stopFunction(): Promise<void>;
    reloadSandboxes(bundledCode: BundlerOutput, tunnelOptions: TunnelOptions): Promise<void>;
}
export declare class StartTunnelCommand {
    private readonly getAppConfig;
    private readonly devServer;
    private readonly tunnelFactory;
    private readonly tunnelClient;
    private readonly functionHost;
    private readonly logger;
    private readonly configFile;
    private tunnelServers;
    private cspReporterServer;
    constructor(getAppConfig: AppConfigProvider, devServer: DevelopmentServer, tunnelFactory: CreateTunnelService, tunnelClient: RegisterTunnelService, functionHost: FunctionChangeWatcher, logger: Logger, configFile: ConfigFile);
    private validateTunnelUrl;
    private validateTunnelPort;
    private stopServices;
    stopDockerComposeStack: (composeFiles?: Record<string, string>) => Promise<void>;
    private deleteDockerComposeFile;
    private startFaaSTunnelServer;
    private startResourceBasedTunnelsServers;
    execute(options: StartTunnelOptions, containersDockerComposeFiles?: Record<string, string>): Promise<StartTunnelResult>;
}
//# sourceMappingURL=start-tunnel-command.d.ts.map