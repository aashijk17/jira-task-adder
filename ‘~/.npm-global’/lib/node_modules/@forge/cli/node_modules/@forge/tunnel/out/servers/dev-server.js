"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalDevelopmentServer = exports.stopServer = exports.TunnelInvocationValidationError = void 0;
const tslib_1 = require("tslib");
const express_1 = tslib_1.__importDefault(require("express"));
const bundler_1 = require("@forge/bundler");
const cli_shared_1 = require("@forge/cli-shared");
const runtime_1 = require("@forge/runtime");
const util_1 = require("../util");
const http_proxy_middleware_1 = require("http-proxy-middleware");
const ari_1 = require("@forge/util/packages/ari");
class TunnelInvocationValidationError extends cli_shared_1.UserError {
}
exports.TunnelInvocationValidationError = TunnelInvocationValidationError;
async function stopServer(server) {
    if (!server) {
        return;
    }
    return new Promise((resolve) => {
        server.close(() => resolve());
    });
}
exports.stopServer = stopServer;
class LocalDevelopmentServer {
    invocationService;
    logger;
    configFile;
    fileSystemReader;
    statsigService;
    i18nResourceBundlingService;
    appEnvironmentClient;
    app;
    httpServer;
    tunnelOptions;
    environmentId;
    appId;
    onFatalError;
    constructor(invocationService, logger, configFile, fileSystemReader, statsigService, i18nResourceBundlingService, appEnvironmentClient) {
        this.invocationService = invocationService;
        this.logger = logger;
        this.configFile = configFile;
        this.fileSystemReader = fileSystemReader;
        this.statsigService = statsigService;
        this.i18nResourceBundlingService = i18nResourceBundlingService;
        this.appEnvironmentClient = appEnvironmentClient;
        this.app = (0, express_1.default)();
        this.app.disable('x-powered-by');
        this.app.disable('etag');
        this.app.post(`/:fnKey`, express_1.default.json({ limit: '6mb' }), this.handleInvocation);
        this.app.use(/^\/forge\/.*--.*\/.*/, this.configureProxyMiddleware);
    }
    async start(port = 0, _permissions, _remotes) {
        this.httpServer = await new Promise((resolve, reject) => {
            const httpServer = this.app.listen({ port });
            httpServer.on('error', reject).on('listening', () => resolve(httpServer));
        });
        return {
            port: this.httpServer.address().port,
            devServer: this
        };
    }
    async stop() {
        await stopServer(this.httpServer);
    }
    async compileAndWatch(watch, tunnelOptions = cli_shared_1.defaultNoDebugTunnelOptions) {
        this.tunnelOptions = tunnelOptions;
        const watchMode = this.tunnelOptions.debug ? 'debug' : 'watch';
        const handlers = await this.configFile.getAppHandlers();
        const entryPoints = (0, bundler_1.getEntryPoints)(handlers);
        if (!entryPoints.length) {
            return { outputDir: (0, bundler_1.getOutputDir)({ watchMode }) };
        }
        const bundler = (0, bundler_1.getNodeBundler)(this.logger, (0, bundler_1.getWrapperProvider)({ fileSystemReader: this.fileSystemReader, statsigService: this.statsigService }), this.configFile, this.statsigService);
        const { translations, modules } = await this.configFile.readConfig();
        const i18nResourceBundle = await this.i18nResourceBundlingService.bundle(modules, translations);
        const { result } = await bundler.watch({
            appDirectory: process.cwd(),
            entryPoints,
            watchMode,
            successMessage: cli_shared_1.Text.tunnel.functionsBundlingSucceeded,
            i18nResourceBundle
        }, watch);
        return result;
    }
    getApp() {
        return this.app;
    }
    setErrorHandler(handler) {
        this.onFatalError = handler;
    }
    handleInvocation = async (req, res) => {
        const request = req.body;
        const envVars = (0, runtime_1.getUserVars)();
        request.variables?.forEach((item) => {
            if (!envVars.find((i) => i.key === item.key)) {
                envVars.push(item);
            }
        });
        await this.validateApp(request);
        request.variables = [...envVars].sort((a, b) => a.key.localeCompare(b.key));
        try {
            const invokeResults = await this.invocationService.invoke(request.handler, request);
            if (!invokeResults.success) {
                return res.status(500).send(invokeResults.error);
            }
            res.json(invokeResults);
        }
        catch (error) {
            try {
                res.status(500).send((0, util_1.toLambdaError)(error));
            }
            catch (e) {
                this.logger.error(e);
            }
        }
    };
    configureProxyMiddleware = async (req, res, next) => {
        const serviceKey = req.originalUrl.match(/^\/forge\/(.*)--.*\/.*/)?.[1];
        const { services } = await this.configFile.readConfig();
        const port = await (0, cli_shared_1.getServicePort)(services, serviceKey);
        if (!port || port < 1024 || port > 49152) {
            this.logger.error(new Error(cli_shared_1.Text.error.invalidServicePort(serviceKey ?? '')));
            return;
        }
        (0, http_proxy_middleware_1.createProxyMiddleware)({
            target: `http://localhost:${port}`,
            pathRewrite: { '^/forge/[^/]*': '' },
            logLevel: 'info',
            logProvider: () => {
                return {
                    log: this.logger.trace,
                    debug: this.logger.trace,
                    info: this.logger.trace,
                    warn: this.logger.warn,
                    error: this.logger.error
                };
            },
            onProxyReq: (proxyReq) => {
                this.logger.info(cli_shared_1.Text.tunnel.container.invoke(proxyReq, port));
            },
            onError: (err, _, res) => {
                const message = cli_shared_1.Text.tunnel.container.error(err.code ?? err.message);
                this.logger.warn(message);
                res.status(500).send(message);
            }
        })(req, res, next);
    };
    async validateApp(request) {
        try {
            if (!(await this.statsigService.isSelfManagedTunnelEnabled())) {
                return;
            }
            await this.setEnvironmentAndAppId();
            const requestAppId = request?._meta?.appContext?.appId;
            if (requestAppId && requestAppId !== this.appId) {
                throw new TunnelInvocationValidationError(cli_shared_1.Text.tunnel.error.invalidInvokeRequestForAppId(requestAppId));
            }
            const requestEnvId = request?._meta?.appContext?.environmentId;
            if (requestEnvId && requestEnvId !== this.environmentId) {
                throw new TunnelInvocationValidationError(cli_shared_1.Text.tunnel.error.invalidInvokeRequestForAppEnv(requestEnvId));
            }
        }
        catch (error) {
            await this.onFatalError?.(error);
        }
    }
    async setEnvironmentAndAppId() {
        if (this.environmentId && this.appId) {
            return;
        }
        const config = await this.configFile.readConfig();
        this.appId = ari_1.EcosystemAppAri.parse(config.app.id).appId;
        const environmentKey = this.tunnelOptions?.environment || 'default';
        this.environmentId = await this.appEnvironmentClient.getAppEnvironmentId(config.app.id, environmentKey);
    }
}
exports.LocalDevelopmentServer = LocalDevelopmentServer;
