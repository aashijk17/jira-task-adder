"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeSandbox = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const path_1 = tslib_1.__importDefault(require("path"));
const readline_1 = tslib_1.__importDefault(require("readline"));
const uuid_1 = require("uuid");
const bundler_1 = require("@forge/bundler");
const runtime_1 = require("@forge/runtime");
const RUNNER = path_1.default.join(__dirname, '..', '..', 'out', 'sandbox', 'sandbox-runner.js');
class NodeSandbox {
    name;
    process;
    callbacks;
    constructor({ appPath, modName, handler, debugPort }) {
        const name = `${modName}.${handler}`;
        this.name = name;
        this.callbacks = new Map();
        const fileName = path_1.default.join(appPath, bundler_1.NODE_RUNTIME_CODE_FILE);
        const handlerName = 'main';
        const handlerEnv = '__forge__.main';
        this.process = (0, child_process_1.fork)(RUNNER, [fileName, handlerName], {
            stdio: ['ignore', 'pipe', 2, 'ipc'],
            env: {
                _HANDLER: handlerEnv,
                FORGE_EFS_RUNTIME_PATH: appPath,
                FORGE_CUSTOM_WRAPPER_FILE_NAME: '__forge_wrapper__.cjs'
            },
            execArgv: debugPort ? [`--inspect=0.0.0.0:${debugPort}`] : undefined
        });
        readline_1.default.createInterface(this.process.stdout).on('line', (line) => {
            const message = JSON.parse(line);
            this.handleOutput(message);
        });
        this.process.on('message', (message) => {
            const requestId = message.requestId;
            const result = message.result;
            this.callbacks.get(requestId)?.(result);
        });
    }
    handleOutput(output) {
        if (output.invocationId) {
            const p3LogEvent = output;
            runtime_1.StaticInvocationEventEmitter.emit(runtime_1.EVENT_P3_LOG, p3LogEvent);
        }
    }
    async execute(request) {
        const requestId = (0, uuid_1.v4)();
        return new Promise((resolve, reject) => {
            this.callbacks.set(requestId, (result) => {
                this.callbacks.delete(requestId);
                resolve(result);
            });
            const timeout = request._meta.timeout ?? 25;
            const deadline = Date.now() + timeout * 1000;
            const tunnelContext = {
                requestId,
                deadline
            };
            const message = { lambdaEvent: request, tunnelContext };
            this.process.send(message);
        });
    }
    stop() {
        this.process.kill();
    }
}
exports.NodeSandbox = NodeSandbox;
