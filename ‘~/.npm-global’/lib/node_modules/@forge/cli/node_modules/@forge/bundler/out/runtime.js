"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNodeBundler = exports.userCodePath = exports.NODE_RUNTIME_CODE_FILE = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const promises_1 = tslib_1.__importDefault(require("fs/promises"));
const webpack_1 = tslib_1.__importDefault(require("webpack"));
var RawSource = webpack_1.default.sources.RawSource;
const cli_shared_1 = require("@forge/cli-shared");
const i18n_1 = require("@forge/i18n");
const common_1 = require("./config/common");
const typescript_1 = require("./typescript");
const webpack_2 = require("./webpack");
const text_1 = require("./text");
exports.NODE_RUNTIME_CODE_FILE = '__forge__.cjs';
const NODE_RUNTIME_BACKUP_WRAPPER_FILE = '__forge_wrapper__.cjs';
const NODE_RUNTIME_USE_LOCAL_WRAPPER_FILE = '__forge_use_local_wrapper.txt';
const NODE_RUNTIME_VERSION_FILE = 'runtime.json';
const NODE_WEBPACK_USER_CODE_DIR = 'bundled';
function userCodePath(entryKey) {
    return path_1.default.join(path_1.default.dirname(entryKey), NODE_WEBPACK_USER_CODE_DIR, path_1.default.basename(entryKey));
}
exports.userCodePath = userCodePath;
async function emitWrapperFiles(provider, emit) {
    const wrapper = await provider.getNodeRuntimeWrapper();
    const loader = await provider.getNodeRuntimeLoader();
    let entrypointScript;
    if (loader) {
        entrypointScript = loader;
        await emit(NODE_RUNTIME_BACKUP_WRAPPER_FILE, wrapper.script);
    }
    else {
        entrypointScript = wrapper;
    }
    await emit(exports.NODE_RUNTIME_CODE_FILE, entrypointScript.script);
    if (process.env.FORGE_RUNTIME_PATH) {
        await emit(NODE_RUNTIME_USE_LOCAL_WRAPPER_FILE, 'Local wrapper used');
    }
    await emit(NODE_RUNTIME_VERSION_FILE, JSON.stringify({ version: entrypointScript.version }, null, 2));
}
async function emitI18nFiles(i18nResourceBundle, emit) {
    await Promise.all((0, cli_shared_1.listFilesInI18nResourceBundle)(i18nResourceBundle).map(async ([fileName, filePath]) => {
        const fileContent = await promises_1.default.readFile(filePath);
        await emit(path_1.default.join(i18n_1.I18N_BUNDLE_FOLDER_NAME, fileName), fileContent.toString());
    }));
}
class NodeBundler extends webpack_2.WebpackBundler {
    wrapperProvider;
    constructor(logger, wrapperProvider) {
        super(logger);
        this.wrapperProvider = wrapperProvider;
    }
    async getConfig(args) {
        const webpackConfig = (0, common_1.getCommonWebpackConfig)(args);
        webpackConfig.target = 'node18';
        webpackConfig.output.filename = '[name].cjs';
        webpackConfig.name = 'node-runtime';
        webpackConfig.module.rules.push({
            test: /\.m?js$/,
            resolve: {
                fullySpecified: false
            }
        });
        webpackConfig.plugins.push({
            apply: (compiler) => {
                compiler.hooks.make.tapPromise('AfterEmitPlugin', async (compilation) => {
                    const emit = async (name, contents) => compilation.emitAsset(name, new RawSource(contents));
                    await emitWrapperFiles(this.wrapperProvider, emit);
                    if (args.i18nResourceBundle) {
                        await emitI18nFiles(args.i18nResourceBundle, emit);
                    }
                });
            }
        });
        return webpackConfig;
    }
}
class TypeScriptNodeBundler extends typescript_1.TypeScriptBundler {
    wrapperProvider;
    constructor(logger, wrapperProvider) {
        super(logger);
        this.wrapperProvider = wrapperProvider;
    }
    async getResult(args, outputDir, output) {
        const result = await super.getResult(args, outputDir, output);
        const emit = async (name, contents) => {
            const outputPath = path_1.default.join(outputDir, name);
            await promises_1.default.mkdir(path_1.default.dirname(outputPath), { recursive: true });
            await promises_1.default.writeFile(outputPath, contents);
        };
        await emitWrapperFiles(this.wrapperProvider, emit);
        if (args.i18nResourceBundle) {
            await emitI18nFiles(args.i18nResourceBundle, emit);
        }
        return result;
    }
}
class ConfigBundler {
    configReader;
    statsigService;
    bundlers;
    constructor(logger, wrapperProvider, configReader, statsigService) {
        this.configReader = configReader;
        this.statsigService = statsigService;
        this.bundlers = new Map([
            ['webpack', new NodeBundler(logger, wrapperProvider)],
            ['typescript', new TypeScriptNodeBundler(logger, wrapperProvider)]
        ]);
    }
    async getBundlerType() {
        const configuredBundler = (await this.configReader.readConfig()).app.package?.bundler ?? 'webpack';
        if (configuredBundler === 'typescript' && !(await this.statsigService.isTypescriptBundlerEnabled())) {
            throw new cli_shared_1.UserError(text_1.Text.typescriptBundlerEAP);
        }
        return configuredBundler;
    }
    async getBundler() {
        return this.bundlers.get(await this.getBundlerType());
    }
    async bundle(args) {
        return (await this.getBundler()).bundle(args);
    }
    async watch(args, watch) {
        return (await this.getBundler()).watch(args, watch);
    }
}
function getNodeBundler(logger, wrapperProvider, configReader, statsigService) {
    return new ConfigBundler(logger, wrapperProvider, configReader, statsigService);
}
exports.getNodeBundler = getNodeBundler;
