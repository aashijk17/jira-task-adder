"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourcesValidator = exports.MAX_RESOURCE_COUNT = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = require("path");
const cheerio_1 = require("cheerio");
const utils_1 = require("../utils");
const text_1 = require("../text");
const utils_2 = require("../utils");
exports.MAX_RESOURCE_COUNT = 50;
class ResourcesValidator {
    async validate(manifest) {
        if (!manifest || !manifest.typedContent || !manifest.filePath) {
            return {
                success: false,
                manifestObject: manifest
            };
        }
        const validationErrors = [];
        const { typedContent: { resources, modules }, yamlContentByLine, filePath } = manifest;
        if (!resources) {
            return {
                success: true,
                manifestObject: manifest
            };
        }
        if (resources.length > exports.MAX_RESOURCE_COUNT) {
            validationErrors.push({
                message: text_1.errors.resources.tooManyResourcesError(exports.MAX_RESOURCE_COUNT),
                reference: text_1.References.Resources,
                level: 'error',
                ...(0, utils_1.findPosition)('resource', yamlContentByLine)
            });
        }
        if (modules) {
            const resourceMap = new Map(resources.map(({ key, path }) => [key, path]));
            const manifestDir = (0, path_1.dirname)(filePath);
            (0, utils_1.getValidModules)(modules).forEach((moduleKey) => {
                modules[moduleKey]?.forEach((module) => {
                    (0, utils_2.findInvalidResourceReferences)(module, resources).forEach((resourceKey) => {
                        validationErrors.push({
                            message: text_1.errors.modules.wrongResourceReference(moduleKey, resourceKey),
                            reference: text_1.References.Resources,
                            level: 'error',
                            ...(0, utils_1.findPosition)(moduleKey, yamlContentByLine)
                        });
                    });
                    const resourcePath = resourceMap.get(module.resource);
                    if (resourcePath === undefined)
                        return;
                    const resourcePathDir = (0, path_1.resolve)(resourcePath);
                    if (module.render === 'native') {
                        if (fs_1.default.lstatSync(resourcePathDir).isDirectory()) {
                            validationErrors.push({
                                message: text_1.errors.modules.wrongResourceType(resourcePath),
                                reference: text_1.References.Resources,
                                level: 'error',
                                ...(0, utils_1.findPosition)(moduleKey, yamlContentByLine)
                            });
                        }
                    }
                    else {
                        if (fs_1.default.lstatSync(resourcePathDir).isDirectory() &&
                            !fs_1.default.existsSync((0, path_1.resolve)(manifestDir, resourcePath, 'index.html'))) {
                            validationErrors.push({
                                message: text_1.errors.resources.missingEntrypoint(resourcePath, moduleKey),
                                reference: text_1.References.Resources,
                                level: 'error',
                                ...(0, utils_1.findPosition)(resourcePath, yamlContentByLine)
                            });
                        }
                        else if (!fs_1.default.lstatSync(resourcePathDir).isDirectory()) {
                            validationErrors.push({
                                message: text_1.errors.resources.nonDirectory(resourcePath, moduleKey),
                                reference: text_1.References.Resources,
                                level: 'error',
                                ...(0, utils_1.findPosition)(resourcePath, yamlContentByLine)
                            });
                        }
                    }
                });
            });
            (0, utils_1.getValidModules)(modules).forEach((moduleKey) => {
                const uniquePaths = new Set(modules[moduleKey].map(({ resource }) => resourceMap.get(resource)));
                uniquePaths.forEach((path) => {
                    if (!path)
                        return;
                    if (fs_1.default.existsSync((0, path_1.resolve)(manifestDir, path, 'index.html'))) {
                        const content = fs_1.default.readFileSync((0, path_1.resolve)(manifestDir, path, 'index.html'));
                        const $ = (0, cheerio_1.load)(content, { xml: { xmlMode: false } });
                        const cspContent = $('meta[http-equiv="Content-Security-Policy"]').attr('content');
                        if (cspContent) {
                            const cspStyleSrc = cspContent.split(';').find((s) => s.startsWith('style-src'));
                            if (cspStyleSrc?.includes("'unsafe-inline'")) {
                                const existingStylesPermissions = manifest.typedContent?.permissions?.content?.styles;
                                let shouldShowError = false;
                                if (!existingStylesPermissions?.length || !existingStylesPermissions?.includes('unsafe-inline')) {
                                    shouldShowError = true;
                                }
                                if (shouldShowError) {
                                    validationErrors.push({
                                        message: text_1.errors.resources.deprecatedCspPolicyDefinition(path),
                                        reference: text_1.References.Resources,
                                        level: 'error',
                                        metadata: {
                                            missingContentStylePermission: 'unsafe-inline'
                                        },
                                        ...(0, utils_1.findPosition)(path, yamlContentByLine)
                                    });
                                }
                            }
                        }
                    }
                });
            });
        }
        const invalidDirectoryErrors = resources
            .map((resource) => {
            const { key, path } = resource;
            const manifestDir = (0, path_1.dirname)(filePath);
            const resourceDirPath = (0, path_1.resolve)(manifestDir, path);
            if (!fs_1.default.existsSync(resourceDirPath)) {
                return {
                    message: text_1.errors.resources.missingResource(path, key),
                    reference: text_1.References.Resources,
                    level: 'error',
                    ...(0, utils_1.findPosition)(path, yamlContentByLine)
                };
            }
            else if (fs_1.default.lstatSync(resourceDirPath).isDirectory() && fs_1.default.readdirSync(resourceDirPath).length === 0) {
                return {
                    message: text_1.errors.resources.emptyDirectory(path, key),
                    reference: text_1.References.Resources,
                    level: 'error',
                    ...(0, utils_1.findPosition)(path, yamlContentByLine)
                };
            }
        })
            .filter((error) => error !== undefined);
        const resourceKeys = [];
        resources.forEach((resource) => resourceKeys.push(resource.key));
        const duplicateKeys = [...new Set(resourceKeys.filter((item, index) => resourceKeys.indexOf(item) != index))];
        duplicateKeys.forEach((duplicateKey) => {
            validationErrors.push({
                message: text_1.errors.resources.duplicateKeyFound(duplicateKey),
                reference: text_1.References.Resources,
                level: 'error',
                ...(0, utils_1.findPosition)(duplicateKey, yamlContentByLine)
            });
        });
        validationErrors.push(...invalidDirectoryErrors);
        return {
            success: validationErrors.length === 0,
            manifestObject: manifest,
            errors: validationErrors
        };
    }
}
exports.ResourcesValidator = ResourcesValidator;
