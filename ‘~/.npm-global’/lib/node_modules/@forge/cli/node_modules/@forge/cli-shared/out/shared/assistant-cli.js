"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runAssistant = exports.checkGeminiSetup = exports.checkRovoAuthStatus = exports.createForgeCommandErrorPrompt = exports.createUnknownForgeCommandPrompt = exports.createForgeTunnelErrorPrompt = exports.AssistantName = exports.ASSISTANT_CHECK_TIMEOUT = exports.ASSISTANT_ANALYZE_TIMEOUT = void 0;
const child_process_1 = require("child_process");
exports.ASSISTANT_ANALYZE_TIMEOUT = 300000;
exports.ASSISTANT_CHECK_TIMEOUT = 30000;
var AssistantName;
(function (AssistantName) {
    AssistantName["ROVO"] = "rovo";
    AssistantName["GEMINI"] = "gemini";
})(AssistantName = exports.AssistantName || (exports.AssistantName = {}));
function createForgeTunnelErrorPrompt(error) {
    return `Do not try to change the code, just analyze the issue and make a suggestion to fix the error. Analyze why when the Forge function resolver code is executed, there is error ${error}. This is likely because of some bug in the app code`;
}
exports.createForgeTunnelErrorPrompt = createForgeTunnelErrorPrompt;
function createUnknownForgeCommandPrompt(command, errorText) {
    return `Do not try to change the code, just analyze the issue and make a suggestion to fix the error. Analyze why when I run the Forge command${command} and has the unknown command error ${errorText}. This is likely because of syntax error in the command. You can refer to https://developer.atlassian.com/platform/forge/cli-reference/ for the CLI reference. Try to suggest a valid command based on the intention.`;
}
exports.createUnknownForgeCommandPrompt = createUnknownForgeCommandPrompt;
function createForgeCommandErrorPrompt(command, error) {
    return `Do not try to change the code, just analyze the issue and make a suggestion to fix the error. Analyze why when I run the command ${command} and I have the error ${error}`;
}
exports.createForgeCommandErrorPrompt = createForgeCommandErrorPrompt;
function checkCommandAvailability(command, args) {
    return new Promise((resolve) => {
        const childProcess = (0, child_process_1.spawn)(command, args, {
            stdio: 'pipe',
            timeout: exports.ASSISTANT_CHECK_TIMEOUT
        });
        childProcess.on('close', (code) => {
            resolve(code === 0);
        });
        childProcess.on('error', () => {
            resolve(false);
        });
    });
}
function checkRovoAuthStatus() {
    return checkCommandAvailability('acli', ['rovodev', 'auth', 'status']);
}
exports.checkRovoAuthStatus = checkRovoAuthStatus;
function checkGeminiSetup() {
    return checkCommandAvailability('gemini', ['--help']);
}
exports.checkGeminiSetup = checkGeminiSetup;
function runAssistantCommand(assistantName, command, args, logger) {
    return new Promise((resolve) => {
        logger.info(`Sending error to ${assistantName} for analysis...`);
        const childProcess = (0, child_process_1.spawn)(command, args, {
            stdio: 'inherit',
            timeout: exports.ASSISTANT_ANALYZE_TIMEOUT
        });
        childProcess.on('close', () => {
            resolve();
        });
        childProcess.on('error', (error) => {
            logger.error(new Error(`Failed to start ${assistantName.toLowerCase()}: ${error.message}`));
            resolve();
        });
    });
}
function runAssistant(prompt, assistantName, logger) {
    switch (assistantName) {
        case AssistantName.ROVO:
            return runAssistantCommand(AssistantName.ROVO, 'acli', ['rovodev', prompt], logger);
        case AssistantName.GEMINI:
            return runAssistantCommand(AssistantName.GEMINI, 'gemini', ['-p', prompt], logger);
        default:
            logger.error(new Error(`Unknown assistant: ${assistantName}`));
            return Promise.resolve();
    }
}
exports.runAssistant = runAssistant;
