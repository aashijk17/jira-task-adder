"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstallationService = exports.MultipleMatchingInstallationsError = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const egress_1 = require("@forge/egress");
const lodash_1 = require("lodash");
const graphql_client_1 = require("../installations/graphql-client");
const NO_DEPLOYMENTS_VERSION = '1.1.0';
const IDENTITY_PRODUCT_NAME = 'identity';
const BITBUCKET_PRODUCT_NAME = 'bitbucket';
const JIRA_SERVICE_DESK_PRODUCT_NAME = 'jira-servicedesk';
class MultipleMatchingInstallationsError extends cli_shared_1.BaseError {
    constructor() {
        super(cli_shared_1.Text.error.multipleMatchingInstallations);
    }
}
exports.MultipleMatchingInstallationsError = MultipleMatchingInstallationsError;
class InstallationService {
    getAppConfig;
    listInstallationsClient;
    upgradeAppInstallationsClient;
    hasNoAppInstallationsForEnvClient;
    getEntitlementOffering;
    getVersionByMajorVersionIdClient;
    constructor(getAppConfig, listInstallationsClient, upgradeAppInstallationsClient, hasNoAppInstallationsForEnvClient, getEntitlementOffering, getVersionByMajorVersionIdClient) {
        this.getAppConfig = getAppConfig;
        this.listInstallationsClient = listInstallationsClient;
        this.upgradeAppInstallationsClient = upgradeAppInstallationsClient;
        this.hasNoAppInstallationsForEnvClient = hasNoAppInstallationsForEnvClient;
        this.getEntitlementOffering = getEntitlementOffering;
        this.getVersionByMajorVersionIdClient = getVersionByMajorVersionIdClient;
    }
    comparePossibleInstallations(url1, url2) {
        const trimmedUrl1 = url1.replace(/\/+$/, '');
        const trimmedUrl2 = url2.replace(/\/+$/, '');
        return trimmedUrl1 === trimmedUrl2;
    }
    matchSiteForProduct(filterSite, installationSite, installationProduct) {
        if (installationProduct === BITBUCKET_PRODUCT_NAME) {
            return this.comparePossibleInstallations(filterSite.href, installationSite);
        }
        return this.comparePossibleInstallations(filterSite.host, installationSite);
    }
    filterInstallations(installations, { site: filterSite, product: filterProduct, environment: filterEnvironment }) {
        return installations.filter(({ product, secondaryProducts, site, environmentKey }) => {
            const matchRequired = filterProduct === (0, cli_shared_1.productDisplayName)(product);
            const matchOptional = secondaryProducts &&
                secondaryProducts.some((secondaryProduct) => filterProduct === (0, cli_shared_1.productDisplayName)(secondaryProduct));
            const matchProduct = !filterProduct || matchRequired || matchOptional;
            const matchSite = !filterSite || this.matchSiteForProduct(filterSite, site, product);
            const matchEnvironment = !filterEnvironment || filterEnvironment === (0, cli_shared_1.optionToEnvironment)(environmentKey);
            return matchProduct && matchSite && matchEnvironment;
        });
    }
    async listAppInstallations(filter) {
        const { id: appId } = await this.getAppConfig();
        const installations = await this.listInstallationsClient.listInstallations(appId, filter);
        return { installations: this.filterInstallations(installations, { ...filter }) };
    }
    async hasNoAppInstallationsForEnv(appEnv) {
        const { id: appId } = await this.getAppConfig();
        return this.hasNoAppInstallationsForEnvClient.hasNoAppInstallationsForEnv(appId, appEnv);
    }
    async listNonTechnicalAppInstallations(filter) {
        const { installations } = await this.listAppInstallations(filter);
        return {
            installations: installations.filter(({ product }) => product !== IDENTITY_PRODUCT_NAME && product !== JIRA_SERVICE_DESK_PRODUCT_NAME)
        };
    }
    async findOnlyMatchingInstallation(filter) {
        const filterInstalls = await this.listNonTechnicalAppInstallations(filter);
        if (!filterInstalls.installations.length) {
            throw new cli_shared_1.UserError(cli_shared_1.Text.error.invalidInstallationContext);
        }
        if (filterInstalls.installations.length !== 1) {
            throw new MultipleMatchingInstallationsError();
        }
        return filterInstalls.installations[0];
    }
    async hasOutdatedProductInstallation(environment) {
        const { installations } = await this.listNonTechnicalAppInstallations({
            environment
        });
        return installations.some((installation) => !installation.version.isLatest);
    }
    async getEntitlementOfferingProduct(site, product) {
        return this.getEntitlementOffering.getEntitlementOffering(site, product);
    }
    async upgradeInstallation(site, product, environmentKey, appId) {
        try {
            await this.upgradeAppInstallationsClient.upgradeInstallation({
                site,
                product,
                environmentKey,
                appId
            });
            return false;
        }
        catch (e) {
            if (e.code === graphql_client_1.ALREADY_UPGRADED_CODE) {
                return true;
            }
            else {
                throw e;
            }
        }
    }
    async getVersionByMajorVersionId(id, environmentKey, majorVersion) {
        const versionDetails = await this.getVersionByMajorVersionIdClient.getVersionByMajorVersionId(id, environmentKey, majorVersion);
        const versions = versionDetails?.nodes;
        if (!versions || versions.length === 0)
            return;
        const version = versions[0];
        if (!version)
            return undefined;
        const { scopes, egressAddresses, requiredProducts } = this.getPermissionsFromAppEnvironmentVersion(version);
        const groupedEgressAddresses = (0, egress_1.sortAndGroupEgressPermissionsByDomain)(egressAddresses);
        return {
            scopes,
            requiredProducts,
            hasDeployments: version.version !== NO_DEPLOYMENTS_VERSION,
            egressAddresses: groupedEgressAddresses,
            addedScopes: scopes,
            environmentType: versionDetails.environmentType,
            versionId: version.id,
            isLatest: version.isLatest,
            version: version.version
        };
    }
    getPermissionsFromAppEnvironmentVersion(appEnvironmentVersion) {
        const permissions = appEnvironmentVersion?.permissions[0];
        const requiredProducts = appEnvironmentVersion?.requiredProducts ?? [];
        if (!permissions) {
            return { scopes: [], egressAddresses: [], requiredProducts };
        }
        const scopes = permissions.scopes.map((s) => s.key);
        const egressAddresses = permissions?.egress ? (0, cli_shared_1.flatMap)(permissions.egress, ({ addresses }) => addresses ?? []) : [];
        return { scopes, egressAddresses, requiredProducts };
    }
    async getAppEnvironmentPermissions(appId, environmentKey) {
        const versionDetails = await this.listInstallationsClient.getVersions(appId, environmentKey, 2);
        const versions = versionDetails?.nodes;
        if (!versions || versions.length === 0)
            return;
        const [{ scopes, egressAddresses, requiredProducts }, oldVersion] = versions.map((appEnvironmentVersion) => this.getPermissionsFromAppEnvironmentVersion(appEnvironmentVersion));
        const groupedEgressAddresses = (0, egress_1.sortAndGroupEgressPermissionsByDomain)(egressAddresses);
        if (!oldVersion) {
            return {
                scopes,
                requiredProducts,
                hasDeployments: false,
                egressAddresses: groupedEgressAddresses,
                addedScopes: scopes,
                environmentType: versionDetails.environmentType
            };
        }
        const { scopes: oldScopes } = oldVersion;
        const addedScopes = (0, lodash_1.difference)(scopes, oldScopes);
        return {
            scopes,
            requiredProducts,
            hasDeployments: true,
            egressAddresses: groupedEgressAddresses,
            addedScopes,
            environmentType: versionDetails.environmentType
        };
    }
}
exports.InstallationService = InstallationService;
//# sourceMappingURL=installation-service.js.map