"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InProcessTunnelService = exports.EnvironmentIsNotDefined = exports.InvalidContainerServicePort = exports.DockerUnableToStartError = exports.DockerUnableToPullProxySidecarImage = exports.DockerAuthenticationError = exports.InvalidDebugStartingPortNumber = exports.DebugArgumentNameMismatch = exports.FunctionHandlersMustBeDefinedInDebugMode = void 0;
const manifest_1 = require("@forge/manifest");
const cli_shared_1 = require("@forge/cli-shared");
class FunctionHandlersMustBeDefinedInDebugMode extends cli_shared_1.UserError {
    constructor() {
        super(cli_shared_1.Text.tunnel.functionHandlersMustBeDefined);
    }
}
exports.FunctionHandlersMustBeDefinedInDebugMode = FunctionHandlersMustBeDefinedInDebugMode;
class DebugArgumentNameMismatch extends cli_shared_1.UserError {
    constructor(functionHandler) {
        super(cli_shared_1.Text.tunnel.debugArgumentNameMismatch(functionHandler));
    }
}
exports.DebugArgumentNameMismatch = DebugArgumentNameMismatch;
class InvalidDebugStartingPortNumber extends cli_shared_1.UserError {
    constructor(port) {
        super(cli_shared_1.Text.tunnel.invalidDebugStartingPortNumber(port));
    }
}
exports.InvalidDebugStartingPortNumber = InvalidDebugStartingPortNumber;
class DockerAuthenticationError extends cli_shared_1.UserError {
    constructor(errCode) {
        super(cli_shared_1.Text.tunnel.unableToAuthenticateDocker(errCode));
    }
}
exports.DockerAuthenticationError = DockerAuthenticationError;
class DockerUnableToPullProxySidecarImage extends cli_shared_1.UserError {
    constructor(err) {
        super(cli_shared_1.Text.tunnel.unableToPullProxySidecarImage(err?.message ?? 'Unknown Error Occurred.'));
    }
}
exports.DockerUnableToPullProxySidecarImage = DockerUnableToPullProxySidecarImage;
class DockerUnableToStartError extends cli_shared_1.UserError {
    constructor(err) {
        super(cli_shared_1.Text.tunnel.unableToStartDockerComposeStack(err?.message ?? 'Unknown Error Occurred.'));
    }
}
exports.DockerUnableToStartError = DockerUnableToStartError;
class InvalidContainerServicePort extends cli_shared_1.UserError {
    constructor(serviceKey) {
        super(cli_shared_1.Text.error.invalidServicePort(serviceKey));
    }
}
exports.InvalidContainerServicePort = InvalidContainerServicePort;
class EnvironmentIsNotDefined extends cli_shared_1.UserError {
    constructor(envKey) {
        super(cli_shared_1.Text.error.environmentIsNotDefined(envKey));
    }
}
exports.EnvironmentIsNotDefined = EnvironmentIsNotDefined;
class InProcessTunnelService {
    startTunnelCommand;
    tunnelInteractor;
    configFilePortFindingService;
    constructor(startTunnelCommand, tunnelInteractor, configFilePortFindingService) {
        this.startTunnelCommand = startTunnelCommand;
        this.tunnelInteractor = tunnelInteractor;
        this.configFilePortFindingService = configFilePortFindingService;
    }
    async run(tunnelOptions) {
        const resourcePortMap = await this.configFilePortFindingService.findPorts();
        const tunnel = await this.startTunnelCommand.execute({
            environmentKey: tunnelOptions.environment || process.env.ENVIRONMENT_KEY || 'default',
            resourcePortMap,
            host: 'localhost',
            url: tunnelOptions.url,
            port: tunnelOptions.localPort
        }, tunnelOptions.containersDockerComposeFiles);
        const monitor = await this.tunnelInteractor.watchApp(tunnel, tunnelOptions);
        const manifestFileWatcher = this.tunnelInteractor.watchAndWarnOnManifestChanges(manifest_1.MANIFEST_FILE);
        await this.tunnelInteractor.handleUserExitEvent(tunnel.stopFunction, monitor, manifestFileWatcher);
    }
}
exports.InProcessTunnelService = InProcessTunnelService;
//# sourceMappingURL=tunnel-service.js.map