"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionService = exports.MissingVersionUpgradeParameters = void 0;
const semver_1 = require("semver");
const cli_shared_1 = require("@forge/cli-shared");
const manifest_1 = require("@forge/manifest");
class MissingVersionUpgradeParameters extends Error {
    constructor() {
        super(cli_shared_1.Text.version.upgrade.start.error.missingVersionUpgradeParameters);
    }
}
exports.MissingVersionUpgradeParameters = MissingVersionUpgradeParameters;
class VersionService {
    getAppConfig;
    versionDetailsClient;
    adapters = [this.addDefaultTypeToLegacyWebtriggerDetails];
    constructor(getAppConfig, versionDetailsClient) {
        this.getAppConfig = getAppConfig;
        this.versionDetailsClient = versionDetailsClient;
    }
    filterOutEmpty(array) {
        return array?.filter((entry) => entry !== null) || [];
    }
    getEgresses(egresses, remoteModules) {
        const remoteModuleUrls = this.filterOutEmpty(remoteModules).map((remote) => remote?.extensionData.baseUrl);
        const egressesWithoutRemoteModules = this.filterOutEmpty(egresses).map((entry) => {
            if (entry.type === 'FETCH_BACKEND_SIDE') {
                return {
                    ...entry,
                    addresses: entry.addresses?.filter((address) => !remoteModuleUrls.includes(address))
                };
            }
            return entry;
        });
        return egressesWithoutRemoteModules
            .filter((entry) => this.filterOutEmpty(entry.addresses).length !== 0)
            .filter((entry) => entry.category !== 'ANALYTICS')
            .map((entry) => ({
            type: this.getTypeFromPermissionType(entry.type),
            addresses: entry.addresses || []
        }));
    }
    getAnalytics(egresses) {
        return this.filterOutEmpty(egresses)
            .filter((entry) => entry.category === 'ANALYTICS')
            ?.map((entry) => ({
            type: this.getTypeFromPermissionType(entry.type),
            addresses: entry.addresses || [],
            inScopeEUD: entry.inScopeEUD || false
        }));
    }
    getPolicies(securityPolicies) {
        return this.filterOutEmpty(securityPolicies).map((entry) => ({
            type: this.getTypeFromPermissionType(entry.type),
            policies: entry.policies || []
        }));
    }
    getConnectedKeys(migrationKeys) {
        if (!migrationKeys) {
            return [];
        }
        return Object.keys(migrationKeys).map((key) => ({
            product: key,
            key: migrationKeys[key] || ''
        }));
    }
    getFunctions(functionModules) {
        const isOldFunctionsExtension = (extensionData) => {
            return 'functionName' in extensionData;
        };
        const isNewFunctionsExtension = (extensionData) => {
            return 'functions' in extensionData;
        };
        const getRuntimeName = (identifier) => (identifier || 'sandbox').replace('provided.al2', 'sandbox').replace('provided', 'sandbox');
        return this.filterOutEmpty(functionModules).map((entry) => {
            const { key, extensionData } = entry;
            if (isOldFunctionsExtension(extensionData)) {
                return {
                    key,
                    runtimeName: getRuntimeName(extensionData.runtime?.identifier),
                    handler: extensionData.handler
                };
            }
            else if (isNewFunctionsExtension(extensionData)) {
                const keysOfFunctions = Object.keys(extensionData.functions || {});
                return {
                    key,
                    runtimeName: getRuntimeName(extensionData.functions[keysOfFunctions[0]].runtime.identifier),
                    handler: extensionData.handler
                };
            }
            else {
                throw new Error('Unknown function extension data format');
            }
        });
    }
    async getAppVersionDetails(environmentKey, majorVersion) {
        const { id: appId } = await this.getAppConfig();
        const data = await this.versionDetailsClient.getVersionDetails(appId, environmentKey, majorVersion);
        const functionModules = data.modules?.filter((mod) => mod?.extensionData.type === manifest_1.AllModuleTypes.CoreFunction);
        const remoteModules = data.modules?.filter((mod) => mod?.extensionData.type === manifest_1.AllModuleTypes.CoreRemote);
        const allModules = this.getModulesGroupedByTypes(data.modules);
        const appDetails = {
            requiresLicense: data.requiresLicense,
            egresses: this.getEgresses(data.permissions?.[0].egress, remoteModules),
            analytics: this.getAnalytics(data.permissions?.[0].egress),
            scopes: data.permissions?.[0].scopes.map((scope) => scope.key).sort() || [],
            policies: this.getPolicies(data.permissions?.[0].securityPolicies),
            connectKeys: this.getConnectedKeys(data.migrationKeys),
            appVersion: (0, semver_1.major)(data.appVersion),
            deploymentDateTime: data.deploymentDateTime,
            environmentType: data.environmentType,
            functions: this.getFunctions(functionModules),
            modules: Object.keys(allModules)
                .filter((type) => !['function', 'remote'].includes(type))
                .map((type) => ({ type, items: allModules[type] })),
            remotes: this.filterOutEmpty(remoteModules).map((entry) => ({
                key: entry.key || 'N/A',
                baseUrl: entry.extensionData.baseUrl,
                operations: entry.extensionData.operations || []
            })),
            environment: (0, cli_shared_1.environmentToOption)(environmentKey)
        };
        this.applyPropertyAdapter(appDetails);
        return appDetails;
    }
    getTypeFromPermissionType(permissionType) {
        switch (permissionType) {
            case cli_shared_1.AppNetworkPermissionType.FetchBackendSide:
                return 'fetch.backend';
            case cli_shared_1.AppNetworkPermissionType.FetchClientSide:
                return 'fetch.client';
            default:
                return permissionType?.toLowerCase().replaceAll('_', '.') || 'N/A';
        }
    }
    getModulesGroupedByTypes(modules) {
        const rawModules = this.filterOutEmpty(modules)
            .filter((mod) => manifest_1.SUPPORTED_MODULES.includes(mod.extensionData.type))
            .filter((mod) => ![manifest_1.AllModuleTypes.CoreFunction, manifest_1.AllModuleTypes.CoreRemote].includes(mod.extensionData.type))
            .map((entry) => ({
            key: entry.key,
            type: entry.extensionData.type,
            properties: {
                ...this.removeInternalPropertiesFromObject(entry.extensionData)
            }
        }));
        return rawModules.reduce((acc, entry) => {
            const type = (0, manifest_1.cleanKey)(entry.type);
            if (acc[type] === undefined) {
                acc[type] = [];
            }
            acc[type].push(entry);
            return acc;
        }, {});
    }
    removeInternalPropertiesFromObject(obj) {
        const { type, functions, outboundAuthContainerId, resourceUploadId, key, ...rest } = obj;
        return rest;
    }
    async getAppVersions(environmentKey) {
        const { id: appId } = await this.getAppConfig();
        return await this.versionDetailsClient.getVersionList(appId, environmentKey);
    }
    async getAppVersionOverviewList(environmentKey) {
        const versions = await this.getAppVersions(environmentKey);
        const majorVersions = versions.map((version) => (0, semver_1.major)(version)).filter((majorVersion) => majorVersion > 0);
        const versionDetails = await Promise.all(majorVersions.map(async (version) => await this.getAppVersionDetails(environmentKey, version)));
        return versionDetails.map((entry) => ({
            version: entry.appVersion,
            deploymentDateTime: entry.deploymentDateTime,
            environmentType: entry.environmentType,
            egresses: entry.egresses.map((egress) => ({ type: egress.type, count: egress.addresses.length })),
            analytics: entry.analytics.map((analytic) => ({ type: analytic.type, count: analytic.addresses.length })),
            policies: entry.policies.map((policy) => ({ type: policy.type, count: policy.policies.length })),
            scopes: (entry.scopes.length || 0).toString(),
            connectKeys: (entry.connectKeys.length || 0).toString(),
            functions: (entry.functions.length || 0).toString(),
            remotes: (entry.remotes.length || 0).toString(),
            modules: entry.modules.map((module) => ({ type: module.type, count: module.items.length })),
            requiresLicense: entry.requiresLicense
        }));
    }
    async getAppUpgradeVersionsList(environmentKey) {
        const { id: appId } = await this.getAppConfig();
        return await this.versionDetailsClient.getAppUpgradeVersionsList(appId, environmentKey);
    }
    async getUpgradableVersions(environmentKey, sourceVersionId) {
        const { id: appId } = await this.getAppConfig();
        return await this.versionDetailsClient.getAppUpgradableToList(appId, environmentKey, sourceVersionId);
    }
    async createAppVersionUpgradeRollout(environmentKey, sourceVersionId, targetVersionId, sourceVersionNumber, targetVersionNumber) {
        if (!sourceVersionId || !targetVersionId) {
            throw new MissingVersionUpgradeParameters();
        }
        return await this.versionDetailsClient.createAppVersionUpgradeRollout(environmentKey, sourceVersionId, targetVersionId, sourceVersionNumber, targetVersionNumber);
    }
    async createAppVersionUpgradeRolloutNonInteractively(environmentKey, sourceMajorVersion, targetMajorVersion) {
        if (!sourceMajorVersion || !targetMajorVersion) {
            throw new MissingVersionUpgradeParameters();
        }
        const { id: appId } = await this.getAppConfig();
        const selectedSourceVersion = await this.versionDetailsClient.getAppVersionIdentity(appId, environmentKey, sourceMajorVersion);
        const selectedTargetVersion = await this.versionDetailsClient.getAppVersionIdentity(appId, environmentKey, targetMajorVersion);
        return await this.createAppVersionUpgradeRollout(environmentKey, selectedSourceVersion.id, selectedTargetVersion.id, sourceMajorVersion.toString(), targetMajorVersion.toString());
    }
    async getAppVersionUpgradeRolloutsList(environmentKey) {
        const { id: appId } = await this.getAppConfig();
        return await this.versionDetailsClient.getAppVersionRolloutsList(appId, environmentKey);
    }
    async cancelAppVersionRollout(appRolloutId, environmentKey) {
        return await this.versionDetailsClient.cancelAppVersionUpgradeRollout(appRolloutId, environmentKey);
    }
    async getAppVersionRollout(appRolloutId) {
        return await this.versionDetailsClient.getAppVersionRollout(appRolloutId);
    }
    applyPropertyAdapter(appDetails) {
        for (const adapter of this.adapters) {
            for (const [property, propertyDetails] of Object.entries(appDetails)) {
                const [propertyKey, updatedPropertyDetails] = adapter([property, propertyDetails]);
                Object.defineProperty(appDetails, propertyKey, { value: updatedPropertyDetails });
            }
        }
    }
    addDefaultTypeToLegacyWebtriggerDetails(params) {
        if (params[0] === 'modules') {
            for (const module of params[1]) {
                if (module.type !== 'webtrigger')
                    continue;
                for (const wt of module.items) {
                    if (!wt.properties.response) {
                        wt.properties = {
                            ...wt.properties,
                            response: {
                                type: 'dynamic (default)'
                            }
                        };
                    }
                }
            }
        }
        return params;
    }
}
exports.VersionService = VersionService;
//# sourceMappingURL=version-service.js.map