"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppVersionDetailsClient = exports.MissingAppVersionError = exports.EnvironmentNotFoundError = exports.MissingAppVersionRolloutError = exports.MissingAppError = void 0;
const cli_shared_1 = require("@forge/cli-shared");
class MissingAppError extends cli_shared_1.UserError {
}
exports.MissingAppError = MissingAppError;
class MissingAppVersionRolloutError extends Error {
}
exports.MissingAppVersionRolloutError = MissingAppVersionRolloutError;
class EnvironmentNotFoundError extends cli_shared_1.UserError {
    constructor(environmentKey) {
        super(cli_shared_1.Text.env.error.envNotExist(environmentKey));
    }
}
exports.EnvironmentNotFoundError = EnvironmentNotFoundError;
class MissingAppVersionError extends Error {
}
exports.MissingAppVersionError = MissingAppVersionError;
class AppVersionDetailsClient {
    graphqlClient;
    constructor(graphqlClient) {
        this.graphqlClient = graphqlClient;
    }
    async getVersionDetails(appId, environmentKey, majorVersion) {
        const query = `
      query forge_cli_getApplicationVersionDetails($appId: ID!, $environmentKey: String!, $firstN: Int!, $majorVersion: Int) {
        app(id: $appId) {
          environmentByKey(key: $environmentKey) {
            type
            key
            versions(first: $firstN, majorVersion: $majorVersion) {
              nodes {
                version
                createdAt
                isLatest
                requiresLicense
                permissions {
                  scopes {
                    key
                  }
                  egress {
                    type
                    addresses
                    category
                    inScopeEUD
                  }
                  securityPolicies {
                    type
                    policies
                  }
                }
                extensions {
                  nodes {
                    id
                    key
                    extensionData
                  }
                }
                storage {
                  hosted {
                    classifications
                    locations
                  }
                  remotes {
                    key
                    baseUrl
                    classifications
                    locations
                  }
                }
                migrationKeys {
                  jira
                  confluence
                }
              }
            }
          }
        }
      }
    `;
        const result = await this.graphqlClient.query(query, {
            appId,
            environmentKey,
            firstN: 1,
            majorVersion
        });
        if (!result.app) {
            throw new MissingAppError();
        }
        if (!result.app.environmentByKey) {
            throw new EnvironmentNotFoundError(environmentKey);
        }
        if (!result.app.environmentByKey.versions?.nodes?.length || !result.app.environmentByKey.versions?.nodes?.[0]) {
            throw new MissingAppVersionError();
        }
        return {
            migrationKeys: result.app.environmentByKey.versions?.nodes?.[0]?.migrationKeys,
            environmentType: result.app.environmentByKey.type,
            appVersion: result.app.environmentByKey.versions?.nodes?.[0]?.version,
            deploymentDateTime: new Date(Number.parseInt(result.app.environmentByKey.versions?.nodes?.[0]?.createdAt)),
            storage: result.app.environmentByKey.versions?.nodes?.[0]?.storage,
            requiresLicense: result.app.environmentByKey.versions?.nodes?.[0]?.requiresLicense,
            permissions: result.app.environmentByKey.versions?.nodes?.[0]?.permissions,
            modules: result.app.environmentByKey.versions?.nodes?.[0]?.extensions?.nodes,
            environment: result.app.environmentByKey.key
        };
    }
    async getVersionList(appId, environmentKey) {
        const query = `
      query forge_cli_getApplicationVersionList($appId: ID!, $first: Int, $after: String) {
        app(id: $appId) {
          environments {
            key
            versions(first: $first, after: $after) {
              nodes {
                version
              }
              pageInfo {
                hasNextPage
                endCursor
              }
            }
          }
        }
      }
    `;
        const output = [];
        let cursor = undefined;
        let hasNext = undefined;
        do {
            const result = await this.graphqlClient.query(query, {
                appId,
                first: 20,
                after: cursor
            });
            if (!result.app) {
                throw new MissingAppError();
            }
            if (!result.app.environments) {
                throw new MissingAppVersionError();
            }
            const environment = result.app.environments.filter((env) => env.key === environmentKey)[0];
            cursor = environment?.versions?.pageInfo.endCursor;
            hasNext = environment?.versions?.pageInfo.hasNextPage;
            output.push(...(environment?.versions?.nodes?.map((node) => node?.version) || []).filter((item) => Boolean(item)));
        } while (hasNext && cursor);
        return output;
    }
    async getAppUpgradeVersionsList(appId, environmentKey) {
        const query = `
      query forge_cli_getAppUpgradeVersionsList($appId: ID!, $environmentKey: String!) {
        app(id: $appId) {
          environmentByKey(key: $environmentKey) {
            key
            versions {
              nodes {
                createdAt
                id
                installations {
                  totalCount
                }
                version
              }
            }
          }
        }
      }
    `;
        let output = [];
        const result = await this.graphqlClient.query(query, {
            appId,
            environmentKey
        });
        if (!result.app) {
            throw new MissingAppError();
        }
        if (!result.app.environmentByKey || !result.app.environmentByKey.versions) {
            throw new MissingAppVersionError();
        }
        const versions = result.app.environmentByKey.versions.nodes;
        if (!versions || versions.length === 0) {
            return output;
        }
        output = versions.map((node) => {
            return {
                version: node?.version ?? '',
                installations: node?.installations?.totalCount ?? 0,
                deploymentDateTime: node?.createdAt ? new Date(Number.parseInt(node?.createdAt)) : undefined,
                id: node?.id ?? ''
            };
        });
        return output;
    }
    async getAppUpgradableToList(appId, environmentKey, sourceVersionId) {
        const query = `
      query forge_cli_getAppUpgradableToList($appId: ID!, $environmentKey: String!, $sourceVersionId: ID!) {
        app(id: $appId) {
          environmentByKey(key: $environmentKey) {
            key
            versions {
              nodes {
                createdAt
                id
                version
                upgradeableByRolloutFromVersion(
                  sourceVersionId: $sourceVersionId
                ) {
                  upgradeableByRollout
                }
              }
            }
          }
        }
      }
    `;
        let output = [];
        const result = await this.graphqlClient.query(query, {
            appId,
            environmentKey,
            sourceVersionId
        });
        if (!result.app) {
            throw new MissingAppError();
        }
        if (!result.app.environmentByKey || !result.app.environmentByKey.versions) {
            throw new MissingAppVersionError();
        }
        const versions = result.app.environmentByKey.versions.nodes;
        if (!versions || versions.length === 0) {
            return output;
        }
        output = versions.map((node) => {
            return {
                version: node?.version ?? '',
                deploymentDateTime: node?.createdAt ? new Date(Number.parseInt(node?.createdAt)) : undefined,
                id: node?.id ?? '',
                upgradeableTo: node?.upgradeableByRolloutFromVersion?.upgradeableByRollout
            };
        });
        return output.filter((version) => version.upgradeableTo);
    }
    async createAppVersionUpgradeRollout(environmentKey, sourceVersionId, targetVersionId, sourceVersionNumber, targetVersionNumber) {
        const query = `
      mutation forge_cli_createAppVersionUpgradeRollout($input: CreateAppVersionRolloutInput!) {
        ecosystem {
          createAppVersionRollout(input: $input) {
            success
            appVersionRollout {
              id
              status
            }
            errors {
              message
              extensions {
                errorType
                statusCode
              }
            }
          }
        }
      }
    `;
        const variables = {
            input: {
                sourceVersionId,
                targetVersionId
            }
        };
        const { response: { ecosystem: { createAppVersionRollout } }, requestId } = await this.graphqlClient.mutate(query, variables);
        if (!createAppVersionRollout) {
            throw new cli_shared_1.GraphQlMutationError(`Unable to get a response (requestId: ${requestId || 'unknown'})`, { requestId });
        }
        const { success, appVersionRollout, errors } = createAppVersionRollout;
        if (success) {
            if (!appVersionRollout) {
                throw new MissingAppVersionRolloutError();
            }
            return appVersionRollout.id;
        }
        else {
            if (errors && errors.length > 0) {
                const errorList = [];
                errors.forEach((error) => {
                    if (error?.extensions?.errorType && error.message) {
                        switch (error.extensions.errorType) {
                            case 'APP_ROLLOUT_RUNNING':
                                errorList.push(cli_shared_1.Text.version.upgrade.start.error.appVersionRolloutRunning);
                                break;
                            case 'PermissionDeniedError':
                                errorList.push(cli_shared_1.Text.version.upgrade.start.error.permissionDeniedError(sourceVersionNumber, targetVersionNumber, environmentKey));
                                break;
                            case 'APP_NOT_FOUND':
                                errorList.push(cli_shared_1.Text.version.upgrade.start.error.inValidVersionNumberSpecified(sourceVersionNumber, targetVersionNumber));
                                break;
                            case 'TOO_MANY_APP_ROLLOUTS_RUNNING_FOR_ACCOUNT':
                                errorList.push(cli_shared_1.Text.version.upgrade.start.error.tooManyRequestsFromAccount);
                                break;
                            case 'APP_ROLLOUTS_UNAVAILABLE':
                                errorList.push(cli_shared_1.Text.version.upgrade.start.error.tooManyRequestsGlobally);
                                break;
                            default:
                                errorList.push(error.message);
                                break;
                        }
                    }
                    else {
                        errorList.push(error?.message ? error.message : '');
                    }
                });
                throw new Error(errorList.join(`\n`));
            }
        }
    }
    async getAppVersionIdentity(appId, environmentKey, majorVersion) {
        const query = `
      query forge_cli_getApplicationIdentityVersionDetails($appId: ID!, $environmentKey: String!, $firstN: Int!, $majorVersion: Int) {
        app(id: $appId) {
          environmentByKey(key: $environmentKey) {
            type
            versions(first: $firstN, majorVersion: $majorVersion) {
              nodes {
                version
                id
              }
            }
          }
        }
      }
    `;
        const result = await this.graphqlClient.query(query, {
            appId,
            environmentKey,
            firstN: 1,
            majorVersion
        });
        if (!result.app) {
            throw new MissingAppError();
        }
        if (!result.app.environmentByKey) {
            throw new EnvironmentNotFoundError(environmentKey);
        }
        if (!result.app.environmentByKey.versions?.nodes?.length || !result.app.environmentByKey.versions?.nodes?.[0]) {
            throw new Error(cli_shared_1.Text.version.upgrade.start.error.inValidMajorVersionNumberSpecified(majorVersion));
        }
        return {
            id: result.app.environmentByKey.versions?.nodes?.[0]?.id,
            appVersion: result.app.environmentByKey.versions?.nodes?.[0]?.version
        };
    }
    async getAppVersionRolloutsList(appId, environmentKey) {
        const query = `
      query forge_cli_getAppVersionRolloutsList(
        $appId: ID!,
        $environmentKey: String!
      ) {
        app(id: $appId) {
          environmentByKey(key: $environmentKey) {
            id
            type
            versions {
              nodes {
                version
                id
              }
            }
            appVersionRollouts {
              nodes {
                id
                appId
                appEnvironmentId
                createdAt
                completedAt
                status
                sourceVersionId
                targetVersionId
                progress {
                  completedUpgradeCount
                  failedUpgradeCount
                  pendingUpgradeCount
                }
              }
            }
          }
        }
      }
    `;
        const output = [];
        const result = await this.graphqlClient.query(query, {
            appId,
            environmentKey
        });
        if (!result.app) {
            throw new MissingAppError();
        }
        const environment = result.app.environmentByKey;
        const versionRollouts = environment?.appVersionRollouts?.nodes;
        if (!versionRollouts || versionRollouts.length === 0) {
            return output;
        }
        output.push(...versionRollouts.map((node) => {
            return {
                id: node?.id,
                appId: node?.appId,
                environmentType: environment.type,
                status: node?.status,
                createdAt: node?.createdAt.toString(),
                completedAt: node?.completedAt ? node?.completedAt.toString() : 'In progress',
                sourceVersionId: environment.versions?.nodes?.find((version) => version?.id === node?.sourceVersionId)
                    ?.version,
                targetVersionId: environment.versions?.nodes?.find((version) => version?.id === node?.targetVersionId)
                    ?.version,
                completedUpgradeCount: node?.progress.completedUpgradeCount,
                pendingUpgradeCount: node?.progress.pendingUpgradeCount,
                failedUpgradeCount: node?.progress.failedUpgradeCount
            };
        }));
        return output;
    }
    async getAppVersionRollout(appRolloutId) {
        const query = `
    query forge_cli_getAppVersionRollout($appRolloutId: ID!) {
      ecosystem {
        appVersionRollout(id: $appRolloutId) {
          progress {
            completedUpgradeCount
            failedUpgradeCount
            pendingUpgradeCount
          }
          sourceVersionId
          targetVersionId
          status
          id
          appId
          completedAt
        }
      }
    }`;
        const result = await this.graphqlClient.query(query, {
            appRolloutId
        });
        if (!result?.ecosystem?.appVersionRollout?.id) {
            throw new Error(cli_shared_1.Text.version.upgrade.cancel.error.inValidRolloutIdSpecified);
        }
        const appVersionRollout = result.ecosystem.appVersionRollout;
        return {
            completedUpgradeCount: appVersionRollout.progress.completedUpgradeCount,
            failedUpgradeCount: appVersionRollout.progress.failedUpgradeCount,
            pendingUpgradeCount: appVersionRollout.progress.pendingUpgradeCount,
            appId: appVersionRollout.appId,
            id: appVersionRollout.id,
            sourceVersionId: appVersionRollout.sourceVersionId,
            targetVersionId: appVersionRollout.targetVersionId,
            status: appVersionRollout.status
        };
    }
    async cancelAppVersionUpgradeRollout(appRolloutId, environmentKey) {
        const query = `
      mutation forge_cli_cancelAppVersionUpgradeRollout($input: CancelAppVersionRolloutInput!) {
        ecosystem {
          cancelAppVersionRollout(input: $input) {
            success
            errors {
              extensions {
                errorType
                statusCode
              }
              message
            }
          }
        }
      }
    `;
        const variables = {
            input: {
                id: appRolloutId
            }
        };
        const { response: { ecosystem: { cancelAppVersionRollout } }, requestId } = await this.graphqlClient.mutate(query, variables);
        if (!cancelAppVersionRollout) {
            throw new cli_shared_1.GraphQlMutationError(`Unable to get a response (requestId: ${requestId || 'unknown'})`, { requestId });
        }
        const { success, errors } = cancelAppVersionRollout;
        if (!success && errors && errors.length > 0) {
            const errorList = [];
            errors.forEach((error) => {
                if (error?.extensions?.errorType && error.message) {
                    switch (error.extensions.errorType) {
                        case 'PermissionDeniedError':
                            errorList.push(cli_shared_1.Text.version.upgrade.cancel.error.permissionDeniedError(environmentKey));
                            break;
                        case 'APP_ROLLOUT_NOT_RUNNING':
                            errorList.push(cli_shared_1.Text.version.upgrade.cancel.error.noUpdateInProgress(environmentKey));
                            break;
                        default:
                            errorList.push(error.message);
                            break;
                    }
                }
                else {
                    errorList.push(error?.message ? error.message : '');
                }
            });
            throw new Error(errorList.join(`\n`));
        }
        return true;
    }
}
exports.AppVersionDetailsClient = AppVersionDetailsClient;
//# sourceMappingURL=graphql-client.js.map