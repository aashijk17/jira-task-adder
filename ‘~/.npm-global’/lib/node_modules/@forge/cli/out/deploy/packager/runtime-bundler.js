"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeBundler = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const bundler_1 = require("@forge/bundler");
const cli_shared_1 = require("@forge/cli-shared");
const i18n_1 = require("@forge/i18n");
class RuntimeBundler {
    archiverFactory;
    logger;
    bundler;
    fileSystemReader;
    configReader;
    constructor(archiverFactory, logger, bundler, fileSystemReader, configReader) {
        this.archiverFactory = archiverFactory;
        this.logger = logger;
        this.bundler = bundler;
        this.fileSystemReader = fileSystemReader;
        this.configReader = configReader;
    }
    async packageCode(archiver, entryPoints, i18nResourceBundle) {
        let combinedMetadata = (0, bundler_1.emptyMetadata)();
        if (entryPoints.length > 0) {
            let bundlerResponse;
            try {
                bundlerResponse = await this.bundler.bundle({ appDirectory: process.cwd(), entryPoints, i18nResourceBundle });
            }
            catch (e) {
                throw new bundler_1.BundlerError(e.message);
            }
            const { outputDir, metadata } = bundlerResponse;
            if (metadata) {
                combinedMetadata = (0, bundler_1.mergeMetadata)(combinedMetadata, metadata);
            }
            this.logger.debug(cli_shared_1.Text.deploy.taskPackage.packageBundledFiles);
            for (const name of await this.fileSystemReader.getFileGlobList([`${outputDir}/**`])) {
                archiver.addFileFrom(path_1.default.relative(outputDir, name), name);
            }
        }
        return combinedMetadata;
    }
    async packageDependencies(archiver) {
        const manifest = JSON.stringify(await this.configReader.readConfig());
        archiver.addFile(cli_shared_1.manifestFileName, Buffer.from(manifest));
        for (const fileName of cli_shared_1.dependencyFileNames) {
            if (!this.fileSystemReader.fileExists(fileName)) {
                continue;
            }
            archiver.addFileFrom(fileName, fileName);
        }
    }
    async packageAll(archiver, handlers, packageConfig, i18nResourceBundle) {
        const entryPoints = (0, bundler_1.getEntryPoints)(handlers);
        const metadata = await this.packageCode(archiver, entryPoints, i18nResourceBundle);
        await this.packageDependencies(archiver);
        const files = await this.fileSystemReader.getFileGlobList(packageConfig?.extraFiles ?? []);
        for (const fileName of files) {
            archiver.addFileFrom(fileName, fileName);
        }
        return metadata;
    }
    packageI18nResources(archiver, i18nResourceBundle) {
        (0, cli_shared_1.listFilesInI18nResourceBundle)(i18nResourceBundle).forEach(([fileName, filePath]) => {
            archiver.addFileFrom(path_1.default.join(i18n_1.I18N_BUNDLE_FOLDER_NAME, fileName), filePath);
        });
    }
    async bundle(handlers, i18nResourceBundle, packageConfig) {
        const archiver = this.archiverFactory();
        const metadata = await this.packageAll(archiver, handlers, packageConfig, i18nResourceBundle);
        if (handlers.length === 0) {
            this.packageI18nResources(archiver, i18nResourceBundle);
        }
        const archivePath = await archiver.finalise();
        this.logger.debug(cli_shared_1.Text.deploy.taskPackage.archiveCreated(archivePath));
        return { runtimeArchivePath: archivePath, metadata };
    }
}
exports.RuntimeBundler = RuntimeBundler;
//# sourceMappingURL=runtime-bundler.js.map