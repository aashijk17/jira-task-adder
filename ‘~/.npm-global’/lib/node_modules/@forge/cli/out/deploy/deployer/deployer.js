"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArtifactDeployer = exports.ExistingInstallationsError = exports.ManifestValidationFailedError = exports.HostedResourceDeploymentFailedError = exports.AppDeploymentFailedError = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const DEPLOYMENT_EVENT_POLL_INTERVAL = 500;
class AppDeploymentFailedError extends cli_shared_1.BaseError {
    userError;
    constructor(userError = false, requestId, message) {
        super(requestId, `${message} (requestId: ${requestId || 'unknown'})`);
        this.userError = userError;
    }
    isUserError() {
        return this.userError;
    }
}
exports.AppDeploymentFailedError = AppDeploymentFailedError;
class HostedResourceDeploymentFailedError extends cli_shared_1.BaseError {
    userError;
    constructor(userError = false, requestId, message) {
        super(requestId, message);
        this.userError = userError;
    }
    isUserError() {
        return this.userError;
    }
}
exports.HostedResourceDeploymentFailedError = HostedResourceDeploymentFailedError;
class ManifestValidationFailedError extends cli_shared_1.UserError {
    constructor(requestId, message) {
        super(`${message} (requestId: ${requestId || 'unknown'})`, requestId);
    }
}
exports.ManifestValidationFailedError = ManifestValidationFailedError;
class ExistingInstallationsError extends cli_shared_1.BaseError {
    userError;
    constructor(userError = false, requestId, message) {
        super(requestId, `${message} (requestId: ${requestId || 'unknown'})`);
        this.userError = userError;
    }
    isUserError() {
        return this.userError;
    }
}
exports.ExistingInstallationsError = ExistingInstallationsError;
function isTransitionEvent(event) {
    return event.__typename === 'AppDeploymentTransitionEvent';
}
class ArtifactDeployer {
    getConfiguredApp;
    deployClient;
    deployMonitorClient;
    pause;
    ui;
    constructor(getConfiguredApp, deployClient, deployMonitorClient, pause, ui) {
        this.getConfiguredApp = getConfiguredApp;
        this.deployClient = deployClient;
        this.deployMonitorClient = deployMonitorClient;
        this.pause = pause;
        this.ui = ui;
    }
    async deploy(environmentKey, artifactUrl, hostedResourceUploadId, majorVersion, buildTag) {
        const { id } = await this.getConfiguredApp();
        const { deploymentId, requestId } = await this.doDeploy(id, environmentKey, artifactUrl, hostedResourceUploadId, majorVersion, buildTag);
        await this.monitorDeployment(id, environmentKey, deploymentId, requestId);
    }
    async doDeploy(appId, environmentKey, artifactUrl, hostedResourceUploadId, majorVersion, buildTag) {
        return await this.deployClient.deploy({
            appId,
            environmentKey,
            artifactUrl,
            hostedResourceUploadId,
            majorVersion,
            buildTag
        });
    }
    async pollAndCheckEvents(appId, environmentKey, deploymentId, totalStreamed, requestId) {
        const { stages, status, errorDetails } = await this.deployMonitorClient.getDeployment({
            appId,
            environmentKey,
            deploymentId
        });
        const events = this.extractAllEvents(stages || []);
        const handleEvent = this.getDeploymentEventsHandler();
        if (events.length > totalStreamed) {
            for (let i = totalStreamed; i < events.length; i++) {
                handleEvent(events[i]);
            }
            totalStreamed = events.length;
        }
        if (status === cli_shared_1.AppDeploymentStatus.Failed) {
            this.handleErrorEvent(errorDetails, requestId);
        }
        return {
            status,
            totalStreamed
        };
    }
    async monitorDeployment(appId, environmentKey, deploymentId, requestId) {
        let totalStreamed = 0;
        let status = cli_shared_1.AppDeploymentStatus.InProgress;
        while (status !== cli_shared_1.AppDeploymentStatus.Done) {
            const checks = await this.pollAndCheckEvents(appId, environmentKey, deploymentId, totalStreamed, requestId);
            totalStreamed = checks.totalStreamed;
            status = checks.status;
            await this.pause(DEPLOYMENT_EVENT_POLL_INTERVAL);
        }
    }
    extractAllEvents(stages) {
        return (0, cli_shared_1.flatMap)(stages, (stage) => {
            const events = stage.events || [];
            let stageHasTransitionEvent = false;
            return events
                .filter((event) => {
                if (!isTransitionEvent(event)) {
                    return true;
                }
                if (stageHasTransitionEvent) {
                    return false;
                }
                stageHasTransitionEvent = true;
                return true;
            })
                .map((event) => ({ ...event, stepName: stage.description }));
        });
    }
    getDeploymentEventsHandler() {
        let addNewLineBetweenTransitions = false;
        return (event) => {
            if (isTransitionEvent(event)) {
                if (event.newStatus === 'STARTED') {
                    if (addNewLineBetweenTransitions) {
                        this.ui.emptyLine();
                        addNewLineBetweenTransitions = false;
                    }
                    this.ui.info(cli_shared_1.Text.deploy.taskDeploy.serverStepStarted(event.stepName));
                }
            }
            else if (event.message) {
                this.ui.debug(event.message);
            }
        };
    }
    handleErrorEvent(errorDetails, requestId) {
        if (errorDetails) {
            const { code, message } = errorDetails;
            switch (code) {
                case 'ENVIRONMENT_UPDATE_VALIDATION_FAILED': {
                    const causeMessage = errorDetails?.fields?.validationResult.message.replace(/Upsert.*Error message: /, '');
                    if (causeMessage?.toLowerCase().includes('egress')) {
                        throw new AppDeploymentFailedError(true, requestId, cli_shared_1.Text.deploy.egressURL.error(causeMessage));
                    }
                    if (causeMessage?.toLowerCase().includes('existing installations')) {
                        if (causeMessage.toLowerCase().includes('modified')) {
                            throw new ExistingInstallationsError(true, requestId, cli_shared_1.Text.deploy.crossContext.modifyError);
                        }
                        else {
                            throw new ExistingInstallationsError(true, requestId, cli_shared_1.Text.deploy.crossContext.enableError);
                        }
                    }
                    break;
                }
                case 'HOSTED_RESOURCE_TOO_MANY_FILES':
                case 'HOSTED_RESOURCE_ZIP_TOO_BIG':
                case 'HOSTED_RESOURCE_FILE_PATH_REFERS_TO_PARENT':
                case 'HOSTED_RESOURCE_INVALID_EGRESS_PERMISSIONS':
                case 'HOSTED_RESOURCE_ICON_RESOURCE_MISSING':
                case 'HOSTED_RESOURCE_INVALID_I18N_RESOURCE': {
                    throw new HostedResourceDeploymentFailedError(true, requestId, cli_shared_1.Text.hostedResources.error(message));
                }
                case 'HOSTED_RESOURCE_FAILED_TO_FETCH':
                case 'HOSTED_RESOURCE_FAILED_TO_COPY':
                case 'HOSTED_RESOURCE_UPLOAD_ID_MISSING': {
                    throw new HostedResourceDeploymentFailedError(false, requestId, cli_shared_1.Text.hostedResources.error(message));
                }
                case 'HOSTED_RESOURCES_LAMBDA_TIMEOUT': {
                    throw new HostedResourceDeploymentFailedError(false, requestId, cli_shared_1.Text.hostedResources.error(cli_shared_1.Text.hostedResources.lambdaTimeout));
                }
                case 'ENTITY_VALIDATION_ERROR':
                case 'MANIFEST_PERMISSIONS_VALIDATION_FAILED':
                case 'MANIFEST_VALIDATION_FAILED': {
                    if (errorDetails.fields) {
                        throw new ManifestValidationFailedError(requestId, cli_shared_1.Text.config.manifest.error(message, JSON.stringify(errorDetails.fields, null, 2)));
                    }
                    throw new ManifestValidationFailedError(requestId, cli_shared_1.Text.config.manifest.error(message));
                }
            }
        }
        throw new AppDeploymentFailedError(false, requestId, cli_shared_1.Text.deploy.taskDeploy.serverStepFailed);
    }
}
exports.ArtifactDeployer = ArtifactDeployer;
//# sourceMappingURL=deployer.js.map