"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageUploadDeployCommand = exports.MissingEnvironmentKeyError = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const lodash_1 = require("lodash");
class MissingEnvironmentKeyError extends cli_shared_1.UserError {
    constructor() {
        super(cli_shared_1.Text.deploy.environmentKey.missingEnvironmentKeyError);
    }
}
exports.MissingEnvironmentKeyError = MissingEnvironmentKeyError;
class PackageUploadDeployCommand {
    packager;
    archiveUploader;
    deployer;
    resourcePackagingService;
    i18nResourceBundlingService;
    constructor(packager, archiveUploader, deployer, resourcePackagingService, i18nResourceBundlingService) {
        this.packager = packager;
        this.archiveUploader = archiveUploader;
        this.deployer = deployer;
        this.resourcePackagingService = resourcePackagingService;
        this.i18nResourceBundlingService = i18nResourceBundlingService;
    }
    async execute(details) {
        let uploadUrl;
        let hostedResourceUploadId;
        let resourcesArchives = {};
        let moduleList = [];
        if (!details.environmentKey) {
            throw new MissingEnvironmentKeyError();
        }
        if (!details.buildTag) {
            ({ uploadUrl, hostedResourceUploadId, resourcesArchives, moduleList } = await this.packageUpload(details));
        }
        await this.deployer.deploy(details.environmentKey, uploadUrl, hostedResourceUploadId, details.majorVersion, details.buildTag);
        return {
            analytics: {
                moduleList,
                hostedResourceList: Object.values(resourcesArchives).map((a) => ({
                    extensionList: a.extensions,
                    fileCount: a.fileCount,
                    rawSize: a.rawSize,
                    zipSize: a.zipSize
                })),
                hasBuildTag: !!details.buildTag
            }
        };
    }
    async packageUpload(details) {
        const [resourcesToBeBundled, preBundledResources] = (0, lodash_1.partition)(details.resources, (res) => res.resourceType === 'nativeUI');
        const i18nResourceBundle = await this.i18nResourceBundlingService.bundle(details.modules, details.i18nConfig);
        const { runtimeArchivePath, nativeUiBundlesDetails, moduleList } = await this.packager.package(details.handlers, resourcesToBeBundled, details.packageConfig, i18nResourceBundle, details.i18nConfig);
        const resourcesArchives = await this.resourcePackagingService.zipResources([...preBundledResources, ...nativeUiBundlesDetails], i18nResourceBundle);
        let uploadUrl;
        let hostedResourceUploadId;
        if (details.buildTag) {
            uploadUrl = await this.archiveUploader.uploadArchive(runtimeArchivePath, details.buildTag);
            hostedResourceUploadId = await this.archiveUploader.uploadHostedResources(resourcesArchives, undefined, details.buildTag);
        }
        else {
            [uploadUrl, hostedResourceUploadId] = await Promise.all([
                this.archiveUploader.uploadArchive(runtimeArchivePath, details.buildTag),
                this.archiveUploader.uploadHostedResources(resourcesArchives, details.environmentKey, details.buildTag)
            ]);
        }
        return {
            uploadUrl,
            hostedResourceUploadId,
            resourcesArchives,
            moduleList
        };
    }
}
exports.PackageUploadDeployCommand = PackageUploadDeployCommand;
//# sourceMappingURL=package-upload-deploy.js.map