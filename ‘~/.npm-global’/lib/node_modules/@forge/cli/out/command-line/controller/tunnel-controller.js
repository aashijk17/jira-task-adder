"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelController = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@forge/cli-shared");
const tunnel_service_1 = require("../../service/tunnel-service");
const docker_compose_1 = require("docker-compose");
const yaml = tslib_1.__importStar(require("yaml"));
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
class TunnelController {
    nodeTunnelService;
    tunnelView;
    configFile;
    cachedConfigService;
    containerCommandService;
    environmentClient;
    constructor(nodeTunnelService, tunnelView, configFile, cachedConfigService, containerCommandService, environmentClient) {
        this.nodeTunnelService = nodeTunnelService;
        this.tunnelView = tunnelView;
        this.configFile = configFile;
        this.cachedConfigService = cachedConfigService;
        this.containerCommandService = containerCommandService;
        this.environmentClient = environmentClient;
    }
    async run(tunnelOptions) {
        const options = await this.validateTunnelCommandOptions(tunnelOptions);
        const envKey = tunnelOptions.environment;
        this.tunnelView.preamble(envKey);
        const { app: { id: appId }, services, modules } = await this.configFile.readConfig();
        const serviceWithTunnelConfigExists = services?.some((service) => service.containers?.some((container) => {
            return !!container.tunnel;
        }));
        if (services && serviceWithTunnelConfigExists) {
            const childProcess = await this.containerCommandService.authenticateDocker();
            await this.processDockerAuthentication(childProcess);
            const dockerComposeFilePaths = await this.generateContainersDockerComposeFile(services, appId, envKey);
            options.containersDockerComposeFiles = dockerComposeFilePaths;
            for (const [serviceKey, filePath] of Object.entries(dockerComposeFilePaths)) {
                await this.startDockerComposeStack(filePath, serviceKey);
            }
        }
        if (modules) {
            const uiKit1Modules = (0, cli_shared_1.findUIKit1Modules)(modules);
            if (uiKit1Modules.length > 0) {
                this.tunnelView.displayUIKit1DeprecationMessage(uiKit1Modules);
            }
        }
        return await this.nodeTunnelService.run(options);
    }
    async startDockerComposeStack(dockerComposeFilePath, serviceKey) {
        try {
            await (0, docker_compose_1.pullOne)('proxy-sidecar', {
                cwd: path.dirname(dockerComposeFilePath),
                log: true,
                config: dockerComposeFilePath
            });
        }
        catch (err) {
            throw new tunnel_service_1.DockerUnableToPullProxySidecarImage(err);
        }
        try {
            await (0, docker_compose_1.upAll)({
                cwd: path.dirname(dockerComposeFilePath),
                log: true,
                config: dockerComposeFilePath,
                composeOptions: [`-p${serviceKey}`]
            });
        }
        catch (err) {
            throw new tunnel_service_1.DockerUnableToStartError(err);
        }
    }
    async processDockerAuthentication(childProcess) {
        await new Promise((resolve, reject) => {
            childProcess.on('close', (code) => {
                if (code === 0) {
                    resolve();
                }
                else {
                    reject(new tunnel_service_1.DockerAuthenticationError(code?.toString() || 'unknown'));
                }
            });
            childProcess.on('error', reject);
        });
    }
    async validateTunnelCommandOptions(tunnelOptions) {
        const assistantName = this.cachedConfigService.getAssistantName();
        const options = {
            ...tunnelOptions,
            debugStartingPort: cli_shared_1.defaultDebugStartingPort,
            assistantName
        };
        if (tunnelOptions.debug) {
            if (!tunnelOptions.debugFunctionHandlers?.length) {
                throw new tunnel_service_1.FunctionHandlersMustBeDefinedInDebugMode();
            }
            const manifestHandlers = await this.configFile.getAppHandlers();
            for (const functionHandler of tunnelOptions.debugFunctionHandlers) {
                if (!manifestHandlers.some((handler) => functionHandler === `${handler.module}.${handler.func}`)) {
                    throw new tunnel_service_1.DebugArgumentNameMismatch(functionHandler);
                }
            }
            const port = parseInt(tunnelOptions.debugStartingPort);
            if (isNaN(port) || port < 0 || port > 65535) {
                throw new tunnel_service_1.InvalidDebugStartingPortNumber(tunnelOptions.debugStartingPort);
            }
            options.debugStartingPort = port;
        }
        return options;
    }
    async generateContainersDockerComposeFile(services, appId, envKey) {
        const filesGenerated = {};
        for (const service of services) {
            const { key: serviceKey, containers } = service;
            const containersWithTunnelConfig = containers.filter((container) => !!container.tunnel);
            if (containersWithTunnelConfig.length > 0) {
                const port = await (0, cli_shared_1.getServicePort)(services, serviceKey);
                if (!port || port < 1024 || port > 49152) {
                    throw new tunnel_service_1.InvalidContainerServicePort(serviceKey);
                }
                const containerConfig = Object.fromEntries(containersWithTunnelConfig.map((container) => {
                    const config = {
                        container_name: container.key,
                        ...container.tunnel?.docker
                    };
                    const envArray = container?.tunnel?.docker.environment ?? [];
                    const filteredEnvArray = envArray.filter((envVar) => !envVar.startsWith('FORGE_EGRESS_PROXY_URL='));
                    filteredEnvArray.push('FORGE_EGRESS_PROXY_URL=http://proxy-sidecar:7072');
                    config.environment = filteredEnvArray;
                    return [container.key, config];
                }));
                const dockerComposeConfig = {
                    services: {
                        ...containerConfig,
                        ...(await this.getProxySidecarConfig(serviceKey, Object.keys(containerConfig), port, appId, envKey))
                    }
                };
                const yamlString = yaml.stringify(dockerComposeConfig);
                const filePath = this.getContainerDockerComposePath(serviceKey);
                fs.writeFileSync(filePath, yamlString);
                filesGenerated[serviceKey] = filePath;
            }
        }
        return filesGenerated;
    }
    getContainerDockerComposePath(serviceKey) {
        const hiddenDir = path.join(process.cwd(), '.services');
        if (!fs.existsSync(hiddenDir)) {
            fs.mkdirSync(hiddenDir, { recursive: true });
        }
        return path.join(hiddenDir, `docker-compose-${serviceKey}.yml`);
    }
    async getProxySidecarConfig(serviceKey, containerKeys, port, appId, envKey = cli_shared_1.DEFAULT_ENVIRONMENT_OPTION) {
        let fopBaseUrl = 'https://forge-outbound-proxy.services.atlassian.com';
        let jwksUrl = 'https://forge.cdn.prod.atlassian-dev.net/.well-known/jwks.json';
        let proxySidecarImage = 'forge-ecr.services.atlassian.com/forge-platform/proxy-sidecar:latest';
        if (process.env.FORGE_GRAPHQL_GATEWAY?.startsWith('https://api-private.stg.atlassian.com/graphql')) {
            fopBaseUrl = 'https://forge-outbound-proxy.stg.services.atlassian.com';
            jwksUrl = 'https://forge.cdn.stg.atlassian-dev.net/.well-known/jwks.json';
            proxySidecarImage = 'forge-ecr.stg.services.atlassian.com/forge-platform/proxy-sidecar:latest';
        }
        const appEnvironments = await this.environmentClient.listEnvironment({ appId });
        const environmentDetails = appEnvironments.filter((environment) => environment.key === envKey);
        if (environmentDetails.length < 1) {
            throw new tunnel_service_1.EnvironmentIsNotDefined(envKey);
        }
        let appIdShort = appId;
        if (appId.startsWith('ari:cloud:ecosystem::app/')) {
            appIdShort = appId.split('/')[1];
        }
        return {
            'proxy-sidecar': {
                image: proxySidecarImage,
                container_name: `proxy-sidecar-${serviceKey}`,
                environment: [
                    `SERVICE_URL=http://${containerKeys[0]}:8080`,
                    `FOP_BASE_URL=${fopBaseUrl}`,
                    `APP_ID=ari:cloud:ecosystem::app/${appIdShort}`,
                    `ENV_ID=ari:cloud:ecosystem::environment/${appIdShort}/${environmentDetails[0].id}`,
                    `JWKS_URL=${jwksUrl}`,
                    `IS_LOCAL_DEV=true`
                ],
                ports: [`${port}:${cli_shared_1.DEFAULT_PROXY_INGRESS_PORT}`],
                depends_on: containerKeys
            }
        };
    }
}
exports.TunnelController = TunnelController;
//# sourceMappingURL=tunnel-controller.js.map