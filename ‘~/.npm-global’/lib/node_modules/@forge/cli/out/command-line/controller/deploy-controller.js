"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployController = exports.InvalidConnectKeyError = exports.DeployLintFailureError = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const errors_1 = require("../errors");
class DeployLintFailureError extends cli_shared_1.HiddenError {
    scopes;
    constructor(scopes) {
        super();
        this.scopes = scopes;
    }
    getAttributes() {
        return {
            ...super.getAttributes(),
            scopes: this.scopes
        };
    }
    isUserError() {
        return true;
    }
}
exports.DeployLintFailureError = DeployLintFailureError;
class InvalidConnectKeyError extends cli_shared_1.HiddenError {
    reason;
    constructor(reason) {
        super();
        this.reason = reason;
    }
    getAttributes() {
        return {
            ...super.getAttributes(),
            reason: this.reason
        };
    }
    isUserError() {
        return true;
    }
}
exports.InvalidConnectKeyError = InvalidConnectKeyError;
class DeployController {
    appConfigProvider;
    configFile;
    lintService;
    installationsService;
    roaService;
    migrationKeysService;
    customEntitiesService;
    appEnvironmentClient;
    deployView;
    nodePackageUploadDeployCommand;
    createEnvironmentCommand;
    constructor(appConfigProvider, configFile, lintService, installationsService, roaService, migrationKeysService, customEntitiesService, appEnvironmentClient, deployView, nodePackageUploadDeployCommand, createEnvironmentCommand) {
        this.appConfigProvider = appConfigProvider;
        this.configFile = configFile;
        this.lintService = lintService;
        this.installationsService = installationsService;
        this.roaService = roaService;
        this.migrationKeysService = migrationKeysService;
        this.customEntitiesService = customEntitiesService;
        this.appEnvironmentClient = appEnvironmentClient;
        this.deployView = deployView;
        this.nodePackageUploadDeployCommand = nodePackageUploadDeployCommand;
        this.createEnvironmentCommand = createEnvironmentCommand;
    }
    isMpacProductionApp(mpacAppKey, environment) {
        return !!(mpacAppKey && environment === 'production');
    }
    connectKeyDeleted(connectKey, comparisonKey) {
        return !!(!connectKey && comparisonKey);
    }
    connectKeyChanged(connectKey, comparisonKey) {
        return !!(comparisonKey && connectKey && connectKey !== comparisonKey);
    }
    connectKeyMutatedInProduction(connectKey, comparisonKey, environment, isSkeletonVersion) {
        if (isSkeletonVersion || environment !== 'production') {
            return false;
        }
        return !!(connectKey !== comparisonKey);
    }
    async validateConnectKeyChange(environment, keys) {
        const { migrationKeys, mpacAppKey, isSkeletonVersion } = keys;
        const connectKey = await this.configFile.getConnectKey();
        const migrationKey = migrationKeys?.confluence || migrationKeys?.jira;
        const isMpacApp = this.isMpacProductionApp(mpacAppKey, environment);
        if (!isMpacApp && this.connectKeyMutatedInProduction(connectKey, migrationKey, environment, !!isSkeletonVersion)) {
            this.deployView.displayConnectKeyMutationInProductionError(migrationKey, connectKey);
            throw new InvalidConnectKeyError(cli_shared_1.Text.deploy.connectKeyChange.mpacAppConnectKeyChangeAnalyticsError);
        }
        else if (this.connectKeyDeleted(connectKey, migrationKey)) {
            this.deployView.displayConnectKeyDeleteWarning(environment);
            const proceed = await this.deployView.promptToContinueDeletingConnectKey();
            return { proceed, connectKeyDeleted: proceed, connectKeyChanged: false };
        }
        else if (isMpacApp && this.connectKeyChanged(connectKey, mpacAppKey)) {
            this.deployView.displayMPACAppConnectKeyChangeError(mpacAppKey, connectKey);
            throw new InvalidConnectKeyError(cli_shared_1.Text.deploy.connectKeyChange.mpacAppConnectKeyChangeAnalyticsError);
        }
        else if (!isMpacApp && this.connectKeyChanged(connectKey, migrationKey)) {
            this.deployView.displayConnectKeyChangeWarning(environment, migrationKey, connectKey);
            const proceed = await this.deployView.promptToContinueChangingConnectKey();
            return { proceed, connectKeyChanged: proceed, connectKeyDeleted: false };
        }
        return { proceed: true, connectKeyChanged: false, connectKeyDeleted: false };
    }
    async verifyPreDeployment(environment) {
        this.deployView.displayLintRunning();
        const { lintResults } = await this.lintService.run(environment, { fix: false }, this.deployView.getLogger());
        const problemCount = this.lintService.problemCount(lintResults);
        if (problemCount.errors) {
            this.deployView.displayLintErrors(lintResults);
            const failures = this.lintService.failedScopes(lintResults);
            throw new DeployLintFailureError(failures);
        }
        else if (problemCount.warnings) {
            this.deployView.displayLintWarnings(problemCount.warnings);
        }
        else {
            this.deployView.displayNoLintProblems();
        }
        const manifest = await this.configFile.readConfig();
        if (manifest?.app?.storage?.entities) {
            if (await this.customEntitiesService.isReindexingInProgress(environment)) {
                if (!(await this.deployView.promptToContinueDeploymentWhileReindexing())) {
                    throw new errors_1.UserAbortError();
                }
            }
        }
        if (manifest?.modules) {
            const uiKit1Modules = (0, cli_shared_1.findUIKit1Modules)(manifest.modules);
            if (uiKit1Modules.length > 0) {
                this.deployView.displayUIKit1DeprecationMessage(uiKit1Modules);
            }
        }
    }
    async verifyPostDeployment(environmentKey, environmentType, majorVersion) {
        const needsVersionUpdate = await this.installationsService.hasOutdatedProductInstallation(environmentKey);
        if (needsVersionUpdate) {
            this.deployView.displayOutdatedInstallationsMessage();
        }
        const roaEligibility = await this.roaService.getEligibilityStatus(environmentKey, majorVersion);
        if (!roaEligibility.isEligible) {
            this.deployView.displayRoaEligibilityFailureMessage(roaEligibility.appVersion, environmentKey, environmentType);
        }
        else {
            this.deployView.displayRoaEligibilitySuccessMessage(roaEligibility.appVersion, environmentKey, environmentType);
        }
        const manifest = await this.configFile.readConfig();
        if (manifest?.app?.storage?.entities) {
            if (await this.customEntitiesService.isReindexingInProgress(environmentKey)) {
                this.deployView.displaySuccessfulDeploymentWhileReindexing();
            }
            this.deployView.displayIndexingCommand(environmentKey);
        }
    }
    async confirmAndCreateEnvironment(environment, nonInteractive) {
        if (!nonInteractive) {
            this.deployView.displayEnvironmentCreationWarning(environment);
            const confirm = await this.deployView.promptToCreateEnvironment();
            if (!confirm) {
                throw new errors_1.UserAbortError();
            }
        }
        await this.createEnvironmentCommand.execute({ environmentKey: environment });
        this.deployView.displayEnvironmentCreationSuccessMessage(environment);
    }
    async getAppEnvironmentDetails(id, environment, nonInteractive) {
        try {
            return await this.appEnvironmentClient.getAppEnvironmentDetails(id, environment);
        }
        catch (e) {
            if (!(e instanceof cli_shared_1.MissingAppEnvironmentError)) {
                throw e;
            }
            await this.confirmAndCreateEnvironment(environment, nonInteractive);
            return this.appEnvironmentClient.getAppEnvironmentDetails(id, environment);
        }
    }
    async run({ environment, verify, nonInteractive, majorVersion, buildTag }) {
        const { id } = await this.appConfigProvider();
        const appDetails = await this.getAppEnvironmentDetails(id, environment, nonInteractive);
        appDetails.buildTag = buildTag;
        this.deployView.displayStart(environment, appDetails.environmentType, buildTag);
        let hasConnectKeyChanged = false;
        let hasConnectKeyDeleted = false;
        if (verify && !buildTag) {
            await this.verifyPreDeployment(environment);
            const keys = await this.migrationKeysService.getMigrationKeysForAppEnvironment(environment);
            const { proceed, connectKeyChanged, connectKeyDeleted } = await this.validateConnectKeyChange(environment, keys);
            if (!proceed) {
                return;
            }
            hasConnectKeyChanged = connectKeyChanged;
            hasConnectKeyDeleted = connectKeyDeleted;
            if (majorVersion) {
                this.deployView.displayDeployPreviousMajorVersionWarning(majorVersion);
                if (!nonInteractive) {
                    if (!(await this.deployView.promptToDeployPreviousMajorVersion())) {
                        return;
                    }
                }
            }
        }
        const handlers = await this.configFile.getAppHandlers();
        const resources = await this.configFile.getResources();
        let hasNoInstallationsForEnv = true;
        try {
            hasNoInstallationsForEnv = await this.installationsService.hasNoAppInstallationsForEnv(appDetails.environmentType);
        }
        catch (err) {
            this.deployView.displayHasNoAppInstallationsForEnvError();
            if (verify) {
                throw err;
            }
        }
        const config = await this.configFile.readConfig();
        const packageConfig = config.app?.package;
        const analytics = await this.deployView.reportDeploymentProgress(appDetails, hasNoInstallationsForEnv, () => this.nodePackageUploadDeployCommand.execute({
            handlers,
            resources,
            environmentKey: environment,
            packageConfig,
            majorVersion,
            modules: config.modules,
            i18nConfig: config.translations,
            buildTag
        }));
        if (verify) {
            await this.verifyPostDeployment(environment, appDetails.environmentType, majorVersion);
        }
        try {
            analytics.analytics.egressPermissionList = await this.configFile.getEgressPermissions();
            analytics.analytics.connectKey = hasConnectKeyChanged
                ? { action: 'changed', value: await this.configFile.getConnectKey() }
                : hasConnectKeyDeleted
                    ? { action: 'deleted' }
                    : {};
        }
        catch (e) {
        }
        return analytics;
    }
}
exports.DeployController = DeployController;
//# sourceMappingURL=deploy-controller.js.map