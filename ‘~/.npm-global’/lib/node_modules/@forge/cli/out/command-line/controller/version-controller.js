"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionController = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const diff = tslib_1.__importStar(require("diff"));
const cli_shared_1 = require("@forge/cli-shared");
const defaultProperties = ['appVersion', 'deploymentDateTime', 'environmentType'];
function filterObjectProperties(source, filteredProperties, defaultProperties) {
    const result = {};
    for (const prop of [...filteredProperties, ...defaultProperties]) {
        result[prop] = source[prop];
    }
    return result;
}
class VersionController {
    versionService;
    view;
    constructor(versionService, view) {
        this.versionService = versionService;
        this.view = view;
    }
    async getAppVersionDiff({ environment, version1, version2, outFile, environment1, environment2 }) {
        const [version1Details, version2Details] = await this.view.displayDiffProgress(() => Promise.all([
            this.versionService.getAppVersionDetails(environment1 ?? environment, version1),
            this.versionService.getAppVersionDetails(environment2 ?? environment, version2)
        ]));
        if (outFile) {
            this.writeDiffToFile(version1Details, version2Details, outFile);
        }
        else {
            this.displayDiffInText(version1Details, version2Details, environment1 ?? environment, environment2 ?? environment);
        }
    }
    async getAppVersionDetails({ environment, majorVersion, json = false, outFile, nonInteractive }) {
        let filteredProperties = [];
        if (!nonInteractive) {
            filteredProperties = await this.view.promptVersionDetailsProperties();
        }
        const request = this.versionService.getAppVersionDetails(environment, majorVersion);
        const versionDetails = nonInteractive ? await request : await this.view.displayDetailsProgress(() => request);
        if (filteredProperties.length === 0) {
            filteredProperties = Object.keys(versionDetails);
        }
        const filteredVersionDetails = filterObjectProperties(versionDetails, filteredProperties, defaultProperties);
        if (outFile) {
            this.writeToFile(filteredVersionDetails, outFile);
        }
        else if (json) {
            this.displayInJson(filteredVersionDetails);
        }
        else {
            this.displayDetailsInTable(filteredVersionDetails, environment);
        }
    }
    writeToFile(data, outFile) {
        this.view.displayWriteToFile(outFile);
        (0, fs_1.writeFileSync)(outFile, JSON.stringify(data, null, 2));
    }
    displayInJson(data) {
        this.view.displayDataInJson(data);
    }
    displayDetailsInTable(details, environment) {
        this.view.displayVersionDetailsBanner(details.appVersion, environment, details.environmentType);
        this.view.displayDetailsAsTable(details);
    }
    displayDiffInText(version1, version2, environment1, environment2) {
        this.view.displayDiffBanner(version1.appVersion, version2.appVersion, environment1, version1.environmentType, environment2 == environment1 ? undefined : environment2, environment2 == environment1 ? undefined : version2.environmentType);
        this.view.displayDiffAsTable({ v1: version1.appVersion, e1: version1.environment, v2: version2.appVersion, e2: version2.environment }, [
            {
                key: 'scopes',
                diff: diff.diffJson(version1.scopes, version2.scopes)
            },
            {
                key: 'deployment date',
                diff: diff.diffJson(version1.deploymentDateTime, version2.deploymentDateTime)
            },
            {
                key: 'egress',
                diff: diff.diffJson(version1.egresses, version2.egresses)
            },
            {
                key: 'analytics',
                diff: diff.diffJson(version1.analytics, version2.analytics)
            },
            { key: 'policies', diff: diff.diffJson(version1.policies, version2.policies) },
            { key: 'connect keys', diff: diff.diffJson(version1.connectKeys, version2.connectKeys) },
            {
                key: 'functions',
                diff: diff.diffJson(version1.functions, version2.functions)
            },
            { key: 'modules', diff: diff.diffJson(version1.modules, version2.modules) },
            { key: 'remotes', diff: diff.diffJson(version1.remotes, version2.remotes) },
            { key: 'license', diff: diff.diffJson('' + version1.requiresLicense, '' + version2.requiresLicense) }
        ]);
    }
    writeDiffToFile(version1, version2, outFile) {
        this.view.displayWriteToFile(outFile);
        const patch = diff.createTwoFilesPatch(`${version1.appVersion}`, `${version2.appVersion}`, JSON.stringify(version1, null, 2), JSON.stringify(version2, null, 2));
        (0, fs_1.writeFileSync)(outFile, patch);
    }
    async getVersionList({ environment, json, outFile, nonInteractive }) {
        const request = this.versionService.getAppVersionOverviewList(environment);
        const versionList = nonInteractive || json ? await request : await this.view.displayListProgress(() => request);
        if (!nonInteractive && !json) {
            this.view.displayListBanner(versionList.length, environment, versionList[0].environmentType);
        }
        if (outFile) {
            this.writeToFile(versionList, outFile);
        }
        else if (json) {
            this.displayInJson(versionList);
        }
        else {
            this.view.displayVersionList(versionList);
        }
    }
    async createVersionUpgrade({ environment, json, outFile, nonInteractive, fromMajorVersion, toMajorVersion }) {
        let appVersionUpgradeRolloutId;
        if (nonInteractive) {
            appVersionUpgradeRolloutId = await this.versionService.createAppVersionUpgradeRolloutNonInteractively(environment, fromMajorVersion, toMajorVersion);
        }
        else {
            const sourceVersions = await this.versionService.getAppUpgradeVersionsList(environment);
            const selectedSourceVersion = await this.getSelectedVersion(['Major version', 'Deployment date', 'Installations'], sourceVersions.map(({ version, deploymentDateTime, installations, id }) => ({
                names: [version, deploymentDateTime, installations],
                value: id,
                primary: version
            })), sourceVersions, cli_shared_1.Text.version.upgrade.start.promptVersionTable, cli_shared_1.Text.version.upgrade.start.overViewVersionTable(sourceVersions.length, environment));
            const upgradableToVersions = await this.versionService.getUpgradableVersions(environment, selectedSourceVersion.id);
            if (upgradableToVersions.length == 0) {
                this.view.displayInfo(cli_shared_1.Text.version.upgrade.start.error.noTargetVersionAvailable);
                return;
            }
            const selectedTargetVersion = await this.getSelectedVersion(['Major version', 'Deployment date'], upgradableToVersions.map(({ version, deploymentDateTime, id }) => ({
                names: [version, deploymentDateTime],
                value: id,
                primary: version
            })), upgradableToVersions, cli_shared_1.Text.version.upgrade.start.selectTargetVersionToUpgrade(selectedSourceVersion.installations));
            const confirmCreate = await this.view.confirmAppVersionRolloutCreation(selectedSourceVersion.version, selectedTargetVersion.version, selectedSourceVersion.installations);
            if (confirmCreate) {
                appVersionUpgradeRolloutId = await this.versionService.createAppVersionUpgradeRollout(environment, selectedSourceVersion.id, selectedTargetVersion.id, selectedSourceVersion.version, selectedTargetVersion.version);
            }
            else {
                return;
            }
        }
        if (outFile) {
            this.writeToFile(cli_shared_1.Text.version.upgrade.start.appVersionRolloutSuccess(appVersionUpgradeRolloutId), outFile);
        }
        else if (json) {
            this.displayInJson(cli_shared_1.Text.version.upgrade.start.appVersionRolloutSuccess(appVersionUpgradeRolloutId));
        }
        else {
            this.view.displayAppVersionRolloutCreationSuccess(appVersionUpgradeRolloutId);
        }
    }
    async listVersionUpgrades({ environment, json, outFile, nonInteractive }) {
        const request = this.versionService.getAppVersionUpgradeRolloutsList(environment);
        const versionUpgradeList = nonInteractive || json ? await request : await this.view.displayBulkUpgradeListProgress(() => request);
        if (!nonInteractive && !json) {
            this.view.displayBulkUpgradeListBanner(versionUpgradeList.length, environment, versionUpgradeList[0] ? versionUpgradeList[0].environmentType : undefined);
        }
        if (outFile) {
            this.writeToFile(versionUpgradeList, outFile);
        }
        else if (json) {
            this.displayInJson(versionUpgradeList);
        }
        else {
            this.view.displayBulkUpgradeList(versionUpgradeList);
        }
    }
    async cancelRolloutVersionUpgrade({ environment, json, outFile, appUpgradeId, nonInteractive }) {
        const appVersionRollout = await this.versionService.getAppVersionRollout(appUpgradeId);
        if (!appVersionRollout || appVersionRollout.status !== cli_shared_1.AppVersionRolloutStatus.Running) {
            this.view.displayAppVersionRolloutCancelNotInProgress(environment);
            return;
        }
        let confirmCancel = false;
        if (!nonInteractive) {
            confirmCancel = await this.view.confirmAppVersionRolloutCancel(appUpgradeId, appVersionRollout.sourceVersionId, appVersionRollout.targetVersionId, appVersionRollout.completedUpgradeCount, appVersionRollout.completedUpgradeCount +
                appVersionRollout.failedUpgradeCount +
                appVersionRollout.pendingUpgradeCount);
        }
        if (nonInteractive || confirmCancel) {
            const result = await this.versionService.cancelAppVersionRollout(appUpgradeId, environment);
            if (result) {
                if (outFile) {
                    this.writeToFile(cli_shared_1.Text.version.upgrade.cancel.appVersionRolloutCancelSuccess(appUpgradeId), outFile);
                }
                else if (json) {
                    this.displayInJson(cli_shared_1.Text.version.upgrade.cancel.appVersionRolloutCancelSuccess(appUpgradeId));
                }
                else {
                    this.view.displayAppVersionRolloutCancelCreationSuccess(appUpgradeId);
                }
            }
        }
    }
    async getSelectedVersion(columns, tableData, versions, versionTablePrompt, versionTableOverview) {
        const index = await this.view.displaySingleSelectVersion(columns, tableData, versionTablePrompt, versionTableOverview);
        return versions[index];
    }
}
exports.VersionController = VersionController;
//# sourceMappingURL=version-controller.js.map