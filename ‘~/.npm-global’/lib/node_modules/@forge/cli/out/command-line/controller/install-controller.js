"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstallController = exports.NoDeploymentError = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const manifest_1 = require("@forge/manifest");
const register_version_commands_1 = require("../register-version-commands");
class NoDeploymentError extends Error {
    constructor(environment) {
        super(cli_shared_1.Text.install.error.noDeploymentFound(environment));
    }
}
exports.NoDeploymentError = NoDeploymentError;
class InstallController {
    appConfigProvider;
    configFile;
    ui;
    installAppSiteCommand;
    installationService;
    installView;
    supportedProductsService;
    statsigService;
    constructor(appConfigProvider, configFile, ui, installAppSiteCommand, installationService, installView, supportedProductsService, statsigService) {
        this.appConfigProvider = appConfigProvider;
        this.configFile = configFile;
        this.ui = ui;
        this.installAppSiteCommand = installAppSiteCommand;
        this.installationService = installationService;
        this.installView = installView;
        this.supportedProductsService = supportedProductsService;
        this.statsigService = statsigService;
    }
    async securityPrompt(site) {
        this.ui.info(cli_shared_1.Text.install.security.banner(site.host));
        let isTrustedApp = true;
        for (const question of cli_shared_1.Text.install.security.questions) {
            if (await this.ui.confirm(question)) {
                isTrustedApp = false;
            }
        }
        if (!isTrustedApp) {
            this.ui.info(cli_shared_1.Text.install.security.notTrustedApp.warn(site.host));
            if (!(await this.ui.confirm(cli_shared_1.Text.install.security.notTrustedApp.confirmApproval))) {
                this.ui.info(cli_shared_1.Text.install.security.notTrustedApp.corpSecurityHelpdesk);
                return;
            }
        }
    }
    async installOrUpgrade(upgrade, environment, environmentType, site, product, appId, text, license, overrides, majorVersionId) {
        const isWorkspaceProduct = !!product && this.supportedProductsService.isWorkspaceProduct(product);
        return this.ui.displayProgress(async () => {
            if (upgrade) {
                const isAlreadyUpdated = await this.installationService.upgradeInstallation(site, product, environment, appId);
                return isAlreadyUpdated;
            }
            else {
                await this.installAppSiteCommand.execute({
                    environmentKey: environment,
                    site,
                    product,
                    licenseOverride: license,
                    overrides,
                    majorVersionId,
                    environmentType
                });
                return false;
            }
        }, text.cmd.start(environment, environmentType, (0, cli_shared_1.productDisplayName)(product)), (alreadyUpdated) => {
            if (alreadyUpdated) {
                return isWorkspaceProduct
                    ? cli_shared_1.Text.upgrade.alreadyUpdated.spinnerWorkspace
                    : cli_shared_1.Text.upgrade.alreadyUpdated.spinnerSite;
            }
            else {
                return text.cmd.end(false, product);
            }
        });
    }
    async promptForProducts(requiredProducts) {
        if (requiredProducts?.length) {
            const supportedProducts = this.supportedProductsService.getSupportedSecondaryProductsForXPA(requiredProducts) ?? [];
            const choices = supportedProducts.map((product) => ({ names: [product] }));
            const selected = await this.ui.promptForTable(cli_shared_1.Text.installationContext.promptOptionalProducts, '', [], choices, true);
            return selected.map((index) => supportedProducts[index]);
        }
        this.ui.info(cli_shared_1.Text.installationContext.overviewProduct);
        return [
            await this.ui.promptForList(cli_shared_1.Text.installationContext.promptProduct, this.supportedProductsService.getSupportedProducts())
        ];
    }
    async promptForSite(products) {
        const isWorkspaceBased = products.length > 0 && this.supportedProductsService.isWorkspaceProduct((0, cli_shared_1.productDisplayName)(products[0]));
        const overviewText = isWorkspaceBased
            ? cli_shared_1.Text.installationContext.overviewWorkspace
            : cli_shared_1.Text.installationContext.overviewSite;
        this.ui.info(overviewText);
        const promptText = isWorkspaceBased
            ? cli_shared_1.Text.installationContext.promptWorkspace
            : cli_shared_1.Text.installationContext.promptSite;
        const trySite = await this.ui.promptForText(promptText);
        const invalidText = isWorkspaceBased ? cli_shared_1.Text.error.invalidWorkspace : cli_shared_1.Text.error.invalidSite;
        if (!trySite) {
            throw new cli_shared_1.ValidationError(invalidText);
        }
        return this.supportedProductsService.validateSite(trySite, products[0] && (0, cli_shared_1.productDisplayName)(products[0]));
    }
    async getAppInstallations(siteOption, productOption, environmentOption) {
        const { installations } = await this.installationService.listNonTechnicalAppInstallations({
            site: siteOption,
            product: productOption,
            environment: environmentOption
        });
        return installations;
    }
    async getInstallationToUpgrade(siteOption, productOption, environmentOption) {
        const matchingInstallations = await this.getAppInstallations(siteOption, productOption, environmentOption);
        let selectedInstallationToUpgrade;
        if (siteOption && productOption?.length) {
            if (!matchingInstallations.length) {
                throw new cli_shared_1.ValidationError(cli_shared_1.Text.error.invalidInstallationContext);
            }
            selectedInstallationToUpgrade = matchingInstallations[0];
        }
        else {
            selectedInstallationToUpgrade = await this.installView.promptForUpgrade(matchingInstallations);
        }
        const { site, product, environmentKey, environmentType, version } = selectedInstallationToUpgrade;
        const productName = (0, cli_shared_1.productDisplayName)(product);
        return {
            site: this.supportedProductsService.validateSite(site, productName),
            product: this.supportedProductsService.validateSupportedProduct(productName),
            environment: environmentKey,
            environmentType,
            scopes: version.scopes
        };
    }
    getUniqueInstallationProductsFromScopes(scopes) {
        if (!scopes || scopes.length === 0)
            return undefined;
        const products = new Set();
        scopes.forEach((scope) => {
            if (scope.search('jira') !== -1) {
                products.add('jira');
            }
            else if (scope.search('confluence') !== -1) {
                products.add('confluence');
            }
        });
        return products.size > 0 ? Array.from(products) : undefined;
    }
    isValidLicense(value) {
        return Object.values(cli_shared_1.LicenseOverrideState).includes(value);
    }
    validateLicenseOption(license, environment) {
        if (license === undefined)
            return undefined;
        if (typeof license !== 'string') {
            throw new cli_shared_1.ValidationError(cli_shared_1.Text.error.licenseOverrideErrors.empty);
        }
        const upperCaseLicense = license.toUpperCase();
        if (!this.isValidLicense(upperCaseLicense)) {
            throw new cli_shared_1.ValidationError(cli_shared_1.Text.error.licenseOverrideErrors.invalid);
        }
        if (environment === cli_shared_1.PRODUCTION_ENVIRONMENT_KEY) {
            throw new cli_shared_1.UserError(cli_shared_1.Text.error.licenseOverrideErrors.prodSupport);
        }
        return upperCaseLicense;
    }
    checkForUIKit1Modules = (modules) => {
        if (!modules)
            return;
        const uiKit1Modules = (0, cli_shared_1.findUIKit1Modules)(modules);
        if (uiKit1Modules.length > 0) {
            this.installView.displayUIKit1DeprecationMessage(uiKit1Modules);
        }
    };
    async getVersionPermissionsByMajorVersion(id, environmentKey, majorVersion) {
        const majorVersionInt = (0, register_version_commands_1.parseMajorVersion)(majorVersion);
        const result = await this.installationService.getVersionByMajorVersionId(id, environmentKey, majorVersionInt);
        if (!result) {
            throw new cli_shared_1.UserError(cli_shared_1.Text.install.error.majorVersionNotFound);
        }
        return result;
    }
    async run({ environment, site, products, upgrade, confirmScopes, license, licenseModes, usersWithAccess, nonInteractive, majorVersion }) {
        const { id } = await this.appConfigProvider();
        const text = upgrade ? cli_shared_1.Text.upgrade : cli_shared_1.Text.install;
        const validLicense = this.validateLicenseOption(license, environment);
        const overrides = await this.validateEcosystemAppInstallationOverridesInput(licenseModes, usersWithAccess, environment);
        let environmentPermissions;
        let requiredProducts;
        if (majorVersion) {
            if (upgrade) {
                throw new cli_shared_1.UserError(cli_shared_1.Text.install.error.majorVersionAndUpgrade);
            }
            const majorVersionResult = await this.getVersionPermissionsByMajorVersion(id, environment, majorVersion);
            if (!majorVersionResult.isLatest && majorVersionResult.version) {
                this.ui.warn(cli_shared_1.Text.install.majorVersionIsNotLatest(majorVersionResult.version));
                if (!nonInteractive && !(await this.ui.confirm(cli_shared_1.Text.install.devAppInstallConfirm)))
                    return;
            }
            environmentPermissions = majorVersionResult;
            requiredProducts = majorVersionResult.requiredProducts;
        }
        else {
            environmentPermissions = await this.installationService.getAppEnvironmentPermissions(id, environment);
            requiredProducts = environmentPermissions?.requiredProducts;
        }
        let scopesFromLastInstallation = new Set();
        if (upgrade) {
            const upgradeResult = await this.getInstallationToUpgrade(site, products?.[0], environment);
            environment = upgradeResult.environment;
            site = upgradeResult.site;
            products = [upgradeResult.product];
            scopesFromLastInstallation = new Set(upgradeResult.scopes);
            this.ui.info(this.supportedProductsService.isWorkspaceProduct(products[0]) ? text.bannerWorkspace : text.bannerSite);
        }
        else if (!requiredProducts?.length) {
            products = products?.length ? products : await this.promptForProducts();
            site = site ? site : await this.promptForSite(products);
            this.ui.info(this.supportedProductsService.isWorkspaceProduct(products[0]) ? text.bannerWorkspace : text.bannerSite);
        }
        else {
            const result = await this.getXPAProductsAndSite(requiredProducts.map(cli_shared_1.productDisplayName), products, site, environment);
            site = result.site;
            products = result.products;
            this.ui.info(cli_shared_1.Text.install.installConfirmation(products.join(', '), site.host));
        }
        if ((0, cli_shared_1.isSecureSite)(site)) {
            await this.securityPrompt(site);
        }
        if (!environmentPermissions?.hasDeployments) {
            this.ui.error(new NoDeploymentError(environment), { pad: false });
            return;
        }
        const { scopes: environmentScopes, environmentType } = environmentPermissions;
        const [{ permissions, modules }, manifestEgressEntries] = await Promise.all([
            this.configFile.readConfig(),
            this.configFile.getEgressPermissions()
        ]);
        this.checkForUIKit1Modules(modules);
        const { manifestEgressAddresses, manifestScopes } = this.extractManifestData(manifestEgressEntries, permissions);
        const differenceInScopes = environmentScopes.filter((x) => !scopesFromLastInstallation.has(x));
        const listScopes = await this.convertListScope(differenceInScopes);
        const scopesConfirmationResult = await this.installView.promptForPermissionsConfirmation(environmentPermissions, listScopes, [...manifestScopes], manifestEgressAddresses, environment, confirmScopes, !!nonInteractive, text, !!majorVersion);
        if (!scopesConfirmationResult)
            return;
        const successfulProducts = [];
        const failedProducts = [];
        if (await this.isNonProductionAppInstallationAttempt(site, products, environmentType)) {
            this.ui.warn(cli_shared_1.Text.install.devAppInstallWarning);
            if (!nonInteractive && !(await this.ui.confirm(cli_shared_1.Text.install.devAppInstallConfirm)))
                return;
        }
        for (const product of products) {
            try {
                const isAlreadyUpdated = await this.installOrUpgrade(upgrade, environment, environmentType, site, product, id, text, validLicense, overrides, environmentPermissions?.versionId);
                if (isAlreadyUpdated) {
                    this.ui.info(cli_shared_1.Text.upgrade.alreadyUpdated.banner(environment, (0, cli_shared_1.productDisplayName)(product), site.host));
                }
                else {
                    this.ui.clearSpinner();
                    this.ui.emptyLine();
                    successfulProducts.push(product);
                }
            }
            catch (error) {
                this.ui.clearSpinner();
                this.ui.error(error);
                failedProducts.push(product);
            }
            await this.checkForMultiProductScopes(environmentScopes, site, environment);
        }
        if (successfulProducts.length) {
            this.ui.info(text.success.banner(environment, environmentType, (0, cli_shared_1.productDisplayName)(successfulProducts.join(', ')), site.host));
        }
        else if (!upgrade) {
            this.ui.info(cli_shared_1.Text.install.failedAll(site, environment));
        }
        if (failedProducts.length) {
            throw new cli_shared_1.PartialInstallationError(cli_shared_1.Text.error.partialInstallation(failedProducts));
        }
    }
    getEntitlementOfferingName(entitlementOffering) {
        if (!entitlementOffering)
            return undefined;
        if ('currentEdition' in entitlementOffering) {
            return entitlementOffering.currentEdition?.toLowerCase();
        }
        else if ('offering' in entitlementOffering) {
            return entitlementOffering.offering?.name?.toLowerCase();
        }
        return undefined;
    }
    async isNonProductionAppInstallationAttempt(site, products, environmentType) {
        if (environmentType === cli_shared_1.AppEnvironmentType.Production)
            return false;
        try {
            const entitlementPromises = products.map((prod) => this.checkProductEntitlementOffering(site, prod));
            const results = await Promise.all(entitlementPromises);
            return results.some((result) => result);
        }
        catch (error) {
            return false;
        }
    }
    async checkProductEntitlementOffering(site, product) {
        const entitlementOffering = await this.installationService.getEntitlementOfferingProduct(site, product);
        const entitlementOfferingName = this.getEntitlementOfferingName(entitlementOffering)?.toLowerCase();
        if (!entitlementOfferingName)
            return false;
        const nonProductionLicenseTypes = ['free', 'developer', 'sandbox'];
        return !nonProductionLicenseTypes.some((nonProductionLicenseType) => entitlementOfferingName.includes(nonProductionLicenseType));
    }
    getAllScopeKeys = (scopes) => {
        return Array.isArray(scopes) ? scopes : Object.keys(scopes);
    };
    extractManifestData = (manifestEgressEntries, permissions) => {
        const manifestEgressAddresses = (0, cli_shared_1.flatMap)(manifestEgressEntries, ({ domains }) => domains ?? []);
        const manifestScopes = new Set(this.getAllScopeKeys(permissions?.scopes ?? []));
        return { manifestEgressAddresses, manifestScopes };
    };
    getXPAProductsAndSite = async (requiredProducts, products, site, environmentKey) => {
        site = site ? site : await this.promptForSite([]);
        const { installations = [] } = await this.installationService.listAppInstallations({
            site,
            ...(environmentKey && { environment: environmentKey }),
            ...(requiredProducts.length > 0 && { product: requiredProducts[0] })
        });
        if (!products?.length) {
            const hasRequiredInstallations = this.checkRequiredInstallationExists(installations, site.host, requiredProducts);
            if (hasRequiredInstallations) {
                this.ui.info(cli_shared_1.Text.install.alreadyInstalledInRequiredProduct(requiredProducts[0]));
                products = products?.length ? products : await this.promptForProducts(requiredProducts);
            }
            else {
                this.ui.info(cli_shared_1.Text.install.installingToRequiredProduct(requiredProducts[0]));
                products = requiredProducts.map((product) => (0, cli_shared_1.productDisplayName)(product));
            }
        }
        else {
            const allowedProducts = this.supportedProductsService.getSupportedSecondaryProductsForXPA([]);
            if (products.some((product) => !allowedProducts.includes(product))) {
                throw new cli_shared_1.ValidationError(cli_shared_1.Text.error.invalidContext(allowedProducts));
            }
            if (requiredProducts.includes(products[0])) {
                this.ui.info(cli_shared_1.Text.install.installingToRequiredProduct(products[0]));
            }
            else {
                this.ui.info(cli_shared_1.Text.install.installingToOptionalProduct(products[0]));
            }
        }
        return { site, products };
    };
    checkForMultiProductScopes = async (environmentScopes, site, environment) => {
        const uniqueProductsFromScopes = this.getUniqueInstallationProductsFromScopes(environmentScopes);
        if (!uniqueProductsFromScopes || uniqueProductsFromScopes.length <= 1)
            return;
        const { installations: nonTechnicalInstallations } = await this.installationService.listNonTechnicalAppInstallations({
            site,
            environment
        });
        const productsToUpgrade = nonTechnicalInstallations
            .filter((installation) => !installation.version.isLatest)
            .map((installation) => installation.product);
        const allInstalledProducts = nonTechnicalInstallations
            .flatMap((install) => {
            const secondaryProducts = install.secondaryProducts ?? [];
            return [...secondaryProducts, install.product];
        })
            .filter((product) => product !== undefined);
        const productsToInstall = uniqueProductsFromScopes.filter((product) => !allInstalledProducts.includes(product));
        if (productsToInstall.length === 0 && productsToUpgrade.length === 0)
            return;
        this.ui.warn(cli_shared_1.Text.install.multiProductScopesDetected(productsToInstall, productsToUpgrade, site.host, environment));
    };
    async convertListScope(scopesToList) {
        const scopesWithInteractiveConsent = (0, manifest_1.getScopesWithInteractiveConsent)();
        return scopesToList.map((scope) => ({
            name: scope,
            requiresInteractiveConsent: scopesWithInteractiveConsent.has(scope)
        }));
    }
    isValidLicenseMode(value) {
        return Object.values(cli_shared_1.EcosystemLicenseMode).includes(value);
    }
    validateLicenseModes(licenseModes, usersWithAccess, environment) {
        if (licenseModes === undefined) {
            return undefined;
        }
        if (environment === cli_shared_1.PRODUCTION_ENVIRONMENT_KEY) {
            throw new cli_shared_1.UserError(cli_shared_1.Text.error.licenseModesOverrideErrors.prodEnvNotSupported);
        }
        if (!Array.isArray(licenseModes) || licenseModes.length === 0) {
            throw new cli_shared_1.UserError(cli_shared_1.Text.error.licenseModesOverrideErrors.empty);
        }
        const ecosystemLicenseModes = new Set();
        for (const licenseMode of licenseModes) {
            const formattedLicenseMode = licenseMode.toUpperCase().replace('-', '_');
            if (!this.isValidLicenseMode(formattedLicenseMode)) {
                throw new cli_shared_1.UserError(cli_shared_1.Text.error.licenseModesOverrideErrors.invalid);
            }
            ecosystemLicenseModes.add(formattedLicenseMode);
        }
        return Array.from(ecosystemLicenseModes);
    }
    validateUsersWithAccess(licenseModes, usersWithAccess, environment) {
        if (usersWithAccess === undefined)
            return;
        if (environment === cli_shared_1.PRODUCTION_ENVIRONMENT_KEY) {
            throw new cli_shared_1.UserError(cli_shared_1.Text.error.userWithAccessOverrideErrors.prodEnvNotSupported);
        }
        if (!Array.isArray(usersWithAccess) || usersWithAccess.length === 0) {
            throw new cli_shared_1.UserError(cli_shared_1.Text.error.userWithAccessOverrideErrors.empty);
        }
        if (usersWithAccess.length > cli_shared_1.Text.maxSizeOfUsersWithAccess) {
            throw new cli_shared_1.UserError(cli_shared_1.Text.error.userWithAccessOverrideErrors.countSize(cli_shared_1.Text.maxSizeOfUsersWithAccess));
        }
    }
    async validateEcosystemAppInstallationOverridesInput(licenseModes, usersWithAccess, environment) {
        const ecosystemLicenseModes = this.validateLicenseModes(licenseModes, usersWithAccess, environment);
        this.validateUsersWithAccess(ecosystemLicenseModes, usersWithAccess, environment);
        return ecosystemLicenseModes || usersWithAccess
            ? { licenseModes: ecosystemLicenseModes, usersWithAccess }
            : undefined;
    }
    checkRequiredInstallationExists = (installations, site, requiredProducts) => {
        return requiredProducts.every((requiredProduct) => installations.some((installation) => installation.site.includes(site) && installation.product.toLowerCase() === requiredProduct.toLowerCase()));
    };
}
exports.InstallController = InstallController;
//# sourceMappingURL=install-controller.js.map