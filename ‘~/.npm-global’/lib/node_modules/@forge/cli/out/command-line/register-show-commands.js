"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCommands = void 0;
const cli_shared_1 = require("@forge/cli-shared");
function readServicesFromConfig(manifest) {
    if (!manifest || !manifest.services) {
        return [];
    }
    return manifest.services.map((service) => service.key);
}
class ShowCommandError extends Error {
}
function showCommandError(ui, message) {
    ui.error(new ShowCommandError(message));
    ui.emptyLine();
}
function specifiedContainerExists(allServiceContainers, containerKey) {
    return allServiceContainers.some((ct) => ct.key === containerKey && ct.instances && ct.instances.length > 0);
}
const SHOW_SERVICES_COMMAND_NAME = 'services';
const registerShowServiceCommand = (parent, { ui, commands: { containerCommand }, configFile }) => {
    parent
        .command(SHOW_SERVICES_COMMAND_NAME)
        .description(cli_shared_1.Text.show.services.cmd.desc)
        .requireAppId()
        .environmentOption()
        .option('-s, --service [service]', cli_shared_1.Text.show.services.cmd.serviceKeyOption)
        .action(async ({ service, environment }) => {
        ui.info(cli_shared_1.Text.show.services.overview);
        environment = (0, cli_shared_1.optionToEnvironment)(environment);
        const serviceNames = service ? [service] : readServicesFromConfig(await configFile.readConfig());
        const { services } = await containerCommand.getContainerServiceDetails(environment, serviceNames);
        if (!services || !services.length) {
            showCommandError(ui, cli_shared_1.Text.show.services.noServicesFound(environment));
            return;
        }
        const headings = [
            ['service', 'Service'],
            ['serviceStatus', 'Service Status'],
            ['versionStatus', 'Version Status'],
            ['runningCount', 'Running Count'],
            ['pendingCount', 'Pending Count'],
            ['maxCount', 'Max Count'],
            ['minCount', 'Min Count'],
            ['createdAt', 'Created at'],
            ['updatedAt', 'Updated at']
        ];
        if (service) {
            headings.shift();
        }
        ui.emptyLine();
        ui.table(headings, services.map((s) => ({
            service: s.key,
            serviceStatus: s.serviceStatus,
            versionStatus: s.versionStatus,
            runningCount: s.runningCount,
            pendingCount: s.pendingCount,
            maxCount: s.maxCount,
            minCount: s.minCount,
            createdAt: s.createdAt,
            updatedAt: s.updatedAt
        })), {
            preMessage: service
                ? cli_shared_1.Text.show.services.specificService(service, environment)
                : cli_shared_1.Text.show.services.allServices(environment)
        });
        ui.emptyLine();
    });
};
const SHOW_CONTAINERS_COMMAND_NAME = 'containers';
const registerShowContainerCommand = (parent, { ui, commands: { containerCommand }, configFile }) => {
    parent
        .command(SHOW_CONTAINERS_COMMAND_NAME)
        .description(cli_shared_1.Text.show.containers.cmd.desc)
        .option('-s, --service <service>', cli_shared_1.Text.show.containers.cmd.serviceKeyOption)
        .option('-c, --container [container]', cli_shared_1.Text.show.containers.cmd.containerKeyOption)
        .requireAppId()
        .environmentOption()
        .action(async ({ environment, service, container }) => {
        ui.info(cli_shared_1.Text.show.containers.overview);
        environment = (0, cli_shared_1.optionToEnvironment)(environment);
        if (!service) {
            ui.emptyLine();
            const serviceNames = readServicesFromConfig(await configFile.readConfig());
            service = await ui.promptForList(cli_shared_1.Text.show.containers.prompt.entry, serviceNames);
            ui.emptyLine();
        }
        const { services } = await containerCommand.getContainerServiceDetails(environment, [service]);
        if (!services || !services.length) {
            showCommandError(ui, cli_shared_1.Text.show.containers.noContainersFound(environment));
            return;
        }
        const specifiedService = services.find((s) => s.key === service);
        if (!specifiedService) {
            showCommandError(ui, cli_shared_1.Text.show.containers.specifiedServiceNotFound(service, environment));
            return;
        }
        if (!specifiedService.containers || !specifiedService.containers.length) {
            showCommandError(ui, cli_shared_1.Text.show.containers.noContainersFoundForService(service, environment));
            return;
        }
        let containers = specifiedService.containers;
        if (container) {
            if (!specifiedContainerExists(containers, container)) {
                showCommandError(ui, cli_shared_1.Text.show.containers.specifiedContainerNotFound(service, container, environment));
                return;
            }
            containers = specifiedService.containers.filter((ct) => ct.key === container);
        }
        for (const ct of containers) {
            if (!ct.instances || !ct.instances.length) {
                ui.info(cli_shared_1.Text.show.containers.noInstancesFoundForContainer(ct.key, service, environment));
                ui.emptyLine();
                continue;
            }
            ui.emptyLine();
            ui.table([
                ['id', 'ID'],
                ['health', 'Health'],
                ['status', 'Status'],
                ['imageURI', 'ImageURI'],
                ['createdAt', 'Created at']
            ], ct.instances.map((c) => ({
                id: c.id,
                health: c.healthStatus,
                status: c.containerStatus,
                imageURI: c.imageURI,
                createdAt: c.createdAt
            })), { preMessage: cli_shared_1.Text.show.containers.specificContainer(ct.key) });
            ui.emptyLine();
        }
    });
};
const SHOW_COMMAND_NAME = 'show';
const registerCommands = (deps) => {
    const containersCmd = deps.cmd.command(SHOW_COMMAND_NAME, { hidden: true }).description(cli_shared_1.Text.show.cmd.desc);
    registerShowServiceCommand(containersCmd, deps);
    registerShowContainerCommand(containersCmd, deps);
};
exports.registerCommands = registerCommands;
//# sourceMappingURL=register-show-commands.js.map