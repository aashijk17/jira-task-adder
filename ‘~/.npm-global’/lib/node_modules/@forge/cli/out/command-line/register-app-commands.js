"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCommands = exports.filterTemplatesByProduct = exports.createCommandHandler = exports.isValidDevSpaceId = exports.directoryNameFromAppName = exports.templateMatchesProduct = exports.formatProduct = exports.CATEGORY_PREDICATES = exports.PRODUCT_OPTIONS_DISPLAY = exports.TemplateContext = exports.TemplateCategory = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const sanitize_filename_1 = tslib_1.__importDefault(require("sanitize-filename"));
const cli_shared_1 = require("@forge/cli-shared");
var TemplateCategory;
(function (TemplateCategory) {
    TemplateCategory["SHOW_ALL"] = "Show All";
    TemplateCategory["ROVO"] = "Rovo Agent and action";
    TemplateCategory["UI_KIT_2"] = "UI Kit";
    TemplateCategory["CUSTOM_UI"] = "Custom UI";
    TemplateCategory["BACKEND"] = "Triggers and Validators";
})(TemplateCategory = exports.TemplateCategory || (exports.TemplateCategory = {}));
var TemplateContext;
(function (TemplateContext) {
    TemplateContext["SHOW_ALL"] = "show-all";
    TemplateContext["AUTOMATION"] = "automation";
    TemplateContext["BITBUCKET"] = "bitbucket";
    TemplateContext["COMPASS"] = "compass";
    TemplateContext["CONFLUENCE"] = "confluence";
    TemplateContext["DASHBOARDS"] = "dashboards";
    TemplateContext["JIRA"] = "jira";
    TemplateContext["JIRA_SERVICE_MANAGEMENT"] = "jira-service-management";
    TemplateContext["TEAMWORK_GRAPH"] = "teamwork-graph";
    TemplateContext["ROVO"] = "rovo";
    TemplateContext["CROSS_CONTEXT"] = "cross-context";
})(TemplateContext = exports.TemplateContext || (exports.TemplateContext = {}));
const PRODUCT_OPTIONS = {
    [TemplateContext.SHOW_ALL]: [TemplateContext.SHOW_ALL],
    [TemplateContext.AUTOMATION]: [TemplateContext.AUTOMATION],
    [TemplateContext.BITBUCKET]: [TemplateContext.BITBUCKET],
    [TemplateContext.COMPASS]: [TemplateContext.COMPASS],
    [TemplateContext.CONFLUENCE]: [TemplateContext.CONFLUENCE],
    [TemplateContext.DASHBOARDS]: [TemplateContext.DASHBOARDS],
    [TemplateContext.JIRA]: [TemplateContext.JIRA],
    [TemplateContext.JIRA_SERVICE_MANAGEMENT]: [TemplateContext.JIRA_SERVICE_MANAGEMENT],
    [TemplateContext.TEAMWORK_GRAPH]: [TemplateContext.TEAMWORK_GRAPH],
    [TemplateContext.ROVO]: [TemplateContext.ROVO],
    [TemplateContext.CROSS_CONTEXT]: [
        TemplateContext.COMPASS,
        TemplateContext.CONFLUENCE,
        TemplateContext.DASHBOARDS,
        TemplateContext.JIRA,
        TemplateContext.JIRA_SERVICE_MANAGEMENT
    ]
};
exports.PRODUCT_OPTIONS_DISPLAY = {
    [TemplateContext.CROSS_CONTEXT]: 'Multiple',
    [TemplateContext.AUTOMATION]: 'Automation (Preview)',
    [TemplateContext.DASHBOARDS]: 'Dashboards (EAP)'
};
exports.CATEGORY_PREDICATES = [
    [TemplateCategory.SHOW_ALL, (name) => !!name],
    [TemplateCategory.ROVO, (name) => name.includes('rovo')],
    [TemplateCategory.UI_KIT_2, (name) => name.includes('ui-kit')],
    [TemplateCategory.CUSTOM_UI, (name) => name.includes('custom-ui')],
    [
        TemplateCategory.BACKEND,
        (name) => !!name && !name.includes('ui-kit') && !name.includes('custom-ui') && !name.includes('rovo') && name !== 'blank'
    ]
];
const MAX_NAME_LENGTH = 60;
function formatProduct(product) {
    return (exports.PRODUCT_OPTIONS_DISPLAY[product] ??
        product
            .split('-')
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' '));
}
exports.formatProduct = formatProduct;
function ensureDirectoryDoesntExist(directory) {
    if (fs_1.default.existsSync(directory)) {
        throw new cli_shared_1.ValidationError(cli_shared_1.Text.create.error.directory.exists(directory));
    }
}
function ensureValidNameLength(name) {
    if (name.length <= 0 || name.length > MAX_NAME_LENGTH) {
        throw new cli_shared_1.ValidationError(cli_shared_1.Text.create.error.name.tooLong(MAX_NAME_LENGTH));
    }
}
async function selectedTemplate(filteredTemplates, ui, categoryPredicates = exports.CATEGORY_PREDICATES) {
    const categoryMap = filteredTemplates.reduce((map, template) => {
        for (const [category, matchesCategory] of categoryPredicates) {
            if (matchesCategory(template)) {
                const templates = map.get(category) ?? [];
                templates.push(template);
                map.set(category, templates);
            }
        }
        return map;
    }, new Map());
    if (categoryMap.size) {
        const sortedCategories = categoryPredicates
            .filter(([category]) => categoryMap.has(category))
            .map(([category]) => category);
        const category = await ui.promptForList(cli_shared_1.Text.create.promptCategory, sortedCategories);
        const categoryFilteredTemplates = filterTemplatesByCategory(categoryMap.get(category) ?? filteredTemplates, category);
        const template = await ui.promptForList(cli_shared_1.Text.create.promptTemplate, categoryFilteredTemplates);
        return modifyTemplateByCategory(template, category);
    }
    else {
        return await ui.promptForList(cli_shared_1.Text.create.promptTemplate, filteredTemplates);
    }
}
function templateMatchesProduct(productName, templateName, products) {
    return (templateName.includes(productName) &&
        products.length > 0 &&
        !products.some((otherProduct) => otherProduct && otherProduct.length > productName.length && templateName.includes(otherProduct)));
}
exports.templateMatchesProduct = templateMatchesProduct;
function directoryNameFromAppName(appName) {
    if (appName === undefined) {
        return undefined;
    }
    const normalized = (0, sanitize_filename_1.default)(appName.trim()).trim().replace(/ /g, '-');
    const chars = Array.from(normalized);
    const allDashes = chars.every((char) => char === '-');
    return allDashes ? undefined : normalized;
}
exports.directoryNameFromAppName = directoryNameFromAppName;
const isValidDevSpaceId = (developerSpaceId) => {
    const UUID_PATTERN = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    return UUID_PATTERN.test(developerSpaceId);
};
exports.isValidDevSpaceId = isValidDevSpaceId;
async function handleDevSpaceSelection(ui, devSpaceService, developerSpaceId, commandContext) {
    let isNewlyCreatedDevSpace = false;
    let selectedDevSpace;
    ui.emptyLine();
    ui.info(cli_shared_1.Text.ctrlC);
    ui.emptyLine();
    const devSpaces = await devSpaceService.getDevSpaces(ui);
    if (developerSpaceId) {
        selectedDevSpace = devSpaces.find((ds) => ds.id === developerSpaceId);
        if (!selectedDevSpace) {
            throw new cli_shared_1.ValidationError(cli_shared_1.Text.devSpace.invalidSpaceName(developerSpaceId));
        }
    }
    else {
        if (commandContext === 'register' && devSpaces.length) {
            ui.info(cli_shared_1.Text.devSpace.assignmentInfo);
            ui.emptyLine();
            ui.info(cli_shared_1.Text.devSpace.selectionPrompt(cli_shared_1.Text.devSpace.documentationLink));
            ui.emptyLine();
        }
        const devSpaceResult = await devSpaceService.selectDevSpace(ui, devSpaces, commandContext);
        if (!devSpaceResult) {
            return null;
        }
        ui.emptyLine();
        isNewlyCreatedDevSpace = devSpaceResult.isNewlyCreated;
        selectedDevSpace = devSpaceResult.devSpace;
    }
    if (!isNewlyCreatedDevSpace && selectedDevSpace) {
        const messageText = commandContext === 'create'
            ? cli_shared_1.Text.devSpace.contributingToSpace(selectedDevSpace.name)
            : cli_shared_1.Text.devSpace.assigningToSpace(selectedDevSpace.name);
        ui.info(messageText);
    }
    ui.clearSpinner();
    return {
        selectedDevSpace,
        isNewlyCreatedDevSpace
    };
}
async function createCommandHandler(ui, createAppCommand, name, { template, directory, developerSpaceId }, devSpaceService, isDevSpaceSelectionEnabled) {
    if (isDevSpaceSelectionEnabled && developerSpaceId && !(0, exports.isValidDevSpaceId)(developerSpaceId)) {
        throw new cli_shared_1.ValidationError(cli_shared_1.Text.devSpace.invalidSpaceId(developerSpaceId));
    }
    const devSpaceResult = isDevSpaceSelectionEnabled
        ? await handleDevSpaceSelection(ui, devSpaceService, developerSpaceId, 'create')
        : null;
    if (isDevSpaceSelectionEnabled && devSpaceResult === null) {
        return;
    }
    const { selectedDevSpace, isNewlyCreatedDevSpace } = devSpaceResult || {
        selectedDevSpace: undefined,
        isNewlyCreatedDevSpace: false
    };
    directory = prepareDirectoryForApp(ui, name, template, directory);
    if (!isDevSpaceSelectionEnabled) {
        ui.info(cli_shared_1.Text.ctrlC);
    }
    ({ name, directory } = await promptAndValidateAppName(ui, name, directory, template, isDevSpaceSelectionEnabled, isNewlyCreatedDevSpace));
    const selection = await promptAndSelectTemplate(ui, createAppCommand, template, directory);
    template = selection.template;
    ui.emptyLine();
    directory = directory;
    const args = {
        name,
        template,
        directory,
        ...(selection.requiredContext && { requiredProduct: selection.requiredContext }),
        ...(selectedDevSpace?.id && { developerSpaceId: selectedDevSpace?.id })
    };
    const result = await ui.displayProgress(() => createAppCommand.execute(args), cli_shared_1.Text.create.cmd.start, cli_shared_1.Text.create.cmd.success(name));
    ui.info(cli_shared_1.Text.create.cmd.successDetails(directory, result.environments));
    return result;
}
exports.createCommandHandler = createCommandHandler;
function prepareDirectoryForApp(ui, name, template, directory) {
    if (directory) {
        ensureDirectoryDoesntExist(directory);
        ui.info(cli_shared_1.Text.create.intro(directory));
    }
    else {
        directory = directoryNameFromAppName(name) || template;
        if (directory) {
            ensureDirectoryDoesntExist(directory);
        }
        const currentDirectory = process.cwd();
        ui.info(cli_shared_1.Text.create.introWithCurrentDirectory(currentDirectory));
    }
    return directory;
}
async function promptAndValidateAppName(ui, name, directory, template, isDevSpaceSelectionEnabled, isNewlyCreatedDevSpace) {
    if (!name) {
        ui.info(cli_shared_1.Text.create.overviewAppName);
        name = await ui.promptForText(cli_shared_1.Text.create.promptName);
        if (!directory) {
            directory = directoryNameFromAppName(name) || template;
            if (directory) {
                ensureDirectoryDoesntExist(directory);
            }
        }
    }
    ensureValidNameLength(name);
    return { name, directory };
}
async function promptAndSelectTemplate(ui, createAppCommand, template, directory) {
    if (!template) {
        ui.info(cli_shared_1.Text.create.overviewTemplates);
        const templates = await ui.displayTemporaryMessage(() => createAppCommand.getAvailableTemplates(), cli_shared_1.Text.create.waitTemplates);
        const templatesWithoutCsuik = templates.filter((template) => !template.includes('csuik'));
        const productOptions = await createAppCommand.filterAvailableProducts(Object.values(TemplateContext), TemplateContext.TEAMWORK_GRAPH, TemplateContext.CROSS_CONTEXT);
        const productName = await ui.promptForList(cli_shared_1.Text.create.promptProduct, productOptions, {
            format: formatProduct
        }, productOptions.length);
        const filteredTemplates = (PRODUCT_OPTIONS[productName] ?? [productName])
            .map((p) => filterTemplatesByProduct(templatesWithoutCsuik, p, productOptions))
            .flat();
        const uniqueTemplates = [...new Set(filteredTemplates.length ? filteredTemplates : templatesWithoutCsuik)];
        template = await selectedTemplate(uniqueTemplates, ui);
        if (!directory) {
            directory = template;
            ensureDirectoryDoesntExist(directory);
        }
        let requiredContext = undefined;
        if (productName === TemplateContext.CROSS_CONTEXT) {
            requiredContext = productOptions.find((context) => templateMatchesProduct(context, template, productOptions));
        }
        return {
            template,
            requiredContext: requiredContext === TemplateContext.JIRA_SERVICE_MANAGEMENT ? TemplateContext.JIRA : requiredContext
        };
    }
    return {
        template
    };
}
function filterTemplatesByProduct(templates, product, productOptions) {
    return product === 'show-all'
        ? templates
        : templates.filter((template) => templateMatchesProduct(product, template, productOptions));
}
exports.filterTemplatesByProduct = filterTemplatesByProduct;
function filterTemplatesByCategory(templates, category) {
    return category === TemplateCategory.SHOW_ALL
        ? templates
        : templates.map((name) => name.replace('-ui-kit', '').replace('-custom-ui', '').replace('-rovo', ''));
}
function modifyTemplateByCategory(template, category) {
    switch (category) {
        case TemplateCategory.UI_KIT_2:
            return `${template}-ui-kit`;
        case TemplateCategory.CUSTOM_UI:
            return `${template}-custom-ui`;
        case TemplateCategory.ROVO:
            return `${template}-rovo`;
        default:
            return template;
    }
}
async function registerCreateCommands(deps) {
    const { cmd, ui, commands: { createAppCommand }, services: { devSpaceService, statsigService } } = deps;
    const isDevSpaceSelectionEnabled = await statsigService.isDevSpaceSelectionEnabled();
    const createCommand = cmd
        .command('create [name]')
        .description(cli_shared_1.Text.create.cmd.desc)
        .option('-t, --template <template name>', cli_shared_1.Text.create.optionTemplate)
        .option('-d, --directory <directory name>', cli_shared_1.Text.create.optionDirectory);
    if (isDevSpaceSelectionEnabled) {
        createCommand.option('-s, --developer-space-id <Developer Space id>', cli_shared_1.Text.create.optionSpace);
    }
    createCommand.action((name, options) => {
        return createCommandHandler(ui, createAppCommand, name, options, devSpaceService, isDevSpaceSelectionEnabled);
    });
}
async function registerRegisterCommand({ cmd, ui, commands: { registerAppCommand }, services: { devSpaceService, statsigService } }) {
    const isDevSpaceSelectionEnabled = await statsigService.isDevSpaceSelectionEnabled();
    const registerCommand = cmd.command('register [name]').description(cli_shared_1.Text.register.cmd.desc);
    if (isDevSpaceSelectionEnabled) {
        registerCommand.option('-s, --developer-space-id <Developer Space id>', cli_shared_1.Text.create.optionSpace);
    }
    registerCommand
        .requireManifestFile()
        .action(async (name, options) => {
        const { developerSpaceId } = options;
        if (isDevSpaceSelectionEnabled && developerSpaceId && !(0, exports.isValidDevSpaceId)(developerSpaceId)) {
            throw new cli_shared_1.ValidationError(cli_shared_1.Text.devSpace.invalidSpaceId(developerSpaceId));
        }
        const devSpaceResult = isDevSpaceSelectionEnabled
            ? await handleDevSpaceSelection(ui, devSpaceService, developerSpaceId, 'register')
            : null;
        if (isDevSpaceSelectionEnabled && devSpaceResult === null) {
            return;
        }
        const { selectedDevSpace } = devSpaceResult || {
            selectedDevSpace: undefined
        };
        if (isDevSpaceSelectionEnabled) {
            ui.info(cli_shared_1.Text.register.intro);
        }
        else {
            ui.info(cli_shared_1.Text.register.intro);
            ui.info(cli_shared_1.Text.ctrlC);
            ui.emptyLine();
        }
        if (!name) {
            ui.info(cli_shared_1.Text.create.overviewAppName);
            name = await ui.promptForText(cli_shared_1.Text.create.promptName);
            ui.emptyLine();
        }
        const executeArgs = { name, ...(selectedDevSpace?.id && { developerSpaceId: selectedDevSpace?.id }) };
        const result = await ui.displayProgress(() => registerAppCommand.execute(executeArgs), cli_shared_1.Text.register.cmd.start, cli_shared_1.Text.register.cmd.success(name));
        ui.info(cli_shared_1.Text.register.cmd.successDetails(result.environments));
        return result;
    });
}
async function registerCommands(deps) {
    await registerCreateCommands(deps);
    await registerRegisterCommand(deps);
}
exports.registerCommands = registerCommands;
//# sourceMappingURL=register-app-commands.js.map