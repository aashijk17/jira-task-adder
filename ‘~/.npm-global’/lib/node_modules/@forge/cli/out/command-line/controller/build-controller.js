"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildController = exports.ManifestEnvironmentVariablesError = exports.BuildLintFailureError = void 0;
const cli_shared_1 = require("@forge/cli-shared");
class BuildLintFailureError extends cli_shared_1.HiddenError {
    scopes;
    constructor(scopes) {
        super();
        this.scopes = scopes;
    }
    getAttributes() {
        return {
            ...super.getAttributes(),
            scopes: this.scopes
        };
    }
    isUserError() {
        return true;
    }
}
exports.BuildLintFailureError = BuildLintFailureError;
class ManifestEnvironmentVariablesError extends Error {
    constructor(message) {
        super(message);
    }
    isUserError() {
        return true;
    }
}
exports.ManifestEnvironmentVariablesError = ManifestEnvironmentVariablesError;
class BuildController {
    buildView;
    lintService;
    configFile;
    nodePackageUploadDeployCommand;
    buildService;
    constructor(buildView, lintService, configFile, nodePackageUploadDeployCommand, buildService) {
        this.buildView = buildView;
        this.lintService = lintService;
        this.configFile = configFile;
        this.nodePackageUploadDeployCommand = nodePackageUploadDeployCommand;
        this.buildService = buildService;
    }
    async run({ verify, buildTag }) {
        buildTag = buildTag ?? this.buildService.generateBuildTag();
        this.buildService.validateBuildOptions({ buildTag });
        this.buildView.displayStart();
        if (verify) {
            await this.verifyPreBuild();
        }
        const handlers = await this.configFile.getAppHandlers();
        const resources = await this.configFile.getResources();
        const config = await this.configFile.readConfig();
        this.checkForManifestVariables(config);
        const packageConfig = config.app?.package;
        await this.buildView.reportBuildProgress(buildTag, () => this.nodePackageUploadDeployCommand.packageUpload({
            handlers,
            resources,
            packageConfig,
            modules: config.modules,
            majorVersion: undefined,
            i18nConfig: config.translations,
            buildTag
        }));
    }
    listBuilds(limit) {
        return this.buildService.getBuildsByApp(limit);
    }
    async verifyPreBuild() {
        this.buildView.displayLintRunning();
        const { lintResults } = await this.lintService.run(cli_shared_1.PRODUCTION_ENVIRONMENT_KEY, { fix: false }, this.buildView.getLogger());
        const problemCount = this.lintService.problemCount(lintResults);
        if (problemCount.errors) {
            this.buildView.displayLintErrors(lintResults);
            const failures = this.lintService.failedScopes(lintResults);
            throw new BuildLintFailureError(failures);
        }
        else if (problemCount.warnings) {
            this.buildView.displayLintWarnings(problemCount.warnings);
        }
        else {
            this.buildView.displayNoLintProblems();
        }
        const manifest = await this.configFile.readConfig();
        this.checkForUIKit1Modules(manifest);
    }
    checkForUIKit1Modules(manifest) {
        if (manifest?.modules) {
            const uiKit1Modules = (0, cli_shared_1.findUIKit1Modules)(manifest.modules);
            if (uiKit1Modules.length > 0) {
                this.buildView.displayUIKit1DeprecationMessage(uiKit1Modules);
            }
        }
    }
    checkForManifestVariables(manifest) {
        const envVars = manifest.environment?.variables;
        if (envVars) {
            throw new ManifestEnvironmentVariablesError(cli_shared_1.Text.build.manifestVariables.error);
        }
    }
}
exports.BuildController = BuildController;
//# sourceMappingURL=build-controller.js.map