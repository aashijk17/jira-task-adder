"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCommands = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const registerImagesCommand = (parent, { ui, commands: { containerCommand } }) => {
    parent
        .command('images')
        .requireAppId()
        .description(cli_shared_1.Text.repositories.images.cmd.desc)
        .command('list')
        .option('-k, --key <key>', cli_shared_1.Text.repositories.images.list.cmd.keyOption)
        .description(cli_shared_1.Text.repositories.images.list.cmd.desc)
        .action(async ({ key }) => {
        if (!key) {
            ui.info(cli_shared_1.Text.repositories.images.list.prompt.overview);
            ui.emptyLine();
            key = await ui.promptForText(cli_shared_1.Text.repositories.images.list.prompt.entry);
            ui.emptyLine();
        }
        ui.info(cli_shared_1.Text.repositories.images.list.listingImages(key));
        ui.info(cli_shared_1.Text.ctrlC);
        ui.emptyLine();
        let startCursor;
        do {
            const { images, endCursor, hasNextPage } = await containerCommand.fetchImages(key, startCursor);
            ui.table([
                ['tags', 'Image Tags'],
                ['pushedAt', 'Pushed At'],
                ['lastPulledAt', 'Last Pulled At'],
                ['sizeInBytes', 'Size (bytes)'],
                ['digest', 'Digest']
            ], images.map(({ digest, tags, pushedAt, lastPulledAt, sizeInBytes }) => ({
                tags: tags.join(', '),
                pushedAt,
                digest,
                lastPulledAt: lastPulledAt || '-',
                sizeInBytes: sizeInBytes.toString()
            })), { json: false, emptyMessage: cli_shared_1.Text.repositories.images.list.noImagesFound });
            startCursor = hasNextPage ? endCursor : undefined;
            if (!startCursor) {
                break;
            }
            ui.emptyLine();
            const result = await ui.confirm(cli_shared_1.Text.repositories.images.list.promptNextPage);
            if (!result) {
                break;
            }
        } while (true);
    });
};
const registerListCommand = (parent, { ui, commands: { containerCommand } }) => {
    parent
        .command('list')
        .description(cli_shared_1.Text.repositories.list.cmd.desc)
        .requireAppId()
        .action(async () => {
        ui.info(cli_shared_1.Text.repositories.list.listingRepositories);
        ui.info(cli_shared_1.Text.ctrlC);
        ui.emptyLine();
        const containers = await containerCommand.fetchContainers();
        ui.table([
            ['key', 'Container Key'],
            ['repositoryURI', 'Repository URI']
        ], containers.map(({ key, repositoryURI }) => ({ key, repositoryURI })), { json: false, emptyMessage: cli_shared_1.Text.repositories.list.noContainersFound });
    });
};
const registerCommands = (deps) => {
    const repositoriesCommand = deps.cmd
        .command('repositories', { hidden: true })
        .description(cli_shared_1.Text.repositories.cmd.desc);
    registerImagesCommand(repositoriesCommand, deps);
    registerListCommand(repositoriesCommand, deps);
};
exports.registerCommands = registerCommands;
//# sourceMappingURL=register-repositories-commands.js.map