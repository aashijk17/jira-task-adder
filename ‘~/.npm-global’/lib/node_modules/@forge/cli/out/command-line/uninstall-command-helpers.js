"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.performMultipleUninstalls = exports.performSingleUninstall = exports.getInstallationContext = exports.getInstallationsFromSelection = exports.getMultiChoiceOptionsForUninstall = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const shared_1 = require("../installations/shared");
const errors_1 = require("./errors");
function addRequiredSuffix(productDisplayName, secondaryCount) {
    return secondaryCount ? `${productDisplayName} (Required)` : productDisplayName;
}
const getMultiChoiceOptionsForUninstall = (filteredInstallations) => {
    return filteredInstallations.reduce((acc, { id, environmentKey, site, product, secondaryProducts, secondaryContexts }, idx) => {
        acc.push({
            names: [
                (0, cli_shared_1.environmentToOption)(environmentKey),
                site,
                addRequiredSuffix((0, cli_shared_1.productDisplayName)(product), secondaryProducts?.length)
            ],
            value: id,
            extra: {
                installationIdx: idx,
                product: product,
                autoSelectId: !!secondaryProducts?.length ? id : undefined,
                required: !!secondaryProducts?.length
            }
        });
        if (secondaryProducts) {
            secondaryProducts.forEach((secondaryProduct, secondaryIdx) => {
                const contextAri = secondaryContexts?.[secondaryIdx];
                acc.push({
                    names: [(0, cli_shared_1.environmentToOption)(environmentKey), site, (0, cli_shared_1.productDisplayName)(secondaryProduct)],
                    value: id,
                    extra: { optional: true, contextAri, installationIdx: idx, product: secondaryProduct }
                });
            });
        }
        return acc;
    }, []);
};
exports.getMultiChoiceOptionsForUninstall = getMultiChoiceOptionsForUninstall;
const getInstallationsFromSelection = (options, selectedSitesIndexes, filteredInstallations) => {
    const firstUninstall = options
        .filter((_, idx) => selectedSitesIndexes.includes(idx))
        .filter(({ extra }) => !extra?.required)
        .map(({ extra }) => ({
        ...filteredInstallations[extra.installationIdx],
        ...(extra.optional && { context: extra.contextAri, product: extra.product })
    }));
    const secondUninstall = options
        .filter((_, idx) => selectedSitesIndexes.includes(idx))
        .filter(({ extra }) => extra?.required)
        .map(({ extra }) => filteredInstallations[extra.installationIdx]);
    const installationIds = new Set([...firstUninstall, ...secondUninstall].map(({ id }) => id));
    const groups = options.reduce((acc, option, idx) => {
        if (!installationIds.has(option.value)) {
            return acc;
        }
        const group = acc.get(option.value) || new Set();
        group.add(idx);
        acc.set(option.value, group);
        return acc;
    }, new Map());
    const selectedSitesIndexSet = new Set(selectedSitesIndexes);
    const wholeGroupSelected = Array.from(installationIds).some((id) => {
        const group = groups.get(id);
        return group && group.size > 1 && Array.from(group).every((idx) => selectedSitesIndexSet.has(idx));
    });
    return [firstUninstall, secondUninstall, wholeGroupSelected];
};
exports.getInstallationsFromSelection = getInstallationsFromSelection;
const getInstallationContext = (installation, product) => {
    let context;
    if (product === installation.product) {
        context = installation.context;
    }
    else {
        const secondaryIndex = installation.secondaryProducts?.indexOf(product.toLowerCase()) ?? -1;
        context = installation.secondaryContexts?.at(secondaryIndex) ?? installation.context;
    }
    if (!context) {
        throw new cli_shared_1.UserError(cli_shared_1.Text.installList.noInstallations);
    }
    return context;
};
exports.getInstallationContext = getInstallationContext;
const performSingleUninstall = async (installId, installationContext, { ui, commands: { uninstallAppCommand } }) => {
    const installation = await ui.displayProgress(() => uninstallAppCommand.execute(installId, installationContext), cli_shared_1.Text.uninstall.cmd.start, (result) => ({
        successful: !!result.successful,
        message: cli_shared_1.Text.uninstall.cmd.success(false)
    }));
    const uninstallMessageFormat = installation.successful ? cli_shared_1.Text.uninstall.done : cli_shared_1.Text.uninstall.failed;
    const uninstallMessage = uninstallMessageFormat((0, cli_shared_1.productDisplayName)((0, cli_shared_1.parseInstallationContext)(installationContext).resourceOwner), installation.site, installation.environmentKey, false);
    if (installation.successful) {
        ui.info(uninstallMessage);
    }
    else {
        ui.error(new shared_1.UninstallAppError(uninstallMessage));
    }
};
exports.performSingleUninstall = performSingleUninstall;
const performMultipleUninstalls = async (appsToUninstallFirst, appsToUninstallSecond, { ui, commands: { uninstallAppCommand } }) => {
    const filteredInstallations = appsToUninstallFirst.filter(({ product }) => product !== 'identity');
    const hasMultipleNonIdentityApps = filteredInstallations.length > 1;
    const uninstalledApps = await ui.displayProgress(async () => {
        const result1 = await uninstallAppCommand.batchExecute([], appsToUninstallFirst);
        if (result1.some(({ successful }) => successful === false)) {
            return result1;
        }
        const result2 = await uninstallAppCommand.batchExecute([], appsToUninstallSecond);
        return result1.concat(result2);
    }, cli_shared_1.Text.uninstall.cmd.start, (result) => {
        const isSuccessful = !result.some(({ successful }) => successful === false);
        return {
            successful: isSuccessful,
            message: cli_shared_1.Text.uninstall.cmd.success(hasMultipleNonIdentityApps)
        };
    });
    const deferredErrors = [];
    uninstalledApps.forEach((uninstall) => {
        const uninstallMessageFormat = uninstall.successful ? cli_shared_1.Text.uninstall.done : cli_shared_1.Text.uninstall.failed;
        const formattedMessage = uninstallMessageFormat((0, cli_shared_1.productDisplayName)(uninstall.product), uninstall.site, uninstall.environmentKey, hasMultipleNonIdentityApps);
        if (uninstall.successful && uninstall.product !== 'identity') {
            ui.info(formattedMessage);
        }
        else if (!uninstall.successful) {
            const uninstallError = new shared_1.UninstallAppError(formattedMessage);
            ui.error(uninstallError);
            deferredErrors.push(uninstallError);
        }
    });
    if (uninstalledApps.some(({ successful }) => successful === false)) {
        throw new errors_1.DeferredErrors(deferredErrors);
    }
    if (hasMultipleNonIdentityApps) {
        ui.info(cli_shared_1.Text.uninstall.interactive.done);
    }
};
exports.performMultipleUninstalls = performMultipleUninstalls;
//# sourceMappingURL=uninstall-command-helpers.js.map