"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionView = exports.getDetailsTable = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@forge/cli-shared");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const getDetailsTable = ({ formatKeyValueList, formatYamlProperties }, details) => {
    const deploymentDate = (date) => `${date.toISOString()}`;
    const scopes = (scopes) => `${(0, cli_shared_1.itemList)(scopes, '')}`;
    const egress = (egresses) => {
        const egressItems = egresses.map((egress) => ({
            key: egress.type,
            value: (0, cli_shared_1.itemList)(egress.addresses, ' ')
        }));
        return formatKeyValueList(egressItems, '', true);
    };
    const analytics = (analytics) => {
        const functionItems = analytics.map((analytic) => {
            const properties = {
                addresses: analytic.addresses,
                inScopeEUD: analytic.inScopeEUD
            };
            return formatYamlProperties(properties, analytic.type, false);
        });
        return (0, cli_shared_1.itemList)(functionItems, '');
    };
    const securityPolicies = (policies) => {
        const policyItems = policies.map((policy) => ({
            key: policy.type,
            value: policy.policies.join(', ')
        }));
        return formatKeyValueList(policyItems);
    };
    const connectKeys = (keys) => {
        const keyItems = keys.map((key) => ({
            key: key.product,
            value: key.key
        }));
        return formatKeyValueList(keyItems, '');
    };
    const functions = (functions) => {
        const functionItems = functions.map((func) => {
            const properties = {
                runtime: func.runtimeName,
                handler: func.handler
            };
            return formatYamlProperties(properties, func.key);
        });
        return (0, cli_shared_1.itemList)(functionItems, '');
    };
    const modules = (modules) => {
        return modules
            .map((mod) => {
            const items = mod.items.map((item) => formatYamlProperties(item.properties, item.key));
            return `${chalk_1.default.bold(mod.type)}\n${(0, cli_shared_1.itemList)(items, '')}`;
        })
            .join('\n');
    };
    const remotes = (remotes) => {
        const remoteItems = remotes.map((remote) => {
            const properties = {
                baseUrl: remote.baseUrl,
                operations: remote.operations
            };
            return formatYamlProperties(properties, remote.key);
        });
        return (0, cli_shared_1.itemList)(remoteItems, '');
    };
    const tableData = [
        {
            entry: 'deployment date',
            detailsFn: deploymentDate,
            property: 'deploymentDateTime'
        },
        {
            entry: 'functions',
            detailsFn: functions,
            property: 'functions'
        },
        {
            entry: 'modules',
            detailsFn: modules,
            property: 'modules'
        },
        {
            entry: 'license',
            detailsFn: cli_shared_1.Text.version.check.details.license,
            property: 'requiresLicense'
        },
        {
            entry: 'scopes',
            detailsFn: scopes,
            property: 'scopes'
        },
        {
            entry: 'egress',
            detailsFn: egress,
            property: 'egresses'
        },
        {
            entry: 'analytics',
            detailsFn: analytics,
            property: 'analytics'
        },
        {
            entry: 'policies',
            detailsFn: securityPolicies,
            property: 'policies'
        },
        {
            entry: 'connect keys',
            detailsFn: connectKeys,
            property: 'connectKeys'
        },
        {
            entry: 'remotes',
            detailsFn: remotes,
            property: 'remotes'
        }
    ];
    return tableData
        .filter(({ property }) => details[property] !== undefined)
        .map(({ entry, detailsFn, property }) => ({
        entry,
        details: detailsFn(details[property]),
        property
    }));
};
exports.getDetailsTable = getDetailsTable;
const getPropertySummary = (property) => {
    return property.map((item) => `${item.type}: ${item.count}`).join('\n');
};
const getRolloutStatus = (status) => {
    switch (status) {
        case 'COMPLETE':
            return 'Completed';
        case 'RUNNING':
            return 'In progress';
        case 'CANCELLED':
            return 'Cancelled';
        default:
            return 'Unknown';
    }
};
class VersionView {
    ui;
    constructor(ui) {
        this.ui = ui;
    }
    async displayDetailsProgress(progress) {
        return this.ui.displayProgress(progress, cli_shared_1.Text.version.check.start, cli_shared_1.Text.version.check.end);
    }
    async displayDiffProgress(progress) {
        return this.ui.displayProgress(progress, cli_shared_1.Text.version.diff.start, cli_shared_1.Text.version.diff.end);
    }
    async displayListProgress(progress) {
        return this.ui.displayProgress(progress, cli_shared_1.Text.version.list.start, cli_shared_1.Text.version.list.end);
    }
    async displayBulkUpgradeListProgress(progress) {
        return this.ui.displayProgress(progress, cli_shared_1.Text.version.upgrade.list.start, cli_shared_1.Text.version.upgrade.list.end);
    }
    async displaySingleSelectVersion(columns, versions, versionTablePrompt, versionTableOverview) {
        return await this.ui.promptForSingleChoiceTable(versionTablePrompt, versionTableOverview ?? '', columns, versions);
    }
    displayInfo(message) {
        this.ui.info(message);
    }
    displayAppVersionRolloutCreationSuccess(appRolloutVersionId) {
        this.ui.emptyLine();
        this.ui.info(cli_shared_1.Text.version.upgrade.start.appVersionRolloutSuccess(appRolloutVersionId));
    }
    displayAppVersionRolloutCancelCreationSuccess(appRolloutId) {
        this.ui.emptyLine();
        this.ui.info(cli_shared_1.Text.version.upgrade.cancel.appVersionRolloutCancelSuccess(appRolloutId));
    }
    displayAppVersionRolloutCancelNotInProgress(environmentKey) {
        this.ui.emptyLine();
        this.ui.error(new Error(cli_shared_1.Text.version.upgrade.cancel.error.noUpdateInProgress(environmentKey)));
    }
    async confirmAppVersionRolloutCreation(sourceVersionId, targetVersionId, installations) {
        this.ui.emptyLine();
        this.ui.warn(cli_shared_1.Text.version.upgrade.start.warningMessage(sourceVersionId, targetVersionId, installations));
        return this.ui.confirm(cli_shared_1.Text.version.upgrade.start.promptConfirmation);
    }
    async confirmAppVersionRolloutCancel(appRolloutId, sourceVersionId, targetVersionId, installationComplete, totalInstallations) {
        this.ui.emptyLine();
        this.ui.warn(cli_shared_1.Text.version.upgrade.cancel.warningMessage(appRolloutId, sourceVersionId, targetVersionId, installationComplete, totalInstallations));
        return this.ui.confirm(cli_shared_1.Text.version.upgrade.cancel.promptConfirmation);
    }
    async promptVersionDetailsProperties() {
        const { options, properties: { descriptions, banner, info, headers } } = cli_shared_1.Text.version.check.details.prompt;
        const propsOptions = [
            {
                names: ['License', descriptions.license],
                property: 'requiresLicense'
            },
            {
                names: ['Scopes', descriptions.scopes],
                property: 'scopes'
            },
            {
                names: ['Egress', descriptions.egress],
                property: 'egresses'
            },
            {
                names: ['Analytics', descriptions.analytics],
                property: 'analytics'
            },
            {
                names: ['Policies', descriptions.policies],
                property: 'policies'
            },
            {
                names: ['Connect Key', descriptions.connectKeys],
                property: 'connectKeys'
            },
            {
                names: ['Functions', descriptions.functions],
                property: 'functions'
            },
            {
                names: ['Modules', descriptions.modules],
                property: 'modules'
            },
            {
                names: ['Remotes', descriptions.remotes],
                property: 'remotes'
            }
        ];
        const allOrNot = await this.ui.promptForList(options.banner, [options.choices.all, options.choices.manual]);
        if (allOrNot === options.choices.manual) {
            const choices = await this.ui.promptForTable(banner, info, headers, propsOptions);
            return choices.map((index) => propsOptions[index].property);
        }
        return [];
    }
    displayVersionDetailsBanner(appVersion, envKey, envType) {
        this.ui.emptyLine();
        this.ui.info(cli_shared_1.Text.version.check.details.banner(envKey, envType, appVersion));
        this.ui.emptyLine();
    }
    displayDetailsAsTable(details) {
        const tableData = [...(0, exports.getDetailsTable)(this.ui, details)].sort((a, b) => a.entry.localeCompare(b.entry));
        this.ui.table([
            ['entry', 'Property'],
            ['details', 'Details']
        ], tableData);
    }
    displayDataInJson(data) {
        this.ui.info(JSON.stringify(data, null, 2));
    }
    displayDiffBanner(version1, version2, env1Key, env1Type, env2Key = undefined, env2Type = undefined) {
        this.ui.emptyLine();
        this.ui.info(cli_shared_1.Text.version.diff.details.banner({ env1Key, env1Type, version1, version2, env2Key, env2Type }));
        this.ui.emptyLine();
    }
    displayDiffAsTable(versions, input) {
        this.ui.table([
            ['entry', 'Property'],
            ['v1', `Version ${versions.v1}.x [${versions.e1}]`],
            ['v2', `Version ${versions.v2}.x [${versions.e2}]`]
        ], input
            .filter(({ diff }) => diff.filter((change) => change.added || change.removed).length > 0)
            .map(({ key, diff }) => ({
            entry: key,
            v1: diff
                .filter((change) => !change.added)
                .map((change) => {
                if (!change.removed) {
                    return chalk_1.default.gray(change.value);
                }
                return change.value;
            })
                .join(''),
            v2: diff
                .filter((change) => !change.removed)
                .map((change) => {
                if (!change.added) {
                    return chalk_1.default.gray(change.value);
                }
                return change.value;
            })
                .join('')
        }))
            .sort((a, b) => a.entry.localeCompare(b.entry)));
    }
    displayListBanner(versions, envKey, envType) {
        this.ui.emptyLine();
        this.ui.info(cli_shared_1.Text.version.list.details.banner(envKey, envType, versions));
        this.ui.emptyLine();
    }
    displayBulkUpgradeListBanner(versions, envKey, envType) {
        this.ui.emptyLine();
        this.ui.info(cli_shared_1.Text.version.upgrade.list.details.banner(envKey, envType, versions));
        this.ui.emptyLine();
    }
    displayWriteToFile(outFile) {
        this.ui.info(cli_shared_1.Text.version.check.details.writeToFile(outFile));
    }
    displayBulkUpgradeList(data) {
        this.ui.table([
            ['id', 'Upgrade ID'],
            ['status', 'Status'],
            ['createdAt', 'Started'],
            ['completedAt', 'Completed'],
            ['sourceVersionId', 'From version'],
            ['targetVersionId', 'To version'],
            ['completedCount', 'Completed'],
            ['pendingCount', 'Pending'],
            ['failedCount', 'Failed']
        ], data.map(({ id, status, createdAt, completedAt, sourceVersionId, targetVersionId, completedUpgradeCount, pendingUpgradeCount, failedUpgradeCount }) => ({
            id,
            status: getRolloutStatus(status),
            createdAt: createdAt,
            completedAt: completedAt,
            sourceVersionId,
            targetVersionId,
            completedCount: completedUpgradeCount.toString(),
            pendingCount: pendingUpgradeCount.toString(),
            failedCount: failedUpgradeCount.toString()
        })));
    }
    displayVersionList(data) {
        this.ui.table([
            ['version', 'Major Versions'],
            ['deploymentDate', 'Deployment Date'],
            ['egresses', 'Egress'],
            ['analytics', 'Analytics'],
            ['policies', 'Policies'],
            ['scopes', 'Scopes'],
            ['connectKeys', 'Connect keys'],
            ['functions', 'Functions'],
            ['remotes', 'Remotes'],
            ['modules', 'Modules'],
            ['requiresLicense', 'License']
        ], data.map(({ version, egresses, analytics, modules, policies, deploymentDateTime, ...rest }) => ({
            ...rest,
            version: version.toString(),
            deploymentDate: deploymentDateTime.toISOString(),
            egresses: getPropertySummary(egresses),
            analytics: getPropertySummary(analytics),
            policies: getPropertySummary(policies),
            modules: getPropertySummary(modules)
        })));
    }
}
exports.VersionView = VersionView;
//# sourceMappingURL=version-view.js.map