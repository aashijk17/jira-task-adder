"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstallationsGraphqlClient = exports.InstallationNotFoundError = exports.MissingAppUninstallTask = exports.MissingAppEnvironmentError = exports.MissingAppError = exports.InstallationRequestFailedError = exports.MissingTaskIdError = exports.EnvironmentNotFoundError = exports.UpgradeError = exports.InstallationError = exports.AlreadyInstalledError = exports.PermissionDeniedError = exports.ALREADY_UPGRADED_CODE = exports.UNINSTALLATION_EVENT_POLL_INTERVAL = void 0;
const exponential_backoff_1 = require("exponential-backoff");
const ari_1 = require("@forge/util/packages/ari");
const cli_shared_1 = require("@forge/cli-shared");
const harmonized_app_installation_errors_1 = require("./harmonized-apps/harmonized-app-installation-errors");
exports.UNINSTALLATION_EVENT_POLL_INTERVAL = 500;
exports.ALREADY_UPGRADED_CODE = 'INSTALLATION_ALREADY_UPGRADED';
const ALREADY_INSTALLED_CODE = 'APP_ALREADY_INSTALLED';
const PERMISSION_DENIED = 'PERMISSION_DENIED';
class PermissionDeniedError extends cli_shared_1.GraphQlMutationError {
    constructor(requestId = 'unknown', appId = 'unknown', statusCode) {
        super(cli_shared_1.Text.install.error.permissionsDeniedInstructions(requestId, appId), {
            requestId,
            code: PERMISSION_DENIED,
            statusCode
        });
    }
}
exports.PermissionDeniedError = PermissionDeniedError;
class AlreadyInstalledError extends cli_shared_1.GraphQlMutationError {
    hasMajorVersion;
    environment;
    environmentType;
    constructor(requestId, statusCode, hasMajorVersion, environment, environmentType) {
        const message = hasMajorVersion && environment && environmentType
            ? cli_shared_1.Text.install.error.alreadyInstalledErrorWithMajorVersion(environment, environmentType)
            : cli_shared_1.Text.install.error.alreadyInstalledError;
        super(message, { requestId, code: ALREADY_INSTALLED_CODE, statusCode });
        this.hasMajorVersion = hasMajorVersion;
        this.environment = environment;
        this.environmentType = environmentType;
    }
}
exports.AlreadyInstalledError = AlreadyInstalledError;
class InstallationError extends cli_shared_1.GraphQlMutationError {
    constructor(message, { requestId, code, statusCode }) {
        super(cli_shared_1.Text.install.error.serverSideInstallationError(message), { requestId, code, statusCode });
    }
}
exports.InstallationError = InstallationError;
class UpgradeError extends cli_shared_1.GraphQlMutationError {
    constructor(message, { requestId, code, statusCode }) {
        super(cli_shared_1.Text.upgrade.error.serverSideInstallationError(message), { requestId, code, statusCode });
    }
}
exports.UpgradeError = UpgradeError;
class EnvironmentNotFoundError extends cli_shared_1.UserError {
    constructor(environmentKey) {
        super(cli_shared_1.Text.env.error.envNotExist(environmentKey));
    }
}
exports.EnvironmentNotFoundError = EnvironmentNotFoundError;
class MissingTaskIdError extends Error {
}
exports.MissingTaskIdError = MissingTaskIdError;
class InstallationRequestFailedError extends cli_shared_1.BaseError {
    userError;
    code;
    constructor(userError, code, message, requestId) {
        super(requestId, message);
        this.userError = userError;
        this.code = code;
    }
    isUserError() {
        return this.userError;
    }
}
exports.InstallationRequestFailedError = InstallationRequestFailedError;
class MissingAppError extends cli_shared_1.UserError {
}
exports.MissingAppError = MissingAppError;
class MissingAppEnvironmentError extends Error {
}
exports.MissingAppEnvironmentError = MissingAppEnvironmentError;
class MissingAppUninstallTask extends Error {
}
exports.MissingAppUninstallTask = MissingAppUninstallTask;
class InstallationNotFoundError extends cli_shared_1.UserError {
}
exports.InstallationNotFoundError = InstallationNotFoundError;
class InstallationsGraphqlClient {
    graphqlClient;
    sitedProductTranslator;
    bitbucketTranslator;
    pause;
    SITE_RESOURCE_TYPE = 'site';
    WORKSPACE_RESOURCE_TYPE = 'workspace';
    static buildInstallationContext(product, resourceId, resourceType) {
        const ari = ari_1.AnyAri.create({
            resourceOwner: (0, cli_shared_1.ariResourceOwner)(product),
            resourceType: resourceType,
            resourceId: resourceId
        });
        return ari.toString();
    }
    constructor(graphqlClient, sitedProductTranslator, bitbucketTranslator, pause) {
        this.graphqlClient = graphqlClient;
        this.sitedProductTranslator = sitedProductTranslator;
        this.bitbucketTranslator = bitbucketTranslator;
        this.pause = pause;
    }
    async buildInstallationContext(product, site) {
        const ari = await this.getProductTranslation(product).buildInstallationContext(product, site);
        return ari.toString();
    }
    getProductTranslation(product) {
        if (product && (0, cli_shared_1.isBitbucketProduct)(product)) {
            return this.bitbucketTranslator;
        }
        return this.sitedProductTranslator;
    }
    async installAppIntoSite({ environmentKey, site, product, appId, licenseOverride, overrides, majorVersionId, environmentType }) {
        const workspaceAri = await this.buildInstallationContext(product, site);
        const query = `
      mutation forge_cli_installApplication($input: AppInstallationInput!) {
        installApp(input: $input) {
          success
          taskId
          errors {
            message
            extensions {
              errorType
              statusCode
            }
          }
        }
      }
    `;
        const variables = {
            input: {
                installationContext: workspaceAri,
                appId,
                environmentKey,
                async: true,
                licenseOverride,
                overrides,
                ...(majorVersionId ? { versionId: majorVersionId } : {})
            }
        };
        const { response: { installApp: { success, taskId, errors } }, requestId } = await this.graphqlClient.mutate(query, variables);
        const error = (0, cli_shared_1.getError)(errors);
        if (!success) {
            if (error.code === PERMISSION_DENIED) {
                throw new PermissionDeniedError(requestId, ari_1.AnyAri.parse(appId).resourceId, error.statusCode);
            }
            throw new InstallationError(`${error.message} (requestId: ${requestId || 'unknown'})`, {
                requestId,
                code: error.code,
                statusCode: error.statusCode
            });
        }
        if (!taskId) {
            throw new MissingTaskIdError(error.message);
        }
        await this.monitorAppInstallOrUpgrade(taskId, !!majorVersionId, environmentKey, environmentType);
    }
    async getEntitlementOffering(site, product) {
        try {
            const productKeys = this.getHamsProductKeys(product);
            const results = await Promise.allSettled(productKeys.map((productKey) => this.graphqlClient.query(`query getEntitlementOffering($hostNames: [String!], $product: String!) {
              tenantContexts(hostNames: $hostNames) {
                cloudUrl
                entitlementInfo(hamsProductKey: $product) {
                  entitlement {
                    ... on HamsEntitlement {
                        id
                        name
                        currentEdition
                      }
                    ... on CcpEntitlement {
                      id
                      offering {
                        name
                      }
                    }
                  }
                }
              }
            }`, {
                hostNames: [site.hostname],
                product: productKey
            })));
            for (const result of results) {
                if (result.status === 'fulfilled') {
                    const data = result.value;
                    return data.tenantContexts?.[0]?.entitlementInfo?.entitlement;
                }
            }
            return undefined;
        }
        catch (error) {
            return undefined;
        }
    }
    getHamsProductKeys(product) {
        switch (product) {
            case 'Jira':
                return [
                    'jira-software.ondemand',
                    'jira-core.ondemand',
                    'jira-servicedesk.ondemand',
                    'jira-product-discovery.ondemand'
                ];
            case 'Confluence':
                return ['confluence.ondemand'];
            case 'Compass':
                return ['compass'];
            case 'Atlas':
                return ['townsquare'];
            default:
                throw new Error('Unsupported product');
        }
    }
    async upgradeInstallation({ site, product, environmentKey, appId, majorVersionId }) {
        const workspaceAri = await this.buildInstallationContext(product, site);
        const query = `
      mutation forge_cli_upgradeApplication($input: AppInstallationUpgradeInput!) {
        upgradeApp(input: $input) {
          success
          taskId
          errors {
            message
            extensions {
              errorType
              statusCode
            }
          }
        }
      }
    `;
        const variables = {
            input: {
                installationContext: workspaceAri,
                appId,
                environmentKey,
                async: true
            }
        };
        const { response: { upgradeApp: { success, errors, taskId } }, requestId } = await this.graphqlClient.mutate(query, variables);
        const error = (0, cli_shared_1.getError)(errors);
        if (!success) {
            throw new UpgradeError(`${error.message} (requestId: ${requestId || 'unknown'})`, {
                requestId,
                code: error.code,
                statusCode: error.statusCode
            });
        }
        if (!taskId) {
            throw new MissingTaskIdError(error.message);
        }
        await this.monitorAppInstallOrUpgrade(taskId, !!majorVersionId, environmentKey);
    }
    async monitorAppInstallOrUpgrade(taskId, hasMajorVersion, environment, environmentType) {
        let status = cli_shared_1.AppTaskState.Pending;
        while (status !== cli_shared_1.AppTaskState.Complete) {
            const result = await this.getAppInstallationTaskRetry(taskId);
            status = result.state;
            if (status === cli_shared_1.AppTaskState.Failed) {
                this.handleFailedInstallOrUpgrade(result, hasMajorVersion, environment, environmentType);
            }
            if (status !== cli_shared_1.AppTaskState.Complete)
                await this.pause(exports.UNINSTALLATION_EVENT_POLL_INTERVAL);
        }
    }
    handleFailedInstallOrUpgrade(result, hasMajorVersion, environment, environmentType) {
        const { errors, requestId } = result;
        const error = errors?.[0];
        const statusCode = error?.extensions?.statusCode;
        const isUserError = statusCode && statusCode >= 400 && statusCode < 500 ? true : false;
        const code = error?.extensions?.errorType ?? undefined;
        if (code === ALREADY_INSTALLED_CODE) {
            throw new AlreadyInstalledError(requestId, statusCode ?? undefined, hasMajorVersion, environment, environmentType);
        }
        if (error && requestId) {
            error.message = cli_shared_1.Text.install.error.appendRequestIdToErrorMessage(error.message ?? undefined, requestId);
        }
        throw new InstallationRequestFailedError(isUserError, code, (0, harmonized_app_installation_errors_1.expandHarmonizedAppInstallationError)(code, error?.message ?? undefined), requestId);
    }
    async uninstallApp(input) {
        const query = `
      mutation forge_cli_uninstallApplication($input: AppUninstallationInput!) {
        uninstallApp(input: $input) {
          success
          taskId
          errors {
            message
            extensions {
              errorType
              statusCode
            }
          }
        }
      }
    `;
        const { response: { uninstallApp: { success, errors, taskId } }, requestId } = await this.graphqlClient.mutate(query, { input });
        const error = (0, cli_shared_1.getError)(errors);
        if (!success) {
            throw new cli_shared_1.GraphQlMutationError(`${error.message} (requestId: ${requestId || 'unknown'})`, {
                requestId,
                code: error.code,
                statusCode: error.statusCode
            });
        }
        return this.monitorUninstallApp(taskId);
    }
    async uninstallMultipleApps(apps) {
        const uninstallsResult = [];
        for (const app of apps) {
            try {
                const [success] = await Promise.all([
                    this.uninstallApp(app),
                    new Promise((resolve) => setTimeout(resolve, 1000))
                ]);
                uninstallsResult.push({ ...app, successful: success });
            }
            catch (err) {
                uninstallsResult.push({ ...app, successful: false });
            }
        }
        return uninstallsResult;
    }
    async listInstallations(appId, installationFilterOptions) {
        const installations = await this.getAllInstallations(appId, installationFilterOptions);
        return await this.resolveInstallationsHostnames(installations);
    }
    async getInstallation(appId, installationId) {
        const installations = await this.listInstallations(appId, { installationId });
        const matchedInstallation = installations.find(({ id }) => id === installationId);
        if (matchedInstallation) {
            return matchedInstallation;
        }
        throw new InstallationNotFoundError(cli_shared_1.Text.installationId.errors.notFound(installationId));
    }
    async hasNoAppInstallationsForEnv(appId, appEnv) {
        const query = `
      query forge_cli_hasNoAppInstallationsForEnv($filter: AppInstallationsByAppFilter!) {
        ecosystem {
          appInstallationsByApp(filter: $filter, first: 1) {
            totalCount
          }
        }
      }
    `;
        const result = (await this.graphqlClient.query(query, {
            filter: {
                apps: {
                    ids: [appId]
                },
                appEnvironments: {
                    types: [appEnv]
                }
            }
        }));
        const totalCount = result?.ecosystem?.appInstallationsByApp?.totalCount ?? -1;
        if (totalCount < 0) {
            throw new MissingAppError();
        }
        return totalCount === 0;
    }
    async getAppInstallationTask(taskId) {
        const query = `
      query forge_cli_getInstallationTask($id: ID!) {
        appInstallationTask(id: $id) {
          state
          errors {
            message
            extensions {
              errorType
              statusCode
            }
          }
        }
      }
    `;
        const { appInstallationTask, requestId } = await this.graphqlClient.query(query, {
            id: taskId
        });
        if (!appInstallationTask) {
            throw new MissingAppUninstallTask(cli_shared_1.Text.uninstall.missingUninstallTask);
        }
        const { state, errors } = appInstallationTask;
        return {
            errors,
            state,
            requestId
        };
    }
    async getAppInstallationTaskRetry(taskId) {
        return (0, exponential_backoff_1.backOff)(() => this.getAppInstallationTask(taskId), {
            startingDelay: 5000,
            numOfAttempts: 40,
            maxDelay: 20000,
            jitter: 'full',
            retry: (e) => e instanceof cli_shared_1.GraphQLProviderServiceError && e.getCode() === 'TOO_MANY_REQUESTS'
        });
    }
    async monitorUninstallApp(taskId) {
        let status = cli_shared_1.AppTaskState.Pending;
        while (status !== cli_shared_1.AppTaskState.Complete) {
            const { state } = await this.getAppInstallationTaskRetry(taskId);
            status = state;
            if (status === cli_shared_1.AppTaskState.Failed) {
                return false;
            }
            if (status !== cli_shared_1.AppTaskState.Complete)
                await this.pause(exports.UNINSTALLATION_EVENT_POLL_INTERVAL);
        }
        return true;
    }
    getResourceArisForProduct(installationContexts, condition) {
        return [...new Set(installationContexts.filter((context) => condition(context)))];
    }
    async getCombinedHostnameMap(installationContexts) {
        const bitbucketAris = this.getResourceArisForProduct(installationContexts, this.bitbucketTranslator.ariBelongsToProduct);
        const cloudIdAris = this.getResourceArisForProduct(installationContexts, this.sitedProductTranslator.ariBelongsToProduct);
        const [siteAriToHostname, bbWorkspaceAriToHostname] = await Promise.all([
            this.sitedProductTranslator.getSitesForResourceAris(cloudIdAris),
            this.bitbucketTranslator.getSitesForResourceAris(bitbucketAris)
        ]);
        const combinedAriToHostname = {
            ...siteAriToHostname,
            ...bbWorkspaceAriToHostname
        };
        return combinedAriToHostname;
    }
    async resolveInstallationsHostnames(installations) {
        if (!installations.length) {
            return [];
        }
        const installationContexts = installations.map(({ installation }) => (0, cli_shared_1.parseInstallationContext)(installation.installationContext));
        const combinedAriToHostname = await this.getCombinedHostnameMap(installationContexts);
        return installationContexts.map((context, i) => {
            const { environment, environmentType, installation } = installations[i];
            const site = combinedAriToHostname[context.toString()];
            const secondaryProducts = (installation.secondaryInstallationContexts ?? [])
                .map((context) => (0, cli_shared_1.parseInstallationContext)(context))
                .map((context) => context.resourceOwner);
            const permissions = installation.appEnvironmentVersion?.permissions || [];
            const appEnvironmentVersion = {
                isLatest: installation.appEnvironmentVersion?.isLatest ?? false,
                version: installation.appEnvironmentVersion?.version ?? '1.0.0',
                scopes: permissions.flatMap((permission) => permission.scopes.map((scope) => scope.key))
            };
            return {
                id: installation.id,
                ...(secondaryProducts.length > 0 ? { secondaryProducts } : {}),
                product: context.resourceOwner,
                environmentKey: environment,
                environmentType,
                context: installation.installationContext,
                ...(installation.secondaryInstallationContexts?.length
                    ? { secondaryContexts: installation.secondaryInstallationContexts }
                    : {}),
                site,
                version: appEnvironmentVersion
            };
        });
    }
    async getAllInstallations(appId, installationFilterOptions) {
        const query = `
      query forge_cli_getEcosystemInstallationsByApp($filter: AppInstallationsByAppFilter!, $first: Int, $after: String) {
        ecosystem {
          appInstallationsByApp(filter: $filter, first: $first, after: $after) {
            nodes {
              id
              installationContext
              secondaryInstallationContexts
              appEnvironment {
                key
                type
              }
              appEnvironmentVersion {
                isLatest
                version
                permissions {
                  scopes {
                    key
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }
      }
    `;
        const output = [];
        let cursor = undefined;
        let hasNext = undefined;
        do {
            const filter = await InstallationsGraphqlClient.buildInstallationsFilter(appId, installationFilterOptions, this.buildInstallationContext.bind(this));
            const result = (await this.graphqlClient.query(query, {
                filter,
                first: 100,
                after: cursor
            }));
            if (!result?.ecosystem?.appInstallationsByApp?.nodes) {
                throw new MissingAppError();
            }
            const { nodes, pageInfo } = result.ecosystem.appInstallationsByApp;
            for (const node of nodes) {
                if (node) {
                    if (!node.appEnvironment) {
                        throw new MissingAppEnvironmentError();
                    }
                    output.push({
                        environment: node.appEnvironment.key,
                        environmentType: node.appEnvironment.type,
                        installation: node
                    });
                }
            }
            cursor = pageInfo.endCursor;
            hasNext = pageInfo.hasNextPage;
        } while (hasNext && cursor);
        return output;
    }
    static async buildInstallationsFilter(appId, installationFilterOptions, buildInstallationContext) {
        const filter = {
            apps: {
                ids: [appId]
            }
        };
        if (installationFilterOptions?.environment) {
            filter.appEnvironments = { types: [(0, cli_shared_1.guessEnvironmentType)(installationFilterOptions.environment)] };
        }
        if (installationFilterOptions?.site && installationFilterOptions?.product) {
            const workspaceAri = await buildInstallationContext(installationFilterOptions.product, installationFilterOptions.site);
            filter.appInstallations = { contexts: [workspaceAri] };
        }
        if (installationFilterOptions?.installationId) {
            filter.appInstallations = {
                ...filter.appInstallations,
                ids: [installationFilterOptions.installationId]
            };
        }
        return filter;
    }
    async getVersions(appId, environmentKey, firstN = 1) {
        const query = `
      query forge_cli_getApplicationEnvironmentLatestVersions($appId: ID!, $environmentKey: String!, $firstN: Int!) {
        app(id: $appId) {
          environmentByKey(key: $environmentKey) {
            type
            versions(first: $firstN) {
              nodes {
                requiredProducts
                permissions {
                  egress {
                    addresses
                  }
                  scopes {
                    key
                  }
                }
              }
            }
          }
        }
      }
    `;
        const result = await this.graphqlClient.query(query, {
            appId,
            environmentKey,
            firstN
        });
        if (!result.app) {
            throw new MissingAppError();
        }
        if (!result.app.environmentByKey) {
            throw new EnvironmentNotFoundError(environmentKey);
        }
        return {
            nodes: result.app.environmentByKey.versions?.nodes,
            environmentType: result.app.environmentByKey.type
        };
    }
    async getVersionByMajorVersionId(id, environmentKey, majorVersion) {
        if (!majorVersion) {
            return undefined;
        }
        const query = `
      query forge_cli_getApplicationVersionList($id: ID!, $environmentKey: String!, $majorVersion: Int!) {
        app(id: $id) {
          environmentByKey(key: $environmentKey) {
            type
            versions(majorVersion: $majorVersion) {
              nodes {
                id
                version
                isLatest
                requiredProducts
                permissions {
                  egress {
                    addresses
                  }
                  scopes {
                    key
                  }
                }
              }
            }
          }
        }
      }`;
        const variables = {
            id,
            environmentKey,
            majorVersion
        };
        const { app } = await this.graphqlClient.query(query, variables);
        if (!app) {
            throw new MissingAppError();
        }
        if (!app.environmentByKey) {
            throw new EnvironmentNotFoundError(environmentKey);
        }
        if (!app.environmentByKey.versions?.nodes?.length) {
            return undefined;
        }
        return {
            nodes: app.environmentByKey.versions.nodes,
            environmentType: app.environmentByKey.type
        };
    }
}
exports.InstallationsGraphqlClient = InstallationsGraphqlClient;
//# sourceMappingURL=graphql-client.js.map