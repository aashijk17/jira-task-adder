"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SitedProductTranslator = exports.ActivationIdMissingError = exports.InvalidAtlassianSiteError = exports.GRAPH_PRODUCT_ID_IN_TCS = void 0;
const cli_shared_1 = require("@forge/cli-shared");
exports.GRAPH_PRODUCT_ID_IN_TCS = 'devops';
const PRODUCT_RESOURCE_OWNER_TO_TCS_PRODUCT_ID = {
    graph: exports.GRAPH_PRODUCT_ID_IN_TCS
};
const NON_SITED_PRODUCTS_USING_WORKSPACE_ARI = [cli_shared_1.TRELLO_RESOURCE_OWNER, cli_shared_1.BITBUCKET_RESOURCE_OWNER];
class InvalidAtlassianSiteError extends cli_shared_1.UserError {
    constructor(url) {
        super(cli_shared_1.Text.install.error.invalidAtlassianSite(url));
    }
}
exports.InvalidAtlassianSiteError = InvalidAtlassianSiteError;
class ActivationIdMissingError extends Error {
    constructor(url, product) {
        super(cli_shared_1.Text.install.error.activationIdMissing(url, product));
    }
}
exports.ActivationIdMissingError = ActivationIdMissingError;
function removeDuplicatedAris(aris) {
    return Array.from(new Map(aris.map((ari) => [ari.toString(), ari])).values());
}
const tenantContextsToCloudIdAndActivationId = (url, contexts, productResourceOwner) => {
    if (!contexts.length) {
        throw new InvalidAtlassianSiteError(url);
    }
    const context = contexts[0];
    if (!context || !context.cloudId) {
        throw new InvalidAtlassianSiteError(url);
    }
    const activationId = context.activationIdByProduct?.active;
    if (!activationId) {
        throw new ActivationIdMissingError(url.toString(), (0, cli_shared_1.productDisplayName)(productResourceOwner));
    }
    return { cloudId: context.cloudId, activationId: activationId };
};
function splitArrayToChunks(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
}
class SitedProductTranslator {
    graphqlClient;
    constructor(graphqlClient) {
        this.graphqlClient = graphqlClient;
    }
    ariBelongsToProduct(ari) {
        return (ari.resourceType === cli_shared_1.SITE_RESOURCE_TYPE ||
            (ari.resourceType === cli_shared_1.WORKSPACE_RESOURCE_TYPE &&
                !NON_SITED_PRODUCTS_USING_WORKSPACE_ARI.includes(ari.resourceOwner)));
    }
    async buildInstallationContext(product, site) {
        const productResourceOwner = (0, cli_shared_1.ariResourceOwner)(product);
        const { cloudId, activationId } = await this.getCloudIdAndActivationId(site, productResourceOwner);
        const workspaceAriCreator = cli_shared_1.createWorkspaceAriByProduct[productResourceOwner];
        return workspaceAriCreator(cloudId, activationId);
    }
    async getSitesForResourceAris(aris) {
        const uniqueAris = removeDuplicatedAris(aris);
        const arisWithCloudId = uniqueAris.filter((ari) => ari.resourceType == cli_shared_1.SITE_RESOURCE_TYPE || !!ari.cloudId);
        const arisWithOnlyActivationId = uniqueAris.filter((ari) => ari.resourceType == cli_shared_1.WORKSPACE_RESOURCE_TYPE && !ari.cloudId);
        const [cloudIdArisToHostname, activationIdArisToHostname] = await Promise.all([
            this.bulkQuerySiteHostnames(arisWithCloudId, (ari) => ari.cloudId || ari.resourceId, this.queryHostnamesByCloudIds),
            this.bulkQuerySiteHostnames(arisWithOnlyActivationId, (ari) => ari.resourceId, this.queryHostnamesByActivationIds)
        ]);
        return {
            ...cloudIdArisToHostname,
            ...activationIdArisToHostname
        };
    }
    queryHostnamesByCloudIds = async (cloudIds) => {
        const query = `
        query forge_cli_getHostnameForTenantContexts($cloudIds: [ID!]!) {
            tenantContexts(cloudIds: $cloudIds) {
                hostName
            }
        }
        `;
        const response = await this.graphqlClient.query(query, {
            cloudIds: cloudIds
        });
        return Object.fromEntries(cloudIds.map((id, index) => [
            id,
            response?.tenantContexts?.[index]?.hostName || id
        ]));
    };
    queryHostnamesByActivationIds = async (activationIds) => {
        const query = `
        query forge_cli_getHostnameForTenantContexts($activationIds: [ID!]!) {
            tenantContexts(activationIds: $activationIds) {
                hostName
            }
        }
        `;
        const response = await this.graphqlClient.query(query, {
            activationIds: activationIds
        });
        return Object.fromEntries(activationIds.map((id, index) => [id, response?.tenantContexts?.[index]?.hostName]));
    };
    async bulkQuerySiteHostnames(aris, idExtractor, querySiteHostnameFunction) {
        if (aris.length === 0) {
            return {};
        }
        const idsToQuery = [...new Set(aris.map(idExtractor))];
        const idsChunks = splitArrayToChunks(idsToQuery, 20);
        const chunkedMapping = await Promise.all(idsChunks.map(querySiteHostnameFunction));
        const fullMapping = Object.assign({}, ...chunkedMapping);
        return Object.fromEntries(aris.map((ari) => [ari.toString(), fullMapping[idExtractor(ari)]]));
    }
    async getCloudIdAndActivationId(site, productResourceOwner) {
        const query = `
        query getTenantContextDetails($hostNames: [String!], $product: String!) {
          tenantContexts(hostNames: $hostNames) {
            cloudId
            activationIdByProduct(product: $product) {
              active
            }
          }
        }
        `;
        const result = await this.graphqlClient.query(query, {
            hostNames: [site.hostname],
            product: PRODUCT_RESOURCE_OWNER_TO_TCS_PRODUCT_ID[productResourceOwner] || productResourceOwner
        });
        const tenantContexts = result.tenantContexts || [];
        return tenantContextsToCloudIdAndActivationId(site, tenantContexts, productResourceOwner);
    }
}
exports.SitedProductTranslator = SitedProductTranslator;
//# sourceMappingURL=sited-products.js.map